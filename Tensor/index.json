{
  "articles/Troubleshooting.html": {
    "href": "articles/Troubleshooting.html",
    "title": "Troubleshooting guide | Tensor for F#",
    "keywords": "Troubleshooting guide This page lists possible issues you might encounter and resolutions for them. CUDA GPU backend The following issues are related to using tensors on CUDA GPUs. You get the message Unable to load DLL 'nvcuda': The specified module could not be found. No nVidia GPU driver that supports CUDA is installed. Install the latest GPU driver from http://www.nvidia.com/Download/index.aspx . You get the message The CUBLAS library was not initialized. The installed nVidia GPU driver is too old, i.e. its CUDA capability version is too low for the used CUBLAS version. Install the latest GPU driver from http://www.nvidia.com/Download/index.aspx ."
  },
  "articles/Tensor.html": {
    "href": "articles/Tensor.html",
    "title": "Tensor at a glance | Tensor for F#",
    "keywords": "Tensor at a glance This page provides an overview of most commonly used tensor functions by category. For a complete, alphabetical reference of all tensor functions see Tensor<'T> and the device-specific functions in HostTensor and CudaTensor . Creation functions Use these functions to create a new tensor. Function Description arange Creates a new vector filled with equaly spaced values using a specifed increment. counting Creates a new vector filled with the integers from zero to the specified maximum. empty Creates a new, empty tensor with the given number of dimensions. falses Creates a new boolean tensor filled with falses. filled Creates a new tensor filled with the specified value. identity Creates a new identity matrix. ones Creates a new tensor filled with ones (1). onesLike Creates a new tensor filled with ones using the specified tensor as template. linspace Creates a new vector of given size filled with equaly spaced values. scalar Creates a new zero-dimensional (scalar) tensor with the specified value. scalarLike Creates a new zero-dimensional (scalar) tensor using the specified tensor as template and with the specified value. trues Creates a new boolean tensor filled with trues. zeros Creates a new tensor filled with zeros (0). zerosLike Creates a new tensor filled with zeros using the specified tensor as template. Slicing and element access functions Use these functions to slice tensors or access individual elements of them. Function Description Item Accesses a slice (part) of the tensor. M Picks elements from a tensor using one or more boolean mask tensors. Value Gets the value of a zero-dimensional (scalar) tensor. Element-wise operations These mathematical operations are applied element-wise to each element of the tensor(s). Function Description ( ~- ) Element-wise negation. ( + ) Element-wise addition. ( - ) Element-wise substraction. ( * ) Element-wise multiplication. ( / ) Element-wise division. ( % ) Element-wise remainder of division. Abs Element-wise absolute value. Acos Element-wise arccosine (inverse cosine). Asin Element-wise arcsine (inverse sine). Atan Element-wise arctanget (inverse tangent). Ceiling Element-wise ceiling (round towards positive infinity). Cos Element-wise cosine. Cosh Element-wise hyperbolic cosine. Exp Element-wise exponential function. Floor Element-wise floor (round towards negative infinity). Log Element-wise natural logarithm. Log10 Element-wise common logarithm. Pow Element-wise exponentiation. Round Element-wise rounding. Sgn Element-wise sign. Sin Element-wise sine. Sinh Element-wise hyperbolic sine. Sqrt Element-wise square root. Tan Element-wise tangent. Tanh Element-wise hyperbolic tangent. Truncate Element-wise truncation (rounding towards zero). Tensor operations These functions perform various operations on one or more tensors. Function Description concat Concatenates tensors along an axis. copy Returns a copy of the tensor. diag Returns a view of the diagonal of the matrix. diagAxis Returns a view of the diagonal along the given axes. diagMat Creates a matrix with the specified diagonal. diagMatAxis Creates a tensor with the specified diagonal along the given axes. diff Calculates the difference between adjoining elements of the vector. diffAxis Calculates the difference between adjoining elements along the specified axes. ofBlocks Builds a tensor out of tensor blocks. replicate Repeats the tensor along an axis. T Transpose of a matrix. Linear algebra functions Use these functions to perform basic linear algebra operations on tensors. Function Description ( .* ) Computes the (batched) matrix product, (batched) matrix-vector product or scalar product. norm Calculates the norm of the (flattened) tensor. normAxis Calculates the norm along the specified axis. invert (Batch) inverts a matrix. pseudoInvert Computes the (batched) Moore-Penrose pseudo-inverse of the specified matrix. SVD Computes the (batched) singular value decomposition (SVD) of the specified matrix. symmetricEigenDecomposition Computes the (real) eigendecomposition of a symmetric matrix. tensorProduct Computes the tensor product between two tensors. Shape functions Use these functions to work with the shape and memory layout of a tensor. Function Description atLeastND Pads the tensor from the left with size-one dimensions until it has at least the specified number of dimensions. broadcastDim Broadcast a dimension to a specified size. broadcastTo Broadcasts the specified tensor to the specified shape. broadcastToSame Broadcasts all specified tensors to have the same shape. broadcastToSameInDims Broadcasts all specified tensors to have the same size in the specified dimensions. cutLeft Removes the first dimension. cutRight Removes the last dimension. flatten Flattens the tensor into a (one-dimensional) vector. insertAxis Insert a dimension of size one before the specifed dimension. isBroadcasted Checks if the specified tensor is broadcasted in at least one dimension. Layout Memory layout of the tensor. NDims Dimensionality of the tensor. NElems Total number of elements within the tensor. padLeft Insert a dimension of size one as the first dimension. padRight Append a dimension of size one after the last dimension. padToSame Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. permuteAxes Permutes the axes as specified. reshape Changes the shape of a tensor. reverseAxis Reverses the elements in the specified dimension. relayout Creates a tensor with the specified layout sharing its storage with the original tensor. Shape Shape of the tensor. swapDim Swaps the specified dimensions of the tensor. Data type functions Use these functions to query or change the data type of the elements of a tensor. Function Description convert Convert the elements of a tensor to the specifed type. DataType Type of data stored within the tensor. Device and storage functions Use these functions to query or change the storage device of a tensor. Function Description Dev Device the data of tensor is stored on. Storage The storage object that holds the data of this tensor. transfer Transfers a tensor to the specifed device. Comparison functions Use these functions to perform comparisons of tensors. The results are mostly boolean tensors. Function Description ( ==== ) Element-wise equality test. ( <<<< ) Element-wise less-than test. ( <<== ) Element-wise less-than-or-equal test. ( >>>> ) Element-wise greater-than test. ( >>== ) Element-wise greater-than-or-equal test. ( <<>> ) Element-wise not-equality test. almostEqual Checks if two tensors have the same (within machine precision) values in all elements. isClose Element-wise check if two tensors have same (within machine precision) values. isFinite Element-wise finity check (not -Inf, Inf or NaN). maxElemwise Element-wise maximum. minElemwise Element-wise minimum. allFinite Checks that all elements of the tensor are finite. Logical functions Use these functions to work with boolean tensors. Function Description ( ~~~~ ) Element-wise logical negation. ( &&&& ) Element-wise loigcal and. ( |||| ) Element-wise loigcal or. ( ^^^^ ) Element-wise loigcal xor. all Checks if all elements of the tensor are true. allAxis Checks if all elements along the specified axis are true. allElems Gets a sequence of all all elements within the tensor. allTensor Checks if all elements of the tensor are true returning the result as a tensor. any Checks if any elements of the tensor are true. anyAxis Checks if any element along the specified axis is true. anyTensor Checks if any element of the tensor is true returning the result as a tensor. countTrue Counts the elements being true. countTrueAxis Counts the elements being true along the specified axis. ifThenElse Element-wise choice between two sources depending on a condition. Index functions These functions return tensor of indices or work with them. Function Description allIdx Gets a sequence of all indices to enumerate all elements within the tensor. argMax Finds the indicies of the maximum value of the tensor. argMaxAxis Finds the index of the maximum value along the specified axis. argMin Finds the indicies of the minimum value of the tensor. argMinAxis Finds the index of the minimum value along the specified axis. find Finds the first occurence of the specfied value and returns its indices. findAxis Finds the first occurence of the specfied value along the specified axis and returns its index. gather Selects elements from a tensor according to specified indices. scatter Disperses elements from a source tensor to a new tensor according to the specified indices. trueIdx Finds the indices of all element that are true. Reduction functions These functions perform operations on tensors that reduce their dimensionality. Function Description max Calculates the maximum of all elements. maxAxis Calculates the maximum value of the elements along the specified axis. min Calculates the minimum of all elements. minAxis Calculates the minimum value of the elements along the specified axis. mean Calculates the mean of the tensor. meanAxis Calculates the mean of the elements along the specified axis. product Calculates the product of all elements. productAxis Calculates the product of the elements along the specified axis. std Calculates the standard deviation of the tensor. stdAxis Calculates the standard deviation of the elements along the specified axis. sum Sums all elements. sumAxis Sums the elements along the specified axis. var Calculates the variance of the tensor. varAxis Calculates the variance of the elements along the specified axis. trace Calculates the trace of the matrix. traceAxis Calculates the trace along the specified axes. Functional operations (host only) Use these functions to perform operations that are common in functional programming languages. They require the tensor to be stored in host memory. Function Description HostTensor.foldAxis Applies to specified function to all elements of the tensor, threading an accumulator through the computation. HostTensor.init Creates a new tensor with values returned by the specified function. HostTensor.map Applies to specified function to all elements of the tensor. HostTensor.map2 Applies to specified function to all elements of the two tensors. HostTensor.mapi Applies to specified indexed function to all elements of the tensor. HostTensor.mapi2 Applies to specified indexed function to all elements of the two tensors. Data exchange (host only) Use these functions to convert tensors to and from other storage modalities. They require the tensor to be stored in host memory. Function Description HostTensor.ofArray Creates a one-dimensional tensor copying the specified data. HostTensor.ofList Creates a one-dimensional tensor from the specified list. HostTensor.ofSeq Creates a one-dimensional tensor from the specified sequence. HostTensor.read Reads a tensor from the specified HDF5 object path in an HDF5 file. HostTensor.readUntyped Reads a tensor with unspecified data type from the specified HDF5 object path in an HDF5 file. HostTensor.toArray Creates an array from a one-dimensional tensor. HostTensor.toList Creates a list from a one-dimensional tensor. HostTensor.toSeq A sequence of all elements contained in the tensor. HostTensor.usingArray Creates a one-dimensional tensor referencing the specified data. HostTensor.write Writes the tensor into the HDF5 file under the specfied HDF5 object path. Random number generation (host only) Use these functions to generate tensors filled with random numbers. Function Description HostTensor.randomInt Creates a tensor filled with random integer numbers from a uniform distribution. HostTensor.randomNormal Creates a tensor filled with random numbers from a normale distribution. HostTensor.randomUniform Creates a tensor filled with random floating-point numbers from a uniform distribution."
  },
  "articles/Status.html": {
    "href": "articles/Status.html",
    "title": "Status | Tensor for F#",
    "keywords": "Status The library is nearly feature complete, but some limitations exists that we hope to resolve in the near future. Current limitations Although we use 64-bit indices, tensors stored on the host are internally limited to 32-bit indices and thus to a maximum of 2,147,483,647 elements. This limitation is imposed by using .NET arrays as the storage backend for tensors stored on the host. We will implement a backend using native (unmanaged) host memory to work around this limitation. This limitation does not apply to tensors stored on CUDA GPUs. On CUDA GPUs only primitive data types (like single, float, boolean, int) are supported. The following operations are not yet implemented on CUDA GPUs. Invoking them will raise an exception. masking countTrue trueIdx SVD symmetricEigendecomposition Some useful linear algebra functions like LU and QR decomposition are missing. No standarized interface for exposing tensors to native code is yet available. However, getting pointers to their memory already works fine. MacOS has no GPU acceleration due to the lack of development hardware. No backend exists yet for OpenCL hardware and thus AMD and Intel GPUs are not supported. The host backend is currently hard coded to use Intel MKL as its BLAS library. It would be nice, if we could dynamically switch the BLAS library, for example to use the free OpenBLAS . Don't be shy to get involved with development and submit pull requests at https://github.com/DeepMLNet/DeepNet/pulls . Issues Issues are tracked via GitHub at https://github.com/DeepMLNet/DeepNet/issues . API stability Until we reach version 1.0 the API is not guaranteed to be stable. Function signatures may change in incompatible ways or functions may be removed altogether."
  },
  "articles/ReleaseNotes.html": {
    "href": "articles/ReleaseNotes.html",
    "title": "Release notes | Tensor for F#",
    "keywords": "Release notes 0.4.9 Remove type constraints on Tensor.arange and Tensor.linspace. 0.4.8 Support for dynamic loading of BLAS libraries for host tensors. Use Tensor.Host.Cfg.BLASLib to configure. 0.4.7 Experimental support for macOS (without CUDA). 0.4.6 Fix double-precision BLAS operations on CUDA GPU. 0.4.5 No changes. 0.4.4 Fix tensor_mkl.dll not being found. Update Tensor.Sample sample project. Add SourceLink support (experimental). 0.4.3 Documentation improvements. Add Tensor.Sample sample project. 0.4.2 Improve CUDA and CUBLAS initialization. 0.4.1 First version to support .NET Standard 2.0. Optimized host backend. Redesigned API."
  },
  "articles/Guide-Shape.html": {
    "href": "articles/Guide-Shape.html",
    "title": "Shape operations | Tensor for F#",
    "keywords": "Shape operations The shape of a tensor specifies the highest valid index for each dimension. Getting the shape The shape of a tensor can be accessed using the Shape property. It is returned as an F# list. The rank (number of dimensions) can be accessed using the NDims property. The number of elements can be accessed using the NElems property. The following example shows the basic usage of these properties. printfn \"a has shape %A, rank %d and %d elements.\" a.Shape a.NDims a.NElems // a has shape [7L; 5L], rank 2 and 35 elements. Reshaping Reshaping changes the shape of the tensor while keeping the number of elements constant. For example consider the 4x4 matrix b , that is created as follows. let b = HostTensor.init [4L; 4L] (fun [|y; x|] -> 4 * int y + int x) // b = // [[ 0 1 2 3] // [ 4 5 6 7] // [ 8 9 10 11] // [ 12 13 14 15]] We can use the Tensor.reshape function to transform this matrix into a vector of length 16 . let b1 = Tensor.reshape [16L] b // b1 = [ 0 1 2 3 4 5 ... 12 13 14 15] We can also specify the special identifier Remainder for the new size of at most one dimension. In this case, its size will be chosen automatically (so that the number of elements does not change). In the following example tensor b is reshaped into a three dimensional tensor of shape 4x2x2 . let b2 = Tensor.reshape [4L; 2L; Remainder] b // b2 = // [[[ 0 1] // [ 2 3]] // [[ 4 5] // [ 6 7]] // [[ 8 9] // [ 10 11]] // [[ 12 13] // [ 14 15]]] View or copy? If the tensor to reshape has row-major memory layout, then Tensor.reshape creates a new view into the existing tensor. Otherwise the tensor is copied during the reshape operation. If you need to ensure that no copy is performed, i.e. the original and reshaped tensor share the same memory, use the Tensor.reshapeView function instead. It will raise an error, if creating a reshaped view of the original tensor is impossible. Reordering axes and transposing The Tensor.swapDim function creates a new view of a tensor with the given dimensions swapped. For example, the following code transpose the matrix b . let b3 = Tensor.swapDim 0 1 b // b3 = // [[ 0 4 8 12] // [ 1 5 9 13] // [ 2 6 10 14] // [ 3 7 11 15]] The original and tensor with swapped axes share the same memory and modifications made to one of them will affect the other one. A matrix can also be transposed using the Tensor.transpose function or the T property, i.e. b.T means transpose of matrix b . The Tensor.permuteAxes function can reorder axes arbitrarily. It takes a list (of length equal to the rank of the tensor) with each element specifying the new position of the corresponding axis. The list must be a permutation of the axes indices, i.e. duplicating or leaving out axes is not permitted. For the rank three tensor b2 from above, the following example code creates the view b4 with shape 2x2x4 . let b4 = Tensor.permuteAxes [2; 0; 1] b2 // b4.Shape = [2L; 2L; 4L] It is important to understand that each list entry specifies where the axis moves to , not where it is coming from. Thus, in this example, axis 0 becomes axis 2, axis 1 becomes axis 0 and axis 2 becomes axis 1. Adding axes The Tensor.padLeft and Tensor.padRight functions add a new axis of size one on the left or right respectively. If you need to add an axis at another position, use the slicing operator with the special NewAxis identifier. The following example creates a view of shape 2x2x1x4 . let b5 = b4.[*, *, NewAxis, *] // b5.Shape = [2L; 2L; 1L; 4L] Broadcasting An axis of size one can be repeated multiple times with the same value. This is called broadcasting. Consider the 1x4 matrix c created using the following code. let c = HostTensor.init [1L; 4L] (fun [|_; i|] -> int i) // c = [[ 0 1 2 3]] We can use the Tensor.broadcastTo function to obtain a tensor with the first dimension repeated 3 times. let c1 = Tensor.broadcastTo [3L; 4L] c // c1 = // [[ 0 1 2 3] // [ 0 1 2 3] // [ 0 1 2 3]] Broadcasting creates a view of the original tensor, thus the repeated dimensions do not use additional memory and changing the broadcasted view will also change the original as well as all indices of a broadcasted dimension. This is demonstrated by the following example. c1.[[1L; 1L]] <- 11 // c1 = // [[ 0 11 2 3] // [ 0 11 2 3] // [ 0 11 2 3]] // c = [[ 0 11 2 3]] Automatic broadcasting Broadcasting is also performed automatically when performing element-wise operations between two tensors of different, but compatible, shapes. This will be explained in the section about tensor operations of the guide."
  },
  "articles/Guide-Save-and-Load.html": {
    "href": "articles/Guide-Save-and-Load.html",
    "title": "Save and load | Tensor for F#",
    "keywords": "Save and load The primary data storage format is HDF5. For compatibility, Numpy files can also be read. Disk storage in HDF5 format Tensors can be stored in and read from industry-standard HDF5 files . Multiple tensors can be stored in a single HDF5 file and accessed by assigning names to them. An opened HDF5 file is represented by an HDF5 object . To close the file, dispose this object. Writing tensors to disk Use the HostTensor.write function to write a tensor to an HDF5 file opened for writing. The following code creates two tensors k and l and writes them into the HDF5 file tensors.h5 in the current directory. let k = HostTensor.init [5L; 3L] (fun [|i; j|] -> 3.0 * float i + float j) let l = HostTensor.init [5L] (fun [|i|] -> 2.0 * float i) use hdfFile = HDF5.OpenWrite \"tensors.h5\" HostTensor.write hdfFile \"k\" k HostTensor.write hdfFile \"l\" l Tensor must be stored in host memory, before they can be written to disk. Loading tensors from disk Use the HostTensor.read function to read a tensor from an HDF5 file opened for reading. The following code loads the tensors k and l from the previously created HDF5 file tensors.h5 and stores them in the variables k2 and l2 . use hdfFile2 = HDF5.OpenRead \"tensors.h5\" let k2 = HostTensor.read<float> hdfFile2 \"k\" let l2 = HostTensor.read<float> hdfFile2 \"l\" The data types of k2 and l2 must be specified explicitly, since they must be known at compile-time. If the declared data type does not match the data type encountered in the HDF5 file, an exception will be raised. If the data type is unknown at compile time, you can use the HostTensor.readUntyped function instead. Viewing and working with HDF5 files The resulting file can be viewed using any HDF5 viewer, for example using the free, cross-platform HDFView application as shown below. Many useful tools for working with HDF5 file are provided at https://support.hdfgroup.org/products/hdf5_tools/toolsbycat.html . Reading .npy and .npz files produced by Numpy For compatibility, it is possible to read .npy and .npz files produced by Numpy. Not all features of the format are supported. Writing .npy and .npz files is not possible and the HDF5 format should be instead. Use the NPYFile.load function to read an .npy file and return its contents as a tensor. Use the NPZFile.Open function to open an .npz file and the Get method of the resulting object to obtain individual entries as tensors."
  },
  "articles/Guide-Reductions.html": {
    "href": "articles/Guide-Reductions.html",
    "title": "Reduction operations | Tensor for F#",
    "keywords": "Reduction operations Reduction functions are function that reduce the number of dimensions of a tensor by combining multiple elements into a single element. Summation is an example of such an operation, since it takes multiple input values and outputs a single value. Summation The Tensor.sum function computes the sum of all elements of a tensor and returns it as a primitive value. let s1 = Tensor.sum f // s1 = 66.0 If you want the result to be returned as a scalar tensor instead of a primitive value, use the Tensor.sumTensor function instead. This is useful for tensors stored on the GPU if the result is used for furhter computation, since it avoids the transfer back to host memory. Often it is necessary to compute many sums in parallel, for example it might be interesting to compute the sums of all columns of a matrix. For this purpose, the tensor library provides the Tensor.sumAxis function. The following example illustrates its usage. let g = HostTensor.init [4L; 4L] (fun [|y; x|] -> 4 * int y + int x) // g = // [[ 0 1 2 3] // [ 4 5 6 7] // [ 8 9 10 11] // [ 12 13 14 15]] let s2 = Tensor.sumAxis 0 g // s2 = [ 24 28 32 36] This computed the sums of all columns of the matrix, thus resulting in a vector. In general, the result tensor of a reduction function that ends in Axis (i.e. Tensor.sumAxis , Tensor.productAxis , etc.) has one dimension less than the input tensor. Product Likewise Tensor.product and Tensor.productAxis compute the product of the elements of a tensor. Maximum and minimum The Tensor.min and Tensor.max compute the minimum and maximum of a tensor and return a primitive value. Analogously Tensor.minAxis and Tensor.maxAxis compute the minimum and maximum over the given axis. let m2 = Tensor.maxAxis 0 g // m2 = [ 12 13 14 15] Mean and variance The Tensor.mean and Tensor.var compute the emperical mean and variance of a tensor. Variants computing the mean and variance along the specified axis are Tensor.meanAxis and Tensor.varAxis respectively."
  },
  "articles/Guide-Operations.html": {
    "href": "articles/Guide-Operations.html",
    "title": "Tensor operations | Tensor for F#",
    "keywords": "Tensor operations The tensor type supports all standard arithmetic operators and arithmetic functions. Element-wise arithmetic operators The elementary arithmetic operators ( + , - , * , / , % , ** , ~- ) are executed element-wise. For example, consider the vectors d and e , that are initialized as follows. let d = HostTensor.init [4L] (fun [|i|] -> float i) let e = HostTensor.init [4L] (fun [|i|] -> 10.0 * float i) // d = [ 0.0000 1.0000 2.0000 3.0000] // e = [ 0.0000 10.0000 20.0000 30.0000] Then we can perform an element-wise addition using the following code. let f = d + e // f = [ 0.0000 11.0000 22.0000 33.0000] It is also possible to apply an operator to a tensor and a scalar value of the same data type. In this case the scalar is repeated to match the size of the given tensor, as shown in the following example. let d1 = d * 100.0 // d1 = [ 0.0000 100.0000 200.0000 300.0000] Automatic broadcasting If a binary operator (for example + ) is applied to two tensors of different shapes, the library tries to automatically broadcast both tensors to a compatible shape using the following rules. If the tensors have different ranks, the tensor with the lower rank is padded from the left with axes of size one until both tensors have the same rank. For example, if tensor a is of shape 4x3x1 and tensor b is of shape 2 , then tensor b is padded to the shape 1 x 1 x2. For each dimension that has different size in both tensors and size one in one of the tensors, this dimension of the tensor with size one is broadcasted to the corresponding dimension of the other tensor. Thus, in our example, the last dimension of tensor a is broadcasted resulting in the shape 4x3x 2 and the first and second dimensions of tensor b (after padding it is of shape 1x1x2 ) are broadcasted, resulting in the shape 4 x 3 x2. If the shapes still differ after applying the above rules, the operation fails and an exception is raised. let a = HostTensor.init [4L; 3L; 1L] (fun [|i; j; k|] -> float i + 0.1 * float j) let b = HostTensor.init [2L] (fun [|i|] -> 10.0 * float i) // a = // [[[ 0.0000] // [ 0.1000] // [ 0.2000]] // [[ 1.0000] // [ 1.1000] // [ 1.2000]] // [[ 2.0000] // [ 2.1000] // [ 2.2000]] // [[ 3.0000] // [ 3.1000] // [ 3.2000]]] // b = [ 0.0000 10.0000] let apb = a + b // apb = // [[[ 0.0000 10.0000] // [ 0.1000 10.1000] // [ 0.2000 10.2000]] // [[ 1.0000 11.0000] // [ 1.1000 11.1000] // [ 1.2000 11.2000]] // [[ 2.0000 12.0000] // [ 2.1000 12.1000] // [ 2.2000 12.2000]] // [[ 3.0000 13.0000] // [ 3.1000 13.1000] // [ 3.2000 13.2000]]] // apb.Shape = [4L; 3L; 2L] Storage devices must match All tensors participating in an operation must be located on the same storage device, i.e. their Dev property must be equal. The result will be stored on the same device as the sources. No automatic transfer between different devices (e.g. GPU and host memory) is performed; instead an exception is raised. If working with tensors stored on different devices, you first have to use the transfer function to copy them to the same device, before applying an operator on them. Element-wise arithmetic and rounding functions The standard F# arithmetic functions, such as sin , exp , log , and rounding functions, such as floor and ceil , can also be applied to tensors. They execute element-wise, just like the arithmetic operators presented above. let f2 = sin f // f2 = [ 0.0000 -1.000 -0.009 0.9999] Specifying where the result should be stored Sometimes you might want to specify in which (existing) tensor the result of an operation should be stored. For this purpose there exist a corresponding Fill* variant of each operation provided by the tensor library. For example, for the multiply operator (*) , there exist the FillMultiply variant, which also performs a multiplication, but stores the result in the specified target tensor. The previous contents of the target tensor are thereby overwritten. The target tensor must have appropriate shape and data type to hold the result of the operation. Also it must reside on the same device as the source(s) of the operation. The following example illustrates the use of the Fill* functions. // f3 = [ -1.0000 -1.0000 29.0000 40.0000] f3.FillMultiply d e // f3 = [ 0.0000 10.0000 40.0000 90.0000] It is also possible to perform operations in-place. This means that one of the inputs of an operation is overwritten by the output. f3.FillMultiply f3 e // f3 = [ 0.0000 100.0000 800.0000 2700.0000] This is especially useful when working with very large tensors and thus care must be taken to conserve memory usage. You can find the Fill* variants of each operation by checking the \" see also \" section in its reference documentation. Matrix multiplication (dot product) Matrix multiplication (dot product) is implemented using the .* operator . This operator can be used to calculate a vector/vector product resulting in a scalar, a matrix/vector product resulting in a vector and a matrix/matrix product resulting in a matrix. If the inputs have more than two dimensions, a batched matrix/matrix product is computed. The following example shows how to compute the matrix product of the 5x3 matrix h with the 3x3 matrix i , resulting in the 5x3 matrix hi . let h = HostTensor.init [5L; 3L] (fun [|i; j|] -> 3.0 * float i + float j) // h = // [[ 0.0000 1.0000 2.0000] // [ 3.0000 4.0000 5.0000] // [ 6.0000 7.0000 8.0000] // [ 9.0000 10.0000 11.0000] // [ 12.0000 13.0000 14.0000]] let i = 0.1 + HostTensor.identity 3L // i = // [[ 1.1000 0.1000 0.1000] // [ 0.1000 1.1000 0.1000] // [ 0.1000 0.1000 1.1000]] let hi = h .* i // hi = // [[ 0.3000 1.3000 2.3000] // [ 4.2000 5.2000 6.2000] // [ 8.1000 9.1000 10.1000] // [ 12.0000 13.0000 14.0000] // [ 15.9000 16.9000 17.9000]] Linear algebra operations The diagonal of a matrix can be extracted using the diag function. To create a diagonal matrix with specific elements on the diagonal use the diagMat function. The norm can be computed using the norm and normAxis functions. To invert a square, invertable matrix use the invert function. However, this may be numerically instable, especially if the condition number of the matrix is low. Thus it is usually better, but also more expensive, to compute the Moore-Penrose pseudo-inverse using the pseudoInvert function. This is also applicable to non-square and non-invertable matrices. let iinv = Tensor.invert i // iinv = // [[ 0.9231 -0.077 -0.077] // [ -0.077 0.9231 -0.077] // [ -0.077 -0.077 0.9231]] The singular value decomposition (SVD) of a matrix is available through SVD . The eigen-decomposition of a symmetric matrix can be computed using the symmetricEigenDecomposition function. The tensor product (pairwise product between all elements of two tensors) between two tensors can be obtained using the the tensorProduct function. Concatenation and block tensors Tensors can be concatenated along an axis using the concat function. To replicate a tensor along an axis use the replicate function. A tensor built out of smaller tensors block can be created using the ofBlocks function. Element-wise function application (host-only) For tensors stored in host memory, it is also possible to apply an arbitrary function element-wise using the HostTensor.map function. let f3 = HostTensor.map (fun x -> if x > 15.0 then 7.0 + x else -1.0) f // f3 = [ -1.0000 -1.0000 29.0000 40.0000] Likewise, the HostTensor.map2 function takes two tensors and applies a binary function to their elements. Indexed variants of both function are provided by HostTensor.mapi and HostTensor.mapi2 . The HostTensor.foldAxis applies a function along the specified axis of a tensor and threads an state through the computation. Further algorithms Further algorithms are provided in the Tensor.Algorithm namespace ."
  },
  "articles/Guide-Logic.html": {
    "href": "articles/Guide-Logic.html",
    "title": "Comparison and logic operations | Tensor for F#",
    "keywords": "Comparison and logic operations Comparison is used to element-wise compare the elements of two tensors resulting in a boolean tensor containing the comparison results. Several operations that can be performed with boolean tensors are described on this page. Element-wise comparison operators Element-wise comparisons are performed using the ==== (element-wise equal) , <<<< (element-wise smaller than) , >>>> (element-wise greater than) and <<>> (element-wise not equal) operators. These operators return tensors of boolean data type. The following example compares the elements of tensors d and e for equality. let d = HostTensor.ofList [0; 1; 2; 3] let e = HostTensor.ofList [0; 10; 2; 30] let j = d ==== e // j = [true; false; true; false] Floating-point accuracy When working with floating-point tensors, testing for exact equality is usually not a good approach, since it does not take into account inaccuracies that are introduced by the finite precision of floating-point data types. Thus exact comparisions may return false even though two result are equal within the precision that can be expected from floating-point operations. Therefore, a better approach for floating-point number is to use the isClose function, that checks for element-wise equality within machine precision. To check whether all elements of two tensors are equal within machine precision, use the almostEqual function. Element-wise logic operators Boolean tensors support the following element-wise logic operators ~~~~ (element-wise negation) , &&&& (element-wise and) , |||| (element-wise or) and ^^^^ (element-wise xor) . The following example shows how to negate a boolean tensor and perform an and operation. let nj = ~~~~j // nj = [false true false true ] let jnj = j &&&& nj // jnj = [false false false false] As expected, the result of anding an element and its negation is always false . Indicies of true elements The trueIdx finds all true elements within a boolean tensors and returns their indices as a new tensor. The following example illustrates its use. let a = HostTensor.ofList2D [[true; false; true; false] [false; true; true; false]] let b = Tensor.trueIdx a // b = [[0L; 0L] // [0L; 2L] // [1L; 1L] // [1L; 2L]] If/then/else operation Sometimes it is desirable to select an element from either a tensor or another, depending on the truth value of a condition. For example, r.[1] should be 5 if c.[1] is true , but 7 if c.[1] is false . The ifThenElse function provides this functionality. It takes a boolean condition tensor, a tensor for the values to use if the condition is true and a tensor for the values to use if the conditions is false . All three tensors must be of same shape. The following example demonstrates the use of this function. let cond = HostTensor.ofList [true; false; false] let ifTrue = HostTensor.ofList [2.0; 3.0; 4.0] let ifFalse = HostTensor.ofList [5.0; 6.0; 7.0] let t = Tensor.ifThenElse cond ifTrue ifFalse // t = [2.0; 6.0; 7.0] Masking tensors with boolean tensors Boolean tensors can be used to select elements from another tensor. This is operation is called masking and picks elements from the tensor for which the corresponding element in the mask tensor is true . Masking is performed by using the M property of a tensor and specifying a boolean tensor as argument. The property can be used for reading and for assignment. Reading for the property always returns a copy of the data. If the mask tensor has the same shape as the value tensor, the result is always a vector, regardless of the dimensionality of both tensors. The following example shows this use case. let a = HostTensor.ofList2D [[1.0; 2.0; 3.0] [4.0; 5.0; 6.0]] let m = HostTensor.ofList2D [[true; true; false] [false; false; true ]] let b = a.M(m) // b = [1.0; 2.0; 6.0] If a particular dimension should not be masked, the special identifier NoMask can be specified instead. For example, this allows to select whole rows or columns of a matrix and is illustrated in the next code segment. let m0 = HostTensor.ofList [true; false] let e = a.M(m0, NoMask) // e = [[1.0; 2.0; 3.0]] You can also assign to the M property and therefore replace the elements within the original tensor, for which the mask tensor contains true entries. The number of elements in the assignment vector must match the number of true entries in the mask tensor. Otherwise an exception is raised. The following example shows how to replace elements within a tensor using a boolean mask. let m = HostTensor.ofList2D [[true; true; false] [false; false; true ]] a.M(m) <- HostTensor.ofList [8.0; 9.0; 0.0] // a = [[8.0; 9.0; 3.0] // [4.0; 5.0; 0.0]] Logical reduction operations Similar to the standard reduction operations like summation, boolean tensors provide additional reduction operations specifically for then need of logic operations. Check if all elements are true The all function checks whether all elements within a boolean tensor are true . The result is returned as a primitive boolean. If an empty tensor is specified, it also returns true . The following example demonstrates its use. let aj = Tensor.all j // aj = false The allAxis function performs the same check, but in parallel for all elements along the specified axis. In the following example it is used to check if all entries within a column of a matrix are true . let g = HostTensor.ofList2D [[true; false; false; true] [true; false; true; false]] let ga = Tensor.allAxis 0 g // ga = [true; false; false; false] Check if any element is true To check whether at least one element in a tensor is true , use the any function. If an empty tensor is specified, it returns false . The anyAxis function performs the same check, but in parallel for all elements along the specified axis. Count true elements The countTrue and countTrueAxis count the number of true elements within a boolean tensor or along the specified axis respectively."
  },
  "articles/Guide-Installation.html": {
    "href": "articles/Guide-Installation.html",
    "title": "Installation and testing | Tensor for F#",
    "keywords": "Installation and testing This page guides you through installing the Tensor library and creating a skeleton project for experimentation. System requirements The following system requirements must be met. System architecture: x86-64 (AMD64 or Intel 64) Operating system: Linux, MacOS or Microsoft Windows Microsoft .NET Standard 2.0 implementation Recommended platform is .NET Core >= 2.0 .NET Framework >= 4.7 is supported Mono >= 5.10 is supported, but significantly slower For MacOS HDF5 libraries (install from Homebrew by running brew install hdf5 ) For GPU acceleration (optional) nVidia GPU supporting CUDA compute capability 3.5 or higher CUDA SDK 8.0 installed (exact version) CUDA driver installed and working Installation The library is provided as a NuGet package. Since we have made modifications (porting to .NET core) to our dependencies and these changes have not yet been merged upstream, a MyGet feed is currently used to deliever the library and its modified dependencies. Once all necessary modifications have been merged upstream, the Tensor library will be delivered via standard NuGet . For MacOS you must make sure that the HDF5 libraries are installed on your system. They can be installed via Homebrew by running brew install hdf5 . The library is deliverd in two NuGet packages. The Tensor NuGet package provides the Tensor<'T> type and all core functions. Additional algorithms and data exchange methods are provided in the Tensor.Algorithm NuGet package . The packages can be installed into your project by performing the following steps. Add the NuGet feed https://www.myget.org/feed/Packages/coreports to your project. This can be done by adding the line <add key=\"CorePorts\" value=\"https://www.myget.org/F/coreports/api/v3/index.json\"/> to the packageSources section of your project NuGet.config file. Install the Tensor and Tensor.Algorithm using the NuGet package manager (either via command line or graphical interface). Skeleton project for .NET Core In the course of this tutorial you will use the following skeleton project for experimentation. We assume that you are using .NET Core 2.0 on either Linux or Windows for the rest of the tutorial. To create the skeleton project run the following commands. $ mkdir tutorial $ cd tutorial $ dotnet new console -lang F# Then, create the file NuGet.config in the project directory with the following contents. <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"CorePorts\" value=\"https://www.myget.org/F/coreports/api/v3/index.json\" /> </packageSources> </configuration> Finally run the following commands to install the Tensor library into your project. $ dotnet add package Tensor $ dotnet add package Tensor.Algorithm Basic verificiation test To verify that the installation was successful you can perform a basic test of the library. Place the following code into Program.fs . open Tensor [<EntryPoint>] let main argv = let x = HostTensor.counting 6L printfn \"x = %A\" x 0 If everything works fine, dotnet run automatically builds your project and produces the following output. $ dotnet run x = [ 0 1 2 3 4 5] GPU acceleration verification test By changing HostTensor to CudaTensor inside Program.fs and executing dotnet run , you can test if GPU acceleration works properly. Source code and issues The source code of the Tensor library is available at https://github.com/DeepMLNet/DeepNet . You can also directly reference the Tensor.fsproj and Tensor.Algorithm.fsproj projects inside the source tree from your project by using dotnet add reference <path> . This is useful if you want to modify the Tensor library itself or for debugging. Please report issues via https://github.com/DeepMLNet/DeepNet/issues and submit your pull requests via https://github.com/DeepMLNet/DeepNet/pulls ."
  },
  "articles/Guide-Index.html": {
    "href": "articles/Guide-Index.html",
    "title": "Index functions | Tensor for F#",
    "keywords": "Index functions Index functions are functions for working with indices of tensors. Sequence of all indices The Tensor.allIdx function returns a sequence of indices that sequentially enumerate all elements within the specified tensor. let a = HostTensor.zeros<int> [2L; 3L] let s = Tensor.allIdx a // s = seq [[0L; 0L]; [0L; 1L]; [0L; 2L]; [1L; 0L]; [1L; 1L]; [1L; 2L]] Indices of maximum and minimum The Tensor.argMax and Tensor.argMin return the index of the element with the highest or lowest value within the tensor. Using them on an empty tensor raises an exception. let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.argMax a // b = [1L; 3L] The above example finds the index of the largest element of the matrix a , which is 8.0 at position 1,3 . As with reduction operations, there exist variants of these functions that work along a specified axis of the tensor. The Tensor.argMaxAxis and Tensor.argMinAxis find the highest or lowest elements along the specified axis and return them as a tensor as indices. let b = Tensor.argMaxAxis 1 a // b = [3L; 3L] The above example finds the maximum values along each row of matrix a , which are located at 0,3 and 1,3 . Find index of specified value The Tensor.tryFind function searches for the specified value and returns the index of its first occurence as an option value. let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 3.0]] let b = Tensor.tryFind 3.0 a // b = Some [0L; 2L] If you want to find the first occurence of a value along a specific axis, use the Tensor.findAxis function. let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 3.0]] let b = Tensor.findAxis 3.0 1 a // b = [2L; 3L] If the specified value is not present, this function returns the special value NotFound instead. Indices of all true values For boolean tensors, the Tensor.trueIdx function returns all indices corresponding to true entries in the tensor. let a = HostTensor.ofList2D [[true; false; true; false] [false; true; true; false]] let b = Tensor.trueIdx a // b = [[0L; 0L] // [0L; 2L] // [1L; 1L] // [1L; 2L]] Gathering and scattering by index The gather and scatter operations use a source tensor and a tensor of indices to build a new tensor. They are useful for building lookup tables. Gather The Tensor.gather function gathers elements from a source tensor using the indices specified in the index tensor. In the following example, we gather the elements with the indices 1,3 , 2,1 , 0,0 and 0,3 from the matrix src and store them in the new tensor g . let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3] [1.0; 1.1; 1.2; 1.3] [2.0; 2.1; 2.2; 2.3]] let i0 = HostTensor.ofList [1L; 2L; 0L; 0L] let i1 = HostTensor.ofList [3L; 1L; 0L; 3L] let g = Tensor.gather [Some i0; Some i1] src // g = [1.3000 2.1000 0.0000 0.3000] If any index is out of range, an exception is raised. You can also specify None instead of an index tensor for a particular dimension to assume an identity mapping. The following example demonstrates this by selecting the indices 0,3 , 1,1 and 2,0 from the matrix src . let j1 = HostTensor.ofList [3L; 1L; 0L] let g2 = Tensor.gather [None; Some j1] src // g2 = [0.3000 1.1000 2.0000] Scatter The Tensor.scatter function can be thought of as the inverse operation of gathering. It takes the elements from the source tensor and writes them into the locations specified by the index tensor. If the same index occurs multiple times, all elements written to it are summed. If a location of the target tensor never occurs, its value will be zero. The following example sums the first row of matrix src into element 0,3 of result tensor s . It further swaps rows 1 and 2 of matrix src . Since row 3 of result tensor s is not referenced, its values are all zero. let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3] [1.0; 1.1; 1.2; 1.3] [2.0; 2.1; 2.2; 2.3]] let i0 = HostTensor.ofList2D [[0L; 0L; 0L; 0L] [2L; 2L; 2L; 2L] [1L; 1L; 1L; 1L]] let i1 = HostTensor.ofList2D [[3L; 3L; 3L; 3L] [0L; 1L; 2L; 3L] [0L; 1L; 2L; 3L]] let s = Tensor.scatter [Some i0; Some i1] [4L; 4L] src // s = // [[ 0.0000 0.0000 0.0000 0.6000] // [ 2.0000 2.1000 2.2000 2.3000] // [ 1.0000 1.1000 1.2000 1.3000] // [ 0.0000 0.0000 0.0000 0.0000]]"
  },
  "index.html": {
    "href": "index.html",
    "title": "Tensor for F# | Tensor for F#",
    "keywords": "Tensor for F# A tensor is an n-dimensional array of an arbitrary data type (for example single or double ). Tensors of data type 'T are implemented by the Tensor<'T> type. A tensor can be either stored in host memory or in the memory of a GPU computing device. Currenty only nVidia cards implementing the CUDA API are supported. The API for host and GPU stored tensors is mostly equal, thus a program can make use of GPU accelerated operations without porting effort. The tensor library provides functionality similar to Numpy's Ndarray and MATLAB arrays , including vector-wise operations, reshaping, slicing, broadcasting, masked assignment, reduction operations and BLAS operations. This open source library is written in F# and targets the .NET Standard 2.0 platform with Linux, MacOS and Microsoft Windows as supported operating systems. Features provided by the core Tensor library Core features n-dimensional arrays (tensors) in host memory or on CUDA GPUs element-wise operations (addition, multiplication, absolute value, etc.) basic linear algebra operations (dot product, SVD decomposition, matrix inverse, etc.) reduction operations (sum, product, average, maximum, arg max, etc.) logic operations (comparision, and, or, etc.) views, slicing, reshaping, broadcasting (similar to NumPy) scatter and gather by indices standard functional operations (map, fold, etc.) Data exchange read/write support for HDF5 (.h5) interop with standard F# types (Seq, List, Array, Array2D, Array3D, etc.) Performance host: SIMD and Intel MKL accelerated operations CUDA GPU: all operations performed locally on GPU and cuBLAS used for matrix operations Additional features provided by Tensor.Algorithm Matrix algebra (integer, rational) Row echelon form Smith normal form Kernel, cokernel and (pseudo-)inverse Matrix decomposition (floating point) Principal component analysis (PCA) ZCA whitening Misc Bezout's identity Loading of NumPy's .npy and .npz files. News 2018/05/02 . Initial benchmarks are available. Documentation To get an overview of available functions by category, see Tensor at a glance . We also provide full reference documentation . To start using the library, follow the installation guide and the getting started guide . Example Check out our example project that demonstrates essential features of the library at https://github.com/DeepMLNet/Tensor.Sample . Authors Sebastian Urban Marcus Basalla Johannes Langer Wiebke Köpp"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | Tensor for F#",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "articles/Guide-Elements.html": {
    "href": "articles/Guide-Elements.html",
    "title": "Elements and slicing | Tensor for F#",
    "keywords": "Elements and slicing The tensor library provides methods to access single elements of a tensor. Furthermore, it provides methods to access and manipulate ranges consisting of multiple elements within a tensor at once. This page provides an overview of both concepts. More information is available at the Item property . Accessing individual elements Individual elements of a tensor can be accessed using the tensor.[[idx0; idx1; ...; idxN]] notation. Zero-based indexing is used. // a = // [[ 0.0000 1.0000 2.0000 3.0000 4.0000] // [ 5.0000 6.0000 7.0000 8.0000 9.0000] // [ 10.0000 11.0000 12.0000 13.0000 14.0000] // [ 15.0000 16.0000 17.0000 18.0000 19.0000] // [ 20.0000 21.0000 22.0000 23.0000 24.0000] // [ 25.0000 26.0000 27.0000 28.0000 29.0000] // [ 30.0000 31.0000 32.0000 33.0000 34.0000]] let v = a.[[1L; 1L]] // v = 6.0 The above example accesses the element at index 1,1 . Note that the indices are specified as 64-bit integers surrounded by double brackets ( [[ and ]] ) and separated using a semicolon. Tensors are mutable objects. An element can be changed using the tensor.[[idx0; idx1; ...; idxN]] <- newValue notation. a.[[2L; 2L]] <- 55.0 // a = // [[ 0.0000 1.0000 2.0000 3.0000 4.0000] // [ 5.0000 6.0000 7.0000 8.0000 9.0000] // [ 10.0000 11.0000 55.0000 13.0000 14.0000] // [ 15.0000 16.0000 17.0000 18.0000 19.0000] // [ 20.0000 21.0000 22.0000 23.0000 24.0000] // [ 25.0000 26.0000 27.0000 28.0000 29.0000] // [ 30.0000 31.0000 32.0000 33.0000 34.0000]] The above example changes the value at index 2,2 to 55. Slicing Slicing creates a new view into an existing tensor. A view shares the same memory with the original tensor and thus any modification affects both the original tensor and all its views. Slicing is done using the tensor.[rng0, rng1, ..., rngN] notation. Note that the ranges are specified within single brackets and separated using commas. Let us select the first row of tensor a . let a1 = a.[0L, *] // a1 = [ 0.0000 1.0000 2.0000 3.0000 4.0000] The asterisk ( * ) selects all elements of the corresponding dimension. Thus in this case the result is a tensor of rank one (i.e. a vector) as seen above. Since a1 is a view of a it shares the same memory. Hence, changing an element of a1 by assigning a new value to it changes the tensor a as well. a1.[[1L]] <- 99.0 // a1 = [ 0.0000 99.0000 2.0000 3.0000 4.0000] // a = // [[ 0.0000 99.0000 2.0000 3.0000 4.0000] // [ 5.0000 6.0000 7.0000 8.0000 9.0000] // [ 10.0000 11.0000 55.0000 13.0000 14.0000] // [ 15.0000 16.0000 17.0000 18.0000 19.0000] // [ 20.0000 21.0000 22.0000 23.0000 24.0000] // [ 25.0000 26.0000 27.0000 28.0000 29.0000] // [ 30.0000 31.0000 32.0000 33.0000 34.0000]] Slicing can also be used to change multiple elements of a tensor at once. For example the following code sets all elements of the first row of a to 1. let a2 = HostTensor.ones<float> [5L] // a2 = [1.0 1.0 1.0 1.0 1.0] a.[0L, *] <- a2 // a = // [[ 1.0000 1.0000 1.0000 1.0000 1.0000] // [ 5.0000 6.0000 7.0000 8.0000 9.0000] // [ 10.0000 11.0000 55.0000 13.0000 14.0000] // [ 15.0000 16.0000 17.0000 18.0000 19.0000] // [ 20.0000 21.0000 22.0000 23.0000 24.0000] // [ 25.0000 26.0000 27.0000 28.0000 29.0000] // [ 30.0000 31.0000 32.0000 33.0000 34.0000]] Slice specification Consider the two-dimensional tensor a of shape 7x5 and the four-dimensional tensor b of shape 1x2x3x4 . A slice range can be one of the following. A range, e.g. 1L..3L . Selects the specified elements in the corresponding dimension. For example a.[1L..3L, 0L..2L] is the 3x3 sub-tensor of a containing rows 1,2,3 and columns 0,1,2 . As it is standard in F#, the ending index is inclusive. A partial range, e.g. 1L.. or ..3L . This selects all elements in the corresponding dimension to the end or from the beginning respectively. Thus a.[1L.., ..3L] is equivalent to a.[1L..6L, 0L..3L] . An asterisk * . Selects all elements in the corresponding dimension. For example a.[1L..3L, *] is equivalent to a.[1L..3L, 0L..4L] . An 64-bit integer. The corresponding dimension collapses, e.g. a.[*, 0L] specifies a one-dimensional tensor of shape 7 corresponding to the first column of a . The special identifier NewAxis . It inserts a new axis of size one at the given position. For example a.[*, NewAxis, *] produces a view of shape 7x1x5 . The special identifier Fill . It fills any dimensions not specified (if any) with an asterisk * . For example b.[0L, Fill, 2L] is equivalent to b.[0L, *, *, 4L] and results into a two-dimensional view into tensor b . All slice ranges can be combined arbitrarily. The result of selecting a single element using the slicing operator, e.g. a.[1L,1L] is a tensor of dimension zero referencing a single element inside a ."
  },
  "articles/Guide-Creation.html": {
    "href": "articles/Guide-Creation.html",
    "title": "Creating and transferring tensors | Tensor for F#",
    "keywords": "Creating and transferring tensors To work with the Tensor library, install the NuGet packages as described in the installation guide and open the Tensor namespace within your source file. You can run the following examples by pasting the code into the main function in Program.fs of the skeleton project. You can also clone the official example project, which follows this guide, from https://github.com/DeepMLNet/Tensor.Sample . The primary type you will work with is Tensor<'T> . It provides functions to work with tensors regardless of their storage device. The modules HostTensor and CudaTensor contain additional functions that are only applicable to tensors stored in host or GPU memory respectively. Creating a tensor filled with zeros Let us create a 3x2 matrix, i.e. a two-dimensional tensor, of data type int filled with zeros in host memory. For this purpose we use the Tensor<'T>.zeros function. let z1 = Tensor<int>.zeros HostTensor.Dev [3L; 2L] // z1 = [[0; 0] // [0; 0] // [0; 0]] The type argument int tells the function which data type to use. In many cases, it can be automatically inferred and thus omitted, but in this example there is not way for the compiler to automatically find out which data type to use. The first argument to the zeros function specifies the device to use. In this case we specified HostTensor.Dev to store the tensor in host memory. The second argument specifies the desired shape. All shapes and indices in this tensor library are 64-bit integers. Thus we have to use the L postfix when writing integer literals, i.e. 3L instead of 3 . Since creating tensors in host memory is a very common operation, the library also provides the shorter notation shown below to perform the same task. let z1 = HostTensor.zeros<int> [3L; 2L] // z1 = [[0; 0] // [0; 0] // [0; 0]] These shorthands are available for all tensor creation function and listed in the HostTensor module. Other initialization possibilities Similarly, we can use the Tensor<'T>.ones function to obtain a vector of data type single and size 3 filled with ones. let o1 = Tensor<single>.ones HostTensor.Dev [3L] // o1 = [0.0f; 0.0f; 0.0f] The Tensor<'T>.identity function creates an identity matrix of the given size. let id1 = Tensor<float>.identity HostTensor.Dev 3L // id1 = [[1.0; 0.0; 0.0] // [0.0; 1.0; 0.0] // [0.0; 0.0; 1.0]] This created a 3x3 identity matrix. Scalar tensors A scalar tensor is a tensor that has a dimensionality of zero. It contains exactly one element and can be treated like a tensor of any other dimensionality. However, for convenience, special functions are provided to make working with scalar tensors easier. A scalar tensor can be created with the Tensor.scalar function (or its corresponding HostTensor.scalar shorthand). let s1 = Tensor.scalar HostTensor.Dev 33.2 // s1 = 33.2 // s1.NDims = 0 // s1.Shape = [] // s1.NElems = 1L Specifying an empty shape when using other creation methods, such as Tensor<'T>.zeros , will also create a scalar tensor. The numeric value of a scalar tensor can be obtained (and changed) using the Value property. printfn \"The numeric value of s1 is %f.\" s1.Value // The numeric value of s1 is 33.2. If you try to use this property on a non-scalar tensor, an exception will be raised. Host-only creation methods Some tensor creation methods can only produce tensors stored in host memory, which, of course, can be transferred to GPU memory subsequently. For example the HostTensor.init function takes a function and uses it to compute the initial value of each element of the tensor. let a = HostTensor.init [7L; 5L] (fun [|i; j|] -> 5.0 * float i + float j) // a = // [[ 0.0000 1.0000 2.0000 3.0000 4.0000] // [ 5.0000 6.0000 7.0000 8.0000 9.0000] // [ 10.0000 11.0000 12.0000 13.0000 14.0000] // [ 15.0000 16.0000 17.0000 18.0000 19.0000] // [ 20.0000 21.0000 22.0000 23.0000 24.0000] // [ 25.0000 26.0000 27.0000 28.0000 29.0000] // [ 30.0000 31.0000 32.0000 33.0000 34.0000]] The first argument specifies the shape of the tensor. The second argument is a function that takes the n-dimensional index (zero-based) of an entry and computes its initial value; here we use the formula 5i + j where i is the row and j is the column of the matrix. The data type (here float ) is automatically inferred from the return type of the initialization function. Creation from F# sequences, lists and arrays The HostTensor.ofSeq converts an F# sequence of finite length into a one-dimensional tensor. let seq1 = seq { for i=0 to 20 do if i % 3 = 0 then yield i } |> HostTensor.ofSeq // seq1 = [ 0 3 6 9 12 15 18] The example above creates a vector of all multiplies of 3 in the range between 0 and 20. A list can be converted into a one-dimensional tensor using the HostTensor.ofList function. To convert an array into a tensor use the HostTensor.ofArray function. The HostTensor.ofList2D and HostTensor.ofArray2D take two-dimensional lists or arrays and convert them into tensors of respective shapes. Conversion to F# sequences, lists and arrays Use the HostTensor.toSeq function to expose the elements of a tensor as a sequence. If the tensor has more than one dimension, it is flattened before the operation is performed. Use the HostTensor.toList or HostTensor.toList2D functions to convert a tensor into a list. The HostTensor.toArray , HostTensor.toArray2D , HostTensor.toArray3D convert a tensor into an array of respective dimensionality. All these operations copy the elements of the tensor. Printing tensors and string representation Tensors can be printed using the %A format specifier of the standard printf function. printfn \"The tensor seq1 is\\n%A\" seq1 // The tensor seq1 is // [ 0 3 6 9 12 15 18] The output of large tensors is automatically truncated to a reasonable size. The corresponding string representation can also be accessed thorugh the Pretty property. The full (untruncated) string representation is available through the Full property. Use the ToString method when it is required to adjust the maximum number of elements that are printed before truncation occurs. Transferring tensors to the GPU If your workstation is equipped with a CUDA capable GPU, you can transfer tensors to GPU memory and perform operations on the GPU. Tensors can be transferred to the GPU by using the CudaTensor.transfer function. Transfer back to host memory is done using the HostTensor.transfer function. let m = seq {1 .. 10} |> HostTensor.ofSeq // m.Dev = HostTensor.Dev let mGpu = CudaTensor.transfer m // mGpu.Dev = CudaTensor.Dev The above sample code creates tensor m in host memory and then creates the copy mGpu in GPU memory. All operations performed on mGpu will execute directly on the GPU. If you receive an error message when trying to perform GPU operations, read the troubleshooting guide to get help."
  },
  "articles/Benchmarks.html": {
    "href": "articles/Benchmarks.html",
    "title": "Benchmarks | Tensor for F#",
    "keywords": "Benchmarks The following benchmarks are available. F# Tensor vs. Anaconda NumPy on Linux F# Tensor vs. Anaconda NumPy on Windows Since the Windows and Linux machines have different hardware, results between them are not comparable. Methodology We benchmarked a variety of functions using different data types and tensor shapes. Each benchmark was run twice, once for tensors stored in host memory and a second time using a CUDA GPU. When benchmarking on the GPU a call to cudaDeviceSynchronize was made to ensure that the operation is complete before the elapsed time was measured. If an operation is not yet implemented for a particular combination of data type and device, the result is replaced by a dash. Benchmarking was driven by BenchmarkDotNet using the following options. BenchmarkDotNet=v0.10.14 MinInvokeCount=1 IterationTime=250.0000 ms LaunchCount=1 TargetCount=4 UnrollFactor=1 WarmupCount=0 Comparison to NumPy For comparison, we run equivalent operations using NumPy from the Anaconda Python 3 distribution. Since it has no inherent support for GPU acceleration, we report only timings for operations executed on the host. The NumPy benchmarks are work in progress and not every equivalent function has been evaluated yet. Benchmarking was driven by pytest-benchmark using the default settings. Source code Source code for the benchmarks is available in the Tensor/Tensor.Benchmark folder of the repository."
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemv.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemv.html",
    "title": "Delegate BLAS.__cblas_dgemv | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_dgemv Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_dgemv = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * alpha:double * a:nativeint * lda:blas_int * x:nativeint * incx:blas_int * beta:double * y:nativeint * incy:blas_int -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit"
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemm_batch.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemm_batch.html",
    "title": "Delegate BLAS.__cblas_dgemm_batch | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_dgemm_batch Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_dgemm_batch = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE [] * transB:CBLAS_TRANSPOSE [] * m:blas_int [] * n:blas_int [] * k:blas_int [] * alpha:double [] * a:nativeint [] * lda:blas_int [] * b:nativeint [] * ldb:blas_int [] * beta:double [] * c:nativeint [] * ldc:blas_int [] * group_count:blas_int * group_size:blas_int [] -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit"
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemm.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemm.html",
    "title": "Delegate BLAS.__cblas_dgemm | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_dgemm Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_dgemm = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * transB:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * k:blas_int * alpha:double * a:nativeint * lda:blas_int * b:nativeint * ldb:blas_int * beta:double * c:nativeint * ldc:blas_int -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_getri.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_getri.html",
    "title": "Delegate BLAS.__LAPACKE_getri | Tensor for F#",
    "keywords": "Delegate BLAS.__LAPACKE_getri Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__LAPACKE_getri = delegate of matrix_layout:int * n:lapack_int * a:nativeint * lda:lapack_int * ipiv:lapack_int [] -> lapack_int Methods Name Description abstract member Invoke: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_getrf.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_getrf.html",
    "title": "Delegate BLAS.__LAPACKE_getrf | Tensor for F#",
    "keywords": "Delegate BLAS.__LAPACKE_getrf Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__LAPACKE_getrf = delegate of matrix_layout:int * m:lapack_int * n:lapack_int * a:nativeint * lda:lapack_int * ipiv:lapack_int [] -> lapack_int Methods Name Description abstract member Invoke: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.html",
    "title": "Class BLAS.Impl | Tensor for F#",
    "keywords": "Class BLAS.Impl BLAS/LAPACK native library Inheritance System.Object BLAS.Impl Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.Impl (blasName:NativeLibName, lapackName:NativeLibName) Parameters Type Name Description Tensor.Utils.NativeLibName blasName Tensor.Utils.NativeLibName lapackName Constructors Name Description new: NativeLibName * NativeLibName -> Impl Implicit constructor. Properties Name Description property Has_cblas_gemm_batch: bool Methods Name Description member cblas_ddot: blas_int * nativeint * blas_int * nativeint * blas_int -> double member cblas_dgemm: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit member cblas_dgemm_batch: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit member cblas_dgemv: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit member cblas_sdot: blas_int * nativeint * blas_int * nativeint * blas_int -> single member cblas_sgemm: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit member cblas_sgemm_batch: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit member cblas_sgemv: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit member LAPACKE_dgeev: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int member LAPACKE_dgesdd: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int member LAPACKE_dgetrf: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int member LAPACKE_dgetri: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int member LAPACKE_dsyevd: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int member LAPACKE_sgeev: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int member LAPACKE_sgesdd: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int member LAPACKE_sgetrf: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int member LAPACKE_sgetri: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int member LAPACKE_ssyevd: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int"
  },
  "api/Tensor.Cuda.ITensorCudaBackend.html": {
    "href": "api/Tensor.Cuda.ITensorCudaBackend.html",
    "title": "Interface ITensorCudaBackend | Tensor for F#",
    "keywords": "Interface ITensorCudaBackend type-neutral interface to CUDA backend for tensors Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax interface ITensorCudaBackend Properties Name Description abstract property NativeTensor: NativeTensor"
  },
  "api/Tensor.Cuda.Cfg.html": {
    "href": "api/Tensor.Cuda.Cfg.html",
    "title": "Class Cfg | Tensor for F#",
    "keywords": "Class Cfg Options for configuring operations performed on CUDA tensors. Inheritance System.Object Cfg Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax type Cfg Remarks All settings are local to the calling thread. Properties Name Description static property DebugCompile: bool If set to true, all CUDA kernels are compiled with debug flags. static property DisableKernelCache: bool If set to true, the CUDA kernel cache is disabled. static property FastKernelMath: bool If set to true, CUDA uses fast math functions with lower accuracy. static property RestrictKernels: bool If set to true, all arguments are passed as restriced to CUDA kernels (experimental). static property Stacktrace: bool If set to true, CUDA operations produce an acurate stack trace when an error is encountered. static property Stream: CUstream The CUDA stream to execute CUDA operations on. See Also CudaTensor (mod)"
  },
  "api/Tensor.Cuda.CannotCudaRegisterMemoryException.html": {
    "href": "api/Tensor.Cuda.CannotCudaRegisterMemoryException.html",
    "title": "Class CannotCudaRegisterMemoryException | Tensor for F#",
    "keywords": "Class CannotCudaRegisterMemoryException Cannot register host memory with CUDA, maybe because it is not properly aligned. Inheritance System.Object System.Exception CannotCudaRegisterMemoryException Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax exception CannotCudaRegisterMemoryException val msg: string Fields Name Description val msg: string Properties Name Description override property Message: string"
  },
  "api/Tensor.Backend.TensorLayoutModule.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.html",
    "title": "Class TensorLayout (mod) | Tensor for F#",
    "keywords": "Class TensorLayout (mod) Functions for working with TensorLayout. Inheritance TensorLayout (mod) Namespace : Tensor.Backend Assembly : Tensor.dll Syntax module TensorLayout Fields Name Description val emptyVector an ArrayND layout for an empty (zero elements) vector (1D) Methods Name Description val addr: int64 list -> TensorLayout -> int64 address of element val allIdx: TensorLayout -> seq<int64 list> sequence of all indices val allIdxOfDim: int -> TensorLayout -> seq<int64> all indices of the given dimension val allIdxOfShape: int64 list -> seq<int64 list> a sequence of indicies enumerating all elements of the array with the given shape val allSrcRngsAndTrgtIdxsForAxisReduce: int -> TensorLayout -> seq<Rng list * int64 list> val broadcastDim: int -> int64 -> TensorLayout -> TensorLayout broadcast the given dimension to the given size val broadcastToSame: TensorLayout -> TensorLayout -> TensorLayout * TensorLayout broadcasts to have the same size val broadcastToSameInDims: seq<int> -> TensorLayout -> TensorLayout -> TensorLayout * TensorLayout broadcasts to have the same size in the given dimensions val broadcastToSameInDimsMany: seq<int> -> TensorLayout list -> TensorLayout list broadcasts to have the same size in the given dimensions val broadcastToSameMany: TensorLayout list -> TensorLayout list broadcasts to have the same size val broadcastToShape: int64 list -> TensorLayout -> TensorLayout broadcasts a tensor to the given shape val canReshape: int64 list -> TensorLayout -> bool Returns true if a can be reshaped into shp without copying. The number of elements must not change. val check: TensorLayout -> unit checks that the layout is valid val checkAxis: int -> TensorLayout -> unit checks that the given axis is valid val checkIndex: int64 list -> int64 list -> unit checks that the given index is valid for the given shape val cStride: int64 list -> int64 list computes the stride given the shape for the ArrayND to be in C-order (row-major) val cutLeft: TensorLayout -> TensorLayout cuts one dimension from the left val cutRight: TensorLayout -> TensorLayout cuts one dimension from the right val diagAxis: int -> int -> TensorLayout -> TensorLayout Creates a layout that extracts the diagonal along the given axes. The first axis is replaced with the diagonal and the second axis is removed. val fStride: int64 list -> int64 list computes the stride given the shape for the ArrayND to be in Fortran-order (column-major) val hasContiguousMemory: TensorLayout -> bool true if the memory of the ArrayND is a contiguous block val idxToLinear: TensorLayout -> int64 list -> int64 Computes the linear index of a given index. Linear indexing is performed in row-major order. val insertAxis: int -> TensorLayout -> TensorLayout Inserts an axis of size 1 before the specified position. val isBroadcasted: TensorLayout -> bool returns true if at least one dimension is broadcasted val isC: TensorLayout -> bool true if the ArrayND is contiguous val isF: TensorLayout -> bool true if the ArrayND is in Fortran order val linearToIdx: TensorLayout -> int64 -> int64 list Computes the index of a given linear index. val nDims: TensorLayout -> int number of dimensions val nElems: TensorLayout -> int64 number of elements val newC: int64 list -> TensorLayout a C-order (row-major) ArrayND layout of the given shape val newF: int64 list -> TensorLayout a Fortran-order (column-major) ArrayND layout of the given shape val newOrdered: int64 list -> int list -> TensorLayout a ArrayND layout of the given shape and stride order val offset: TensorLayout -> int64 offset val orderedStride: int64 list -> int list -> int64 list Computes the strides for the given shape using the specified ordering. The axis that is first in the ordering gets stride 1. The resulting strides will be independent of the shape of the axis that appears last in the ordering. A C-order stride corresponds to the ordering: [n; n-1; ...; 2; 1; 0]. A Fortran-order stride corresponds to the ordering: [0; 1; 2; ...; n-1; n]. val padLeft: TensorLayout -> TensorLayout adds a new dimension of size one to the left val padRight: TensorLayout -> TensorLayout adds a new dimension of size one to the right val padToSame: TensorLayout -> TensorLayout -> TensorLayout * TensorLayout pads shapes from the left until they have same rank val padToSameMany: TensorLayout list -> TensorLayout list pads shapes from the left until they have same rank val permuteAxes: int list -> TensorLayout -> TensorLayout Permutes the axes as specified. Each entry in the specified permutation specifies the new position of the corresponding axis, i.e. to which position the axis should move. val reshape: int64 list -> TensorLayout -> TensorLayout Reshape layout under the assumption that it is contiguous. The number of elements must not change. An error is raised, if reshape is impossible without copying. val reverseAxis: int -> TensorLayout -> TensorLayout Reverses the elements in the specified dimension. val shape: TensorLayout -> int64 list shape val stride: TensorLayout -> int64 list stride val stridesEqual: int64 list -> int64 list -> int64 list -> bool True if strides are equal at all dimensions with size > 1. val swapDim: int -> int -> TensorLayout -> TensorLayout swaps the given dimensions val transpose: TensorLayout -> TensorLayout Transposes the given layout of a matrix. If the array has more then two dimensions, the last two axes are swapped. val tryReshape: int64 list -> TensorLayout -> TensorLayout option Reshape layout under the assumption that it is contiguous. The number of elements must not change. Returns Some newLayout when reshape is possible without copy Returns None when a copy is required. val view: Rng list -> TensorLayout -> TensorLayout creates a subview layout"
  },
  "api/Tensor.Backend.TensorLayout.html": {
    "href": "api/Tensor.Backend.TensorLayout.html",
    "title": "Class TensorLayout (rec) | Tensor for F#",
    "keywords": "Class TensorLayout (rec) Layout (shape, offset, stride) of a Tensor. Inheritance System.Object TensorLayout (rec) Namespace : Tensor.Backend Assembly : Tensor.dll Syntax record TensorLayout val Shape: int64 list val Offset: int64 val Stride: int64 list Fields Name Description val Offset: int64 Offset (to first element) in elements. val Shape: int64 list Shape. val Stride: int64 list Stride in elements. Properties Name Description property NDims: int Number of dimensions. property NElems: int64 Number of elements."
  },
  "api/Tensor.Backend.ITensorStorage.html": {
    "href": "api/Tensor.Backend.ITensorStorage.html",
    "title": "Interface ITensorStorage | Tensor for F#",
    "keywords": "Interface ITensorStorage Tensor storage (type neutral). Namespace : Tensor.Backend Assembly : Tensor.dll Syntax interface ITensorStorage Properties Name Description abstract property Dev: ITensorDevice"
  },
  "api/Tensor.Backend.ITensorFrontend-1.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.html",
    "title": "Interface ITensorFrontend<'T> | Tensor for F#",
    "keywords": "Interface ITensorFrontend<'T> Tensor frontend access (for use from backend). Namespace : Tensor.Backend Assembly : Tensor.dll Syntax interface ITensorFrontend<'T> Type Parameters Name Description 'T Properties Name Description abstract property Backend: ITensorBackend<'T> the backend abstract property Dev: ITensorDevice storage factory abstract property Layout: TensorLayout layout of this tensor (shape, offset and strides) abstract property NDims: int number of dimensions abstract property NElems: int64 number of elements abstract property Offset: int64 stride abstract property Shape: int64 list shape abstract property Storage: ITensorStorage<'T> storage of this tensor abstract property Stride: int64 list stride abstract property T: ITensorFrontend<'T> Transpose Methods Name Description abstract member Copy: TensorOrder option -> ITensorFrontend<'T> returns a copy of the tensor abstract member CopyFrom: ITensorFrontend<'T> -> unit Copies the specifed tensor into this tensor. abstract member Relayout: TensorLayout -> ITensorFrontend<'T> a tensor with the same storage but new layout abstract member Transfer: ITensorDevice -> ITensorFrontend<'T> Transfers this tensor to the specifed device."
  },
  "api/Tensor.Backend.ITensorBackend-1.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.html",
    "title": "Interface ITensorBackend<'T> | Tensor for F#",
    "keywords": "Interface ITensorBackend<'T> Tensor backend. Namespace : Tensor.Backend Assembly : Tensor.dll Syntax interface ITensorBackend<'T> Type Parameters Name Description 'T Properties Name Description abstract property Item: int64 [] -> 'T Methods Name Description abstract member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit abstract member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit abstract member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit abstract member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit abstract member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit abstract member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit abstract member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Convert: ITensorFrontend<'T> * ITensorFrontend<'T1> -> unit abstract member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit abstract member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member FillConst: 'T * ITensorFrontend<'T> -> unit abstract member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit abstract member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit abstract member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit abstract member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit abstract member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit abstract member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit abstract member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit abstract member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit abstract member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit abstract member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool abstract member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit abstract member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit abstract member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.TensorVal.html": {
    "href": "api/Tensor.TensorVal.html",
    "title": "Class TensorVal (mod) | Tensor for F#",
    "keywords": "Class TensorVal (mod) Special constants that can be passed instead of indicies or parameter values or be returned from methods. Inheritance TensorVal (mod) Namespace : Tensor Assembly : Tensor.dll Syntax [<AutoOpen>] module TensorVal Fields Name Description val Fill For slicing: fills all remaining axes with size one. val NewAxis For slicing: inserts a new axis of size one. val NoMask Indicates that the dimension is unmasked, i.e. equals specifying a tensor filled with trues. val NotFound For search: value was not found. val Remainder For reshape: remainder, so that number of elements stays constant."
  },
  "api/Tensor.TensorOrder.html": {
    "href": "api/Tensor.TensorOrder.html",
    "title": "Class TensorOrder (union) | Tensor for F#",
    "keywords": "Class TensorOrder (union) Memory ordering of a tensor. Inheritance System.Object TensorOrder (union) Namespace : Tensor Assembly : Tensor.dll Syntax union TensorOrder | RowMajor | ColumnMajor | CustomOrder of int list Properties Name Description ColumnMajor Column-major (Fortran) memory order. CustomOrder of int list The specified custom memory ordering of dimensions. RowMajor Row-major (C) memory order."
  },
  "api/Tensor.Tensor-1.html": {
    "href": "api/Tensor.Tensor-1.html",
    "title": "Class Tensor<'T> | Tensor for F#",
    "keywords": "Class Tensor<'T> An N-dimensional array with elements of type 'T. Inheritance System.Object Tensor<'T> Implements ITensorFrontend <'T> ITensor Namespace : Tensor Assembly : Tensor.dll Syntax type Tensor<'T> (layout:TensorLayout, storage:ITensorStorage<'T>) interface ITensor interface ITensorFrontend<'T> Parameters Type Name Description TensorLayout layout The memory layout to use. ITensorStorage <'T> storage The storage to use. Type Parameters Name Description 'T The type of the data stored within the tensor. Remarks The data of a tensor can be stored on different devices. Currently supported devices are host memory and CUDA GPU memory. Different tensors can share the whole or parts of the underlying data. The recommended way to create a new tensor is to use static member zeros: ITensorDevice -> int64 list -> Tensor<'T> . The implicit constructor creates a view into the specified storage using the specified memory layout. In most cases, it is not necessary to use the implicit constructor. Constructors Name Description new: int64 list * ITensorDevice * TensorOrder option -> Tensor<'T> Creates a new, uninitialized tensor with a new storage. new: TensorLayout * ITensorStorage<'T> -> Tensor<'T> Implicit constructor. Properties Name Description property DataType: Type Type of data stored within this tensor. property Dev: ITensorDevice Device the data of tensor is stored on. property Full: string Unabreviated string representation of the tensor. property Item: int64 [] -> 'T Accesses a single element within the tensor. property Item: int64 list -> 'T Accesses a single element within the tensor. property Item: int64 -> Tensor<'T> Accesses a slice (part) of the tensor. property Item: Rng list -> Tensor<'T> Accesses a slice (part) of the tensor. property Layout: TensorLayout Memory layout of this tensor. property M: Tensor<bool> list -> Tensor<'T> Picks elements from a tensor using one or more boolean mask tensors. property M: Tensor<bool> -> Tensor<'T> Picks elements from a tensor using one or more boolean mask tensors. property NDims: int Dimensionality of this tensor. property NElems: int64 Total number of elements within this tensor. property Pretty: string String representation of the tensor limited to 10 elements per dimension. property Shape: int64 list Shape of this tensor. property Storage: ITensorStorage<'T> The storage object that holds the data of this tensor. property T: Tensor<'T> Transpose of a matrix. property Value: 'T Accesses the value of a zero-dimensional (scalar) tensor. Methods Name Description static member Abs: Tensor<'T> -> Tensor<'T> Element-wise absolute value. static member Acos: Tensor<'T> -> Tensor<'T> Element-wise arccosine (inverse cosine). static member all: Tensor<bool> -> bool Checks if all elements of the tensor are true. static member allAxis: int -> Tensor<bool> -> Tensor<bool> Checks if all elements along the specified axis are true. static member allElems: Tensor<'T> -> seq<'T> Gets a sequence of all all elements within the tensor. static member allFinite: Tensor<'T> -> bool Checks that all elements of the tensor are finite. static member allIdx: Tensor<'T> -> seq<int64 list> Gets a sequence of all indices to enumerate all elements within the tensor. static member allTensor: Tensor<bool> -> Tensor<bool> Checks if all elements of the tensor are true returning the result as a tensor. static member almostEqual: Tensor<'T> * Tensor<'T> * 'T option * 'T option -> bool Checks if two tensors have the same (within machine precision) values in all elements. static member any: Tensor<bool> -> bool Checks if any elements of the tensor are true. static member anyAxis: int -> Tensor<bool> -> Tensor<bool> Checks if any element along the specified axis is true. static member anyTensor: Tensor<bool> -> Tensor<bool> Checks if any element of the tensor is true returning the result as a tensor. static member arange: ITensorDevice -> 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. static member argMax: Tensor<'T> -> int64 list Finds the indicies of the maximum value of the tensor. static member argMaxAxis: int -> Tensor<'T> -> Tensor<int64> Finds the index of the maximum value along the specified axis. static member argMin: Tensor<'T> -> int64 list Finds the indicies of the minimum value of the tensor. static member argMinAxis: int -> Tensor<'T> -> Tensor<int64> Finds the index of the minimum value along the specified axis. static member Asin: Tensor<'T> -> Tensor<'T> Element-wise arcsine (inverse sine). static member Atan: Tensor<'T> -> Tensor<'T> Element-wise arctanget (inverse tangent). static member atLeast1D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least one dimension. static member atLeast2D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least two dimensions. static member atLeast3D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least three dimensions. static member atLeastND: int -> Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least the specified number of dimensions. static member broadcastDim: int -> int64 -> Tensor<'T> -> Tensor<'T> Broadcast a dimension to a specified size. static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T> Broadcasts the specified tensor to the specified shape. static member broadcastToSame: Tensor<'T> list -> Tensor<'T> list Broadcasts all specified tensors to have the same shape. static member broadcastToSame: Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Broadcasts all specified tensors to have the same shape. static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Broadcasts all specified tensors to have the same shape. static member broadcastToSameInDims: seq<int> * Tensor<'T> list -> Tensor<'T> list Broadcasts all specified tensors to have the same size in the specified dimensions. static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Broadcasts all specified tensors to have the same size in the specified dimensions. static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Broadcasts all specified tensors to have the same size in the specified dimensions. static member Ceiling: Tensor<'T> -> Tensor<'T> Element-wise ceiling (round towards positive infinity). member CheckAxis: int -> unit Checks the the specified axis is valid for this tensor. static member concat: int -> seq<Tensor<'T>> -> Tensor<'T> Concatenates tensors along an axis. static member convert: Tensor<'C> -> Tensor<'T> Convert the elements of a tensor to the specifed type. static member copy: Tensor<'T> * TensorOrder option -> Tensor<'T> Returns a copy of the tensor. member CopyFrom: Tensor<'T> -> unit Fills this tensor with a copy of the specified tensor. static member Cos: Tensor<'T> -> Tensor<'T> Element-wise cosine. static member Cosh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic cosine. static member counting: ITensorDevice -> int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. static member countTrue: Tensor<bool> -> int64 Counts the elements being true. static member countTrueAxis: int -> Tensor<bool> -> Tensor<int64> Counts the elements being true along the specified axis. static member countTrueTensor: Tensor<bool> -> Tensor<int64> Counts the elements being true returning the result as a Tensor. static member cutLeft: Tensor<'T> -> Tensor<'T> Removes the first dimension. static member cutRight: Tensor<'T> -> Tensor<'T> Removes the last dimension. static member dataType: Tensor<'T> -> Type Type of data stored within the tensor. static member dev: Tensor<'T> -> ITensorDevice Device the data of tensor is stored on. static member diag: Tensor<'T> -> Tensor<'T> Returns a view of the diagonal of the matrix. static member diagAxis: int -> int -> Tensor<'T> -> Tensor<'T> Returns a view of the diagonal along the given axes. static member diagMat: Tensor<'T> -> Tensor<'T> Creates a matrix with the specified diagonal. static member diagMatAxis: int -> int -> Tensor<'T> -> Tensor<'T> Creates a tensor with the specified diagonal along the given axes. static member diff: Tensor<'T> -> Tensor<'T> Calculates the difference between adjoining elements of the vector. static member diffAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the difference between adjoining elements along the specified axes. static member dot: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Computes the (batched) matrix product, (batched) matrix-vector product or scalar product. static member empty: ITensorDevice -> int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. override member Equals: obj -> bool Tests for equality to another object. static member Exp: Tensor<'T> -> Tensor<'T> Element-wise exponential function. static member falses: ITensorDevice -> int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. member FillAbs: Tensor<'T> -> unit Fills this tensor with the element-wise absolute value of the argument. member FillAcos: Tensor<'T> -> unit Fills this tensor with the element-wise arccosine (inverse cosine) of the argument. member FillAdd: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise addition of the arguments. member FillAllAxis: int -> Tensor<bool> -> unit Checks if all elements along the specified axis are true using this tensor as target. member FillAnd: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical and of the arguments. member FillAnyAxis: int -> Tensor<bool> -> unit Checks if any element along the specified axis is true using this tensor as target. member FillArgMaxAxis: int -> Tensor<'R> -> unit Finds the index of the maximum value along the specified axis and writes it into this tensor. member FillArgMinAxis: int -> Tensor<'R> -> unit Finds the index of the minimum value along the specified axis and writes it into this tensor. member FillAsin: Tensor<'T> -> unit Fills this tensor with the element-wise arcsine (inverse sine) of the argument. member FillAtan: Tensor<'T> -> unit Fills this tensor with the element-wise arctanget (inverse tangent) of the argument. member FillCeiling: Tensor<'T> -> unit Fills this tensor with the element-wise ceiling (round towards positive infinity) of the argument. member FillConst: 'T -> unit Fills this tensor with the specified constant value. member FillConvert: Tensor<'C> -> unit Copies elements from a tensor of different data type into this tensor and converts their type. member FillCos: Tensor<'T> -> unit Fills this tensor with the element-wise cosine of the argument. member FillCosh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic cosine of the argument. member FillCountTrueAxis: int -> Tensor<bool> -> unit Counts the elements being true along the specified axis and writes the result into this tensor. member FillDivide: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise division of the arguments. member FillDot: Tensor<'T> -> Tensor<'T> -> unit Fill this tensor with the (batched) matrix product, matrix-vector product or scalar product of the arguments. static member filled: ITensorDevice -> int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. member FillEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise equality test of the arguments. member FillExp: Tensor<'T> -> unit Fills this tensor with the element-wise exponential function of the argument. member FillFindAxis: 'R -> int -> Tensor<'R> -> unit Finds the first occurence of the specfied value along the specified axis and write its index into this tensor. member FillFloor: Tensor<'T> -> unit Fills this tensor with the element-wise floor (round towards negative infinity) of the argument. member FillFrom: Tensor<'T> -> unit Fills this tensor with a copy of the specified tensor. member FillGather: Tensor<int64> option list -> Tensor<'T> -> unit Selects elements from a tensor according to specified indices. member FillGreater: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise greater-than test of the arguments. member FillGreaterOrEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise greater-than-or-equal test of the arguments. member FillIfThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with an element-wise choice between two sources depending on a condition. member FillIncrementing: 'T * 'T -> unit Fills this vector with an equispaced sequence of elements. member FillInvert: Tensor<'T> -> unit Fills this tensor with the (batch) inverse of a matrix. member FillIsFinite: Tensor<'R> -> unit Fills this tensor with the element-wise finity check (not -Inf, Inf or NaN) of the argument. member FillLess: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise less-than test of the arguments. member FillLessOrEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise less-than-or-equal test of the arguments. member FillLog: Tensor<'T> -> unit Fills this tensor with the element-wise natural logarithm of the argument. member FillLog10: Tensor<'T> -> unit Fills this tensor with the element-wise common logarithm of the argument. member FillMaxAxis: int -> Tensor<'T> -> unit Calculates the maximum value of the elements over the specified axis and writes the result into this tensor. member FillMaxElemwise: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise maximum of the arguments. member FillMinAxis: int -> Tensor<'T> -> unit Calculates the minimum value of the elements over the specified axis and writes the result into this tensor. member FillMinElemwise: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise minimum of the arguments. member FillModulo: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise remainder of the division of the arguments. member FillMultiply: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise multiplication of the arguments. member FillNegate: Tensor<bool> -> unit Fills this tensor with the element-wise logical negation of the argument. member FillNotEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise not-equality test or of the arguments. member FillOr: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical or of the arguments. member FillPower: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise exponentiation. member FillProductAxis: int -> Tensor<'T> -> unit Calculates the product of the elements over the specified axis and writes the result into this tensor. member FillPseudoInvert: Tensor<'T> * 'T option -> unit Fills this tensor with the (batched) Moore-Penrose pseudo-inverse of the specified matrix. member FillRound: Tensor<'T> -> unit Fills this tensor with the element-wise rounding of the argument. member FillScatter: Tensor<int64> option list -> Tensor<'T> -> unit Disperses elements from a source tensor to this tensor according to the specified indices. member FillSgn: Tensor<'T> -> unit Fills this tensor with the element-wise sign of the argument. member FillSin: Tensor<'T> -> unit Fills this tensor with the element-wise sine of the argument. member FillSinh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic sine of the argument. member FillSqrt: Tensor<'T> -> unit Fills this tensor with the element-wise square root of the argument. member FillSubtract: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise substraction of the arguments. member FillSumAxis: int -> Tensor<'T> -> unit Sums the elements over the specified axis and writes the result into this tensor. member FillSVD: Tensor<'T> * Tensor<'T> * Tensor<'T> option -> unit Fills this tensor with the (batched) singular values of the specified matrix. static member FillSymmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> -> Tensor<'T> -> unit Computes the (real) eigendecomposition of a symmetric matrix and writes it into the specified target tensors. member FillTan: Tensor<'T> -> unit Fills this tensor with the element-wise tangent of the argument. member FillTanh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic tangent of the argument. member FillTruncate: Tensor<'T> -> unit Fills this tensor with the element-wise truncation (rounding towards zero) of the argument. member FillUnaryMinus: Tensor<'T> -> unit Fills this tensor with the element-wise negation of the argument. member FillUnaryPlus: Tensor<'T> -> unit Fills this tensor with the element-wise prefix plus of the argument. member FillXor: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical xor of the arguments. static member find: 'T -> Tensor<'T> -> int64 list Finds the first occurence of the specfied value and returns its indices. static member findAxis: 'T -> int -> Tensor<'T> -> Tensor<int64> Finds the first occurence of the specfied value along the specified axis and returns its index. static member flatten: Tensor<'T> -> Tensor<'T> Flattens the tensor into a (one-dimensional) vector. static member Floor: Tensor<'T> -> Tensor<'T> Element-wise floor (round towards negative infinity). static member gather: Tensor<int64> option list -> Tensor<'T> -> Tensor<'T> Selects elements from a tensor according to specified indices. static member get: Tensor<'T> -> int64 list -> 'T Gets the value of a single element of the tensor. override member GetHashCode: unit -> int Calculates the hash code of the tensor. static member identity: ITensorDevice -> int64 -> Tensor<'T> Creates a new identity matrix. static member ifThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise choice between two sources depending on a condition. static member insertAxis: int -> Tensor<'T> -> Tensor<'T> Insert a dimension of size one before the specifed dimension. static member invert: Tensor<'T> -> Tensor<'T> (Batch) inverts a matrix. static member isBroadcasted: Tensor<'T> -> bool Checks if the specified tensor is broadcasted in at least one dimension. static member isClose: Tensor<'T> * Tensor<'T> * 'T option * 'T option -> Tensor<bool> Element-wise check if two tensors have same (within machine precision) values. static member isFinite: Tensor<'T> -> Tensor<bool> Element-wise finity check (not -Inf, Inf or NaN). static member layout: Tensor<'T> -> TensorLayout Memory layout of the tensor. static member linspace: ITensorDevice -> 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. static member Log: Tensor<'T> -> Tensor<'T> Element-wise natural logarithm. static member Log10: Tensor<'T> -> Tensor<'T> Element-wise common logarithm. static member max: Tensor<'T> -> 'T Calculates the maximum of all elements. static member maxAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the maximum value of the elements along the specified axis. static member maxElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise maximum. static member maxTensor: Tensor<'T> -> Tensor<'T> Calculates the maximum all elements returning a Tensor. static member mean: Tensor<'T> -> 'T Calculates the mean of the tensor. static member meanAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the mean of the elements along the specified axis. static member min: Tensor<'T> -> 'T Calculates the minimum of all elements. static member minAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the minimum value of the elements along the specified axis. static member minElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise minimum. static member minTensor: Tensor<'T> -> Tensor<'T> Calculates the minimum all elements returning a Tensor. static member nDims: Tensor<'T> -> int Dimensionality of the tensor. static member nElems: Tensor<'T> -> int64 Total number of elements within the tensor. static member NewOfType: int64 list * Type * ITensorDevice * TensorOrder option -> ITensor Type-neutral function for creating a new, uninitialized tensor with a new storage. static member norm: Tensor<'T> * 'T option -> 'T Calculates the norm of the (flattened) tensor. static member normAxis: int * Tensor<'T> * 'T option -> Tensor<'T> Calculates the norm along the specified axis. static member ofBlocks: BlockTensor<'T> -> Tensor<'T> Builds a tensor out of tensor blocks. static member ofBlocks: Tensor<'T> list list list -> Tensor<'T> Builds a three dimensional tensor out of tensor blocks. static member ofBlocks: Tensor<'T> list list -> Tensor<'T> Builds a matrix out of matrix blocks. static member ofBlocks: Tensor<'T> list -> Tensor<'T> Builds a vector out of vectors blocks. static member ones: ITensorDevice -> int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). static member onesLike: Tensor<'T> -> Tensor<'T> Creates a new tensor filled with ones using the specified tensor as template. static member padLeft: Tensor<'T> -> Tensor<'T> Insert a dimension of size one as the first dimension. static member padRight: Tensor<'T> -> Tensor<'T> Append a dimension of size one after the last dimension. static member padToSame: Tensor<'T> list -> Tensor<'T> list Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. static member padToSame: Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. static member padToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. static member permuteAxes: int list -> Tensor<'T> -> Tensor<'T> Permutes the axes as specified. static member Pow: 'T * Tensor<'T> -> Tensor<'T> Element-wise exponentiation with scalar. static member Pow: Tensor<'T> * 'T -> Tensor<'T> Element-wise exponentiation with scalar. static member Pow: Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise exponentiation. static member product: Tensor<'T> -> 'T Calculates the product of all elements. static member productAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the product of the elements along the specified axis. static member productTensor: Tensor<'T> -> Tensor<'T> Calculates the product all elements returning a Tensor. static member pseudoInvert: Tensor<'T> * 'T option -> Tensor<'T> Computes the (batched) Moore-Penrose pseudo-inverse of the specified matrix. static member range: Rng list -> Tensor<'T> -> Tensor<'T> Get a slice (part) of the tensor. static member relayout: TensorLayout -> Tensor<'T> -> Tensor<'T> Creates a tensor with the specified layout sharing its storage with the original tensor. static member replicate: int -> int64 -> Tensor<'T> -> Tensor<'T> Repeats the tensor along an axis. static member reshape: int64 list -> Tensor<'T> -> Tensor<'T> Changes the shape of a tensor. static member reshapeView: int64 list -> Tensor<'T> -> Tensor<'T> Creates a reshaped view of the tensor (without copying). static member reverseAxis: int -> Tensor<'T> -> Tensor<'T> Reverses the elements in the specified dimension. static member Round: Tensor<'T> -> Tensor<'T> Element-wise rounding. static member scalar: ITensorDevice -> 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. static member scalarLike: ITensor -> 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor using the specified tensor as template and with the specified value. static member scatter: Tensor<int64> option list -> int64 list -> Tensor<'T> -> Tensor<'T> Disperses elements from a source tensor to a new tensor according to the specified indices. static member set: Tensor<'T> -> int64 list -> 'T -> unit Sets the value of a single element of the tensor. static member Sgn: Tensor<'T> -> Tensor<'T> Element-wise sign. static member shape: Tensor<'T> -> int64 list Shape of the tensor. static member Sin: Tensor<'T> -> Tensor<'T> Element-wise sine. static member Sinh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic sine. static member Sqrt: Tensor<'T> -> Tensor<'T> Element-wise square root. static member std: Tensor<'T> * int64 option -> 'T Calculates the standard deviation of the tensor. static member stdAxis: int * Tensor<'T> * int64 option -> Tensor<'T> Calculates the standard deviation of the elements along the specified axis. static member sum: Tensor<'T> -> 'T Sums all elements. static member sumAxis: int -> Tensor<'T> -> Tensor<'T> Sums the elements along the specified axis. static member sumTensor: Tensor<'T> -> Tensor<'T> Sums all elements returning a Tensor. static member SVD: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Computes the (batched) singular value decomposition (SVD) of the specified matrix. static member SVDWithoutUV: Tensor<'T> -> Tensor<'T> Computes the (batched) singular values of the specified matrix. static member swapDim: int -> int -> Tensor<'T> -> Tensor<'T> Swaps the specified dimensions of the tensor. static member symmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> * Tensor<'T> Computes the (real) eigendecomposition of a symmetric matrix. static member Tan: Tensor<'T> -> Tensor<'T> Element-wise tangent. static member Tanh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic tangent. static member tensorProduct: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Computes the tensor product between two tensors. member ToString: int64 -> string String representation of the tensor limited to a specific number of elements per dimension. override member ToString: unit -> string String representation of the tensor limited to 10 elements per dimension. static member trace: Tensor<'T> -> Tensor<'T> Calculates the trace of the matrix. static member traceAxis: int -> int -> Tensor<'T> -> Tensor<'T> Calculates the trace along the specified axes. static member transfer: ITensorDevice -> Tensor<'T> -> Tensor<'T> Transfers a tensor to the specifed device. member TransferFrom: Tensor<'T> -> unit Transfers the specified tensor located on another device into this tensor. static member transpose: Tensor<'T> -> Tensor<'T> (Batched) transpose of a matrix. static member trueIdx: Tensor<bool> -> Tensor<int64> Finds the indices of all element that are true. static member trues: ITensorDevice -> int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. static member Truncate: Tensor<'T> -> Tensor<'T> Element-wise truncation (rounding towards zero). static member tryFind: 'T -> Tensor<'T> -> int64 list option Finds the first occurence of the specfied value and returns its indices. static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option Tries to create a reshaped view of the tensor (without copying). static member value: Tensor<'T> -> 'T Gets the value of a zero-dimensional (scalar) tensor. static member var: Tensor<'T> * int64 option -> 'T Calculates the variance of the tensor. static member varAxis: int * Tensor<'T> * int64 option -> Tensor<'T> Calculates the variance of the elements along the specified axis. static member zeros: ITensorDevice -> int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). static member zerosLike: Tensor<'T> -> Tensor<'T> Creates a new tensor filled with zeros using the specified tensor as template. Operators Name Description static member ( + ): 'T * Tensor<'T> -> Tensor<'T> Element-wise addition with scalar. static member ( + ): Tensor<'T> * 'T -> Tensor<'T> Element-wise addition with scalar. static member ( + ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise addition. static member ( &&&& ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal and with scalar. static member ( &&&& ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal and with scalar. static member ( &&&& ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal and. static member ( |||| ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal or with scalar. static member ( |||| ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal or with scalar. static member ( |||| ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal or. static member ( / ): 'T * Tensor<'T> -> Tensor<'T> Element-wise division with scalar. static member ( / ): Tensor<'T> * 'T -> Tensor<'T> Element-wise division with scalar. static member ( / ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise division. static member ( .* ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Computes the (batched) matrix product, (batched) matrix-vector product or scalar product. static member ( ==== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise equality test with scalar. static member ( ==== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise equality test with scalar. static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise equality test. static member ( >>== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise greater-than-or-equal test with scalar. static member ( >>== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise greater-than-or-equal test with scalar. static member ( >>== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise greater-than-or-equal test. static member ( >>>> ): 'T * Tensor<'T> -> Tensor<bool> Element-wise greater-than test with scalar. static member ( >>>> ): Tensor<'T> * 'T -> Tensor<bool> Element-wise greater-than test with scalar. static member ( >>>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise greater-than test. static member ( ^^^^ ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal xor with scalar. static member ( ^^^^ ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal xor with scalar. static member ( ^^^^ ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal xor. static member ( <<== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise less-than-or-equal test with scalar. static member ( <<== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise less-than-or-equal test with scalar. static member ( <<== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise less-than-or-equal test. static member ( <<>> ): 'T * Tensor<'T> -> Tensor<bool> Element-wise not-equality test with scalar. static member ( <<>> ): Tensor<'T> * 'T -> Tensor<bool> Element-wise not-equality test with scalar. static member ( <<>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise not-equality test. static member ( <<<< ): 'T * Tensor<'T> -> Tensor<bool> Element-wise less-than test with scalar. static member ( <<<< ): Tensor<'T> * 'T -> Tensor<bool> Element-wise less-than test with scalar. static member ( <<<< ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise less-than test. static member ( % ): 'T * Tensor<'T> -> Tensor<'T> Element-wise division with scalar. static member ( % ): Tensor<'T> * 'T -> Tensor<'T> Element-wise remainder of division with scalar. static member ( % ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise remainder of division. static member ( * ): 'T * Tensor<'T> -> Tensor<'T> Element-wise multiplication with scalar. static member ( * ): Tensor<'T> * 'T -> Tensor<'T> Element-wise multiplication with scalar. static member ( * ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise multiplication. static member ( - ): 'T * Tensor<'T> -> Tensor<'T> Element-wise substraction with scalar. static member ( - ): Tensor<'T> * 'T -> Tensor<'T> Element-wise substraction with scalar. static member ( - ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise substraction. static member ( ~~~~ ): Tensor<bool> -> Tensor<bool> Element-wise logical negation. static member ( ~- ): Tensor<'T> -> Tensor<'T> Element-wise negation. static member ( ~+ ): Tensor<'T> -> Tensor<'T> Element-wise prefix plus. See Also ITensor"
  },
  "api/Tensor.Host.BLASModule.lapack_int.html": {
    "href": "api/Tensor.Host.BLASModule.lapack_int.html",
    "title": "Class BLAS.lapack_int (abrv) | Tensor for F#",
    "keywords": "Class BLAS.lapack_int (abrv) Inheritance BLAS.lapack_int (abrv) Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.lapack_int = int64"
  },
  "api/Tensor.Host.BLASModule.__cblas_sdot.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sdot.html",
    "title": "Delegate BLAS.__cblas_sdot | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_sdot Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_sdot = delegate of n:blas_int * x:nativeint * incx:blas_int * y:nativeint * incy:blas_int -> single Methods Name Description abstract member Invoke: blas_int * nativeint * blas_int * nativeint * blas_int -> single"
  },
  "api/Tensor.Host.TensorHostBackend-1.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.html",
    "title": "Class TensorHostBackend<'T> | Tensor for F#",
    "keywords": "Class TensorHostBackend<'T> Backend for host tensors. Inheritance System.Object TensorHostBackend<'T> Implements System.Collections.Generic.IEnumerable <'T> System.Collections.IEnumerable ITensorBackend <'T> Namespace : Tensor.Host Assembly : Tensor.dll Syntax type TensorHostBackend<'T> (layout:TensorLayout, storage:TensorHostStorage<'T>) interface IEnumerable<'T> interface IEnumerable interface ITensorBackend<'T> Parameters Type Name Description TensorLayout layout TensorHostStorage <'T> storage Type Parameters Name Description 'T Constructors Name Description new: TensorLayout * TensorHostStorage<'T> -> TensorHostBackend<'T> Implicit constructor. Properties Name Description property Data: 'T [] underlying data array property Storage: TensorHostStorage<'T> underlying TensorHostStorate<'T> Methods Name Description member Fill: unit -> 'b * ITensorFrontend<'b> * bool -> unit member FillIndexed: int64 [] -> 'b * ITensorFrontend<'b> * bool -> unit member FoldLastAxis: 'b -> 'c -> 'b * ITensorFrontend<'b> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit member FoldLastAxisIndexed: int64 [] -> '?123649 -> '?123650 -> '?123649 * ITensorFrontend<'?123649> * ITensorFrontend<'?123649> * ITensorFrontend<'?123650> * bool -> unit member Map: 'b -> 'c * ITensorFrontend<'c> * ITensorFrontend<'b> * bool -> unit member Map2: 'b -> 'c -> 'd * ITensorFrontend<'d> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit member MapIndexed: int64 [] -> 'b -> 'c * ITensorFrontend<'c> * ITensorFrontend<'b> * bool -> unit member MapIndexed2: int64 [] -> 'b -> 'c -> 'd * ITensorFrontend<'d> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit Explicit Interface Implementations Name Description interface IEnumerable<'T> with member GetEnumerator: unit -> IEnumerator<'T> interface IEnumerable with member GetEnumerator: unit -> IEnumerator interface ITensorBackend<'T> with member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Convert: ITensorFrontend<'T> * ITensorFrontend<'?123664> -> unit interface ITensorBackend<'T> with member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FillConst: 'T * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Item: int64 [] -> 'T interface ITensorBackend<'T> with member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit interface ITensorBackend<'T> with member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Item: int64 [] * 'T -> unit interface ITensorBackend<'T> with member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool interface ITensorBackend<'T> with member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.PinnedMemory.html": {
    "href": "api/Tensor.Host.PinnedMemory.html",
    "title": "Class PinnedMemory | Tensor for F#",
    "keywords": "Class PinnedMemory pinned .NET managed memory (wraps a GCHandle) Inheritance System.Object PinnedMemory Implements System.IDisposable Namespace : Tensor.Host Assembly : Tensor.dll Syntax type PinnedMemory (gcHnd:GCHandle, size:int64) interface IDisposable Parameters Type Name Description System.Runtime.InteropServices.GCHandle gcHnd int64 size Constructors Name Description new: GCHandle * int64 -> PinnedMemory Implicit constructor. Properties Name Description property Ptr: nativeint pointer to storage array property Size: int64 size of storage array in bytes Methods Name Description override member Finalize: unit -> unit Explicit Interface Implementations Name Description interface IDisposable with member Dispose: unit -> unit"
  },
  "api/Tensor.Host.BLASModule.blas_int.html": {
    "href": "api/Tensor.Host.BLASModule.blas_int.html",
    "title": "Class BLAS.blas_int (abrv) | Tensor for F#",
    "keywords": "Class BLAS.blas_int (abrv) Inheritance BLAS.blas_int (abrv) Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.blas_int = int64"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemv.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemv.html",
    "title": "Delegate BLAS.__cblas_sgemv | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_sgemv Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_sgemv = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * alpha:single * a:nativeint * lda:blas_int * x:nativeint * incx:blas_int * beta:single * y:nativeint * incy:blas_int -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemm_batch.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemm_batch.html",
    "title": "Delegate BLAS.__cblas_sgemm_batch | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_sgemm_batch Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_sgemm_batch = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE [] * transB:CBLAS_TRANSPOSE [] * m:blas_int [] * n:blas_int [] * k:blas_int [] * alpha:single [] * a:nativeint [] * lda:blas_int [] * b:nativeint [] * ldb:blas_int [] * beta:single [] * c:nativeint [] * ldc:blas_int [] * group_count:blas_int * group_size:blas_int [] -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemm.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemm.html",
    "title": "Delegate BLAS.__cblas_sgemm | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_sgemm Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_sgemm = delegate of layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * transB:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * k:blas_int * alpha:single * a:nativeint * lda:blas_int * b:nativeint * ldb:blas_int * beta:single * c:nativeint * ldc:blas_int -> unit Methods Name Description abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit"
  },
  "api/Tensor.Host.BLASModule.__cblas_ddot.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_ddot.html",
    "title": "Delegate BLAS.__cblas_ddot | Tensor for F#",
    "keywords": "Delegate BLAS.__cblas_ddot Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__cblas_ddot = delegate of n:blas_int * x:nativeint * incx:blas_int * y:nativeint * incy:blas_int -> double Methods Name Description abstract member Invoke: blas_int * nativeint * blas_int * nativeint * blas_int -> double"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_syevd.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_syevd.html",
    "title": "Delegate BLAS.__LAPACKE_syevd | Tensor for F#",
    "keywords": "Delegate BLAS.__LAPACKE_syevd Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__LAPACKE_syevd = delegate of matrix_layout:int * jobz:char * uplo:char * n:lapack_int * a:nativeint * lda:lapack_int * w:nativeint -> lapack_int Methods Name Description abstract member Invoke: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_gesdd.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_gesdd.html",
    "title": "Delegate BLAS.__LAPACKE_gesdd | Tensor for F#",
    "keywords": "Delegate BLAS.__LAPACKE_gesdd Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__LAPACKE_gesdd = delegate of matrix_layout:int * jobz:char * m:lapack_int * n:lapack_int * a:nativeint * lda:lapack_int * s:nativeint * u:nativeint * ldu:lapack_int * vt:nativeint * ldvt:lapack_int -> lapack_int Methods Name Description abstract member Invoke: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_geev.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_geev.html",
    "title": "Delegate BLAS.__LAPACKE_geev | Tensor for F#",
    "keywords": "Delegate BLAS.__LAPACKE_geev Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS.__LAPACKE_geev = delegate of matrix_layout:int * jobvl:char * jobvr:char * n:lapack_int * a:nativeint * lda:lapack_int * wr:nativeint * wi:nativeint * vl:nativeint * ldvl:lapack_int * vr:nativeint * ldvr:lapack_int -> lapack_int Methods Name Description abstract member Invoke: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int"
  },
  "api/Tensor.Host.BLASModule.CBLAS_TRANSPOSE.html": {
    "href": "api/Tensor.Host.BLASModule.CBLAS_TRANSPOSE.html",
    "title": "Enum BLAS.CBLAS_TRANSPOSE | Tensor for F#",
    "keywords": "Enum BLAS.CBLAS_TRANSPOSE Implements System.IComparable System.IConvertible System.IFormattable Inherited Members abstract member System.Enum.CompareTo: obj -> int abstract member System.Enum.Equals: obj -> bool static member System.Enum.Format: System.Type * obj * string -> string abstract member System.Enum.GetHashCode: unit -> int static member System.Enum.GetName: System.Type * obj -> string static member System.Enum.GetNames: System.Type -> string [] abstract member System.Enum.GetTypeCode: unit -> System.TypeCode static member System.Enum.GetUnderlyingType: System.Type -> System.Type static member System.Enum.GetValues: System.Type -> System.Array member System.Enum.HasFlag: System.Enum -> bool static member System.Enum.IsDefined: System.Type * obj -> bool static member System.Enum.Parse: System.Type * string * bool -> obj static member System.Enum.Parse: System.Type * string -> obj static member System.Enum.ToObject: System.Type * byte -> obj static member System.Enum.ToObject: System.Type * int -> obj static member System.Enum.ToObject: System.Type * int16 -> obj static member System.Enum.ToObject: System.Type * int64 -> obj static member System.Enum.ToObject: System.Type * obj -> obj static member System.Enum.ToObject: System.Type * sbyte -> obj static member System.Enum.ToObject: System.Type * uint16 -> obj static member System.Enum.ToObject: System.Type * uint32 -> obj static member System.Enum.ToObject: System.Type * uint64 -> obj abstract member System.Enum.ToString: System.IFormatProvider -> string abstract member System.Enum.ToString: string * System.IFormatProvider -> string member System.Enum.ToString: string -> string abstract member System.Enum.ToString: unit -> string static member System.Enum.TryParse: string * 'TEnum byref -> bool static member System.Enum.TryParse: string * bool * 'TEnum byref -> bool Namespace : Tensor.Host Assembly : Tensor.dll Syntax enum BLAS.CBLAS_TRANSPOSE val CblasNoTrans = 111 val CblasTrans = 112 val CblasConjTrans = 113 Fields Name Description val CblasConjTrans: CBLAS_TRANSPOSE val CblasNoTrans: CBLAS_TRANSPOSE val CblasTrans: CBLAS_TRANSPOSE"
  },
  "api/Tensor.Host.BLASModule.CBLAS_LAYOUT.html": {
    "href": "api/Tensor.Host.BLASModule.CBLAS_LAYOUT.html",
    "title": "Enum BLAS.CBLAS_LAYOUT | Tensor for F#",
    "keywords": "Enum BLAS.CBLAS_LAYOUT Implements System.IComparable System.IConvertible System.IFormattable Inherited Members abstract member System.Enum.CompareTo: obj -> int abstract member System.Enum.Equals: obj -> bool static member System.Enum.Format: System.Type * obj * string -> string abstract member System.Enum.GetHashCode: unit -> int static member System.Enum.GetName: System.Type * obj -> string static member System.Enum.GetNames: System.Type -> string [] abstract member System.Enum.GetTypeCode: unit -> System.TypeCode static member System.Enum.GetUnderlyingType: System.Type -> System.Type static member System.Enum.GetValues: System.Type -> System.Array member System.Enum.HasFlag: System.Enum -> bool static member System.Enum.IsDefined: System.Type * obj -> bool static member System.Enum.Parse: System.Type * string * bool -> obj static member System.Enum.Parse: System.Type * string -> obj static member System.Enum.ToObject: System.Type * byte -> obj static member System.Enum.ToObject: System.Type * int -> obj static member System.Enum.ToObject: System.Type * int16 -> obj static member System.Enum.ToObject: System.Type * int64 -> obj static member System.Enum.ToObject: System.Type * obj -> obj static member System.Enum.ToObject: System.Type * sbyte -> obj static member System.Enum.ToObject: System.Type * uint16 -> obj static member System.Enum.ToObject: System.Type * uint32 -> obj static member System.Enum.ToObject: System.Type * uint64 -> obj abstract member System.Enum.ToString: System.IFormatProvider -> string abstract member System.Enum.ToString: string * System.IFormatProvider -> string member System.Enum.ToString: string -> string abstract member System.Enum.ToString: unit -> string static member System.Enum.TryParse: string * 'TEnum byref -> bool static member System.Enum.TryParse: string * bool * 'TEnum byref -> bool Namespace : Tensor.Host Assembly : Tensor.dll Syntax enum BLAS.CBLAS_LAYOUT val CblasRowMajor = 101 val CblasColMajor = 102 Fields Name Description val CblasColMajor: CBLAS_LAYOUT val CblasRowMajor: CBLAS_LAYOUT"
  },
  "api/Tensor.Cuda.OutOfCudaMemoryException.html": {
    "href": "api/Tensor.Cuda.OutOfCudaMemoryException.html",
    "title": "Class OutOfCudaMemoryException | Tensor for F#",
    "keywords": "Class OutOfCudaMemoryException Out of CUDA memory. Inheritance System.Object System.Exception OutOfCudaMemoryException Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax exception OutOfCudaMemoryException val msg: string Fields Name Description val msg: string Properties Name Description override property Message: string"
  },
  "api/Tensor.Cuda.NativeTensor.html": {
    "href": "api/Tensor.Cuda.NativeTensor.html",
    "title": "Class NativeTensor (rec) | Tensor for F#",
    "keywords": "Class NativeTensor (rec) C++ tensor marshaling Inheritance System.Object NativeTensor (rec) Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax record NativeTensor val DataType: Type val BasePtr: nativeint val Offset: int64 val Shape: int64 list val Stride: int64 list val Storage: obj Fields Name Description val BasePtr: nativeint val DataType: Type val Offset: int64 val Shape: int64 list val Storage: obj val Stride: int64 list"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.html",
    "title": "Class CudaRegMemHnd | Tensor for F#",
    "keywords": "Class CudaRegMemHnd CUDA registered memory for fast data transfer. Dispose to unregister memory with CUDA. Inheritance System.Object CudaRegMemHnd Implements System.IDisposable Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax type CudaRegMemHnd interface IDisposable Properties Name Description property CudaRegisteredMemory: CudaRegisteredHostMemory<byte> the CudaRegisteredHostMemory property HostArray: ITensorHostStorage the data array property PinHnd: PinnedMemory GC memory pin handle property Ptr: nativeint pointer to data Methods Name Description override member Finalize: unit -> unit Explicit Interface Implementations Name Description interface IDisposable with member Dispose: unit -> unit"
  },
  "api/Tensor.Cuda.CudaRegMem.html": {
    "href": "api/Tensor.Cuda.CudaRegMem.html",
    "title": "Class CudaRegMem (mod) | Tensor for F#",
    "keywords": "Class CudaRegMem (mod) Methods for locking a TensorHostStorage into memory and registering the memory with CUDA for fast data transfers with GPU device. Inheritance CudaRegMem (mod) Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax module CudaRegMem Methods Name Description val get: ITensorHostStorage -> CudaRegMemHnd get CudaRegMemHnd for already locked TensorHostStorage val getCudaRegisteredMemory: ITensorHostStorage -> CudaRegisteredHostMemory<byte> gets the CudaRegisteredMemory for already locked TensorHostStorage without incrementing the reference count val register: ITensorHostStorage -> CudaRegMemHnd registers a TensorHostStorage (multiple registrations are okay) and returns the corresponding CudaRegMemHnd"
  },
  "api/Tensor.BlockTensor-1.html": {
    "href": "api/Tensor.BlockTensor-1.html",
    "title": "Class BlockTensor<'T> (union) | Tensor for F#",
    "keywords": "Class BlockTensor<'T> (union) Block tensor specification. Inheritance System.Object BlockTensor<'T> (union) Namespace : Tensor Assembly : Tensor.dll Syntax union BlockTensor<'T> | SubBlocks of BlockTensor<'T> list | Block of Tensor<'T> Type Parameters Name Description 'T The type of the data stored within the tensor. Remarks See static member ofBlocks: BlockTensor<'T> -> Tensor<'T> for usage information. Properties Name Description Block of Tensor<'T> A block consisting of a single tensor. SubBlocks of BlockTensor<'T> list A block consisting of multiple sub-blocks. See Also static member ofBlocks: BlockTensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Backend.html": {
    "href": "api/Tensor.Backend.html",
    "title": "Namespace Tensor.Backend | Tensor for F#",
    "keywords": "Namespace Tensor.Backend Classes BaseTensorDevice Base tensor device. TensorLayout (rec) Layout (shape, offset, stride) of a Tensor. TensorLayout (mod) Functions for working with TensorLayout. Interfaces ITensorBackend<'T> Tensor backend. ITensorDevice Tensor device. ITensorFrontend<'T> Tensor frontend access (for use from backend). ITensorStorage Tensor storage (type neutral). ITensorStorage<'T> Tensor storage."
  },
  "api/Tensor.Backend.ITensorStorage-1.html": {
    "href": "api/Tensor.Backend.ITensorStorage-1.html",
    "title": "Interface ITensorStorage<'T> | Tensor for F#",
    "keywords": "Interface ITensorStorage<'T> Tensor storage. Implements ITensorStorage Inherited Members abstract property ITensorStorage.Dev: ITensorDevice Namespace : Tensor.Backend Assembly : Tensor.dll Syntax interface ITensorStorage<'T> inherit ITensorStorage Type Parameters Name Description 'T Methods Name Description abstract member Backend: TensorLayout -> ITensorBackend<'T>"
  },
  "api/Tensor.Algorithm.NPZFile.html": {
    "href": "api/Tensor.Algorithm.NPZFile.html",
    "title": "Class NPZFile | Tensor for F#",
    "keywords": "Class NPZFile A Numpy .npz data file. Inheritance System.Object NPZFile Implements System.IDisposable Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax type NPZFile (path:string) interface IDisposable Parameters Type Name Description string path Constructors Name Description new: string -> NPZFile Implicit constructor. Properties Name Description property Names: string list returns all variable names in the .npz file property Path: string path to this .npz file Methods Name Description member Get: string -> Tensor<'?19678> gets the variable with the specified name from the .npz file static member Open: string -> NPZFile opens the specified .npz file Explicit Interface Implementations Name Description interface IDisposable with member Dispose: unit -> unit"
  },
  "api/Tensor.Algorithm.Decomposition.PCAInfo-1.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCAInfo-1.html",
    "title": "Class Decomposition.PCAInfo<'T> (rec) | Tensor for F#",
    "keywords": "Class Decomposition.PCAInfo<'T> (rec) Information about a performed PCA or ZCA. Inheritance System.Object Decomposition.PCAInfo<'T> (rec) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax record Decomposition.PCAInfo<'T> val Means: Tensor<'T> val Variances: Tensor<'T> val Axes: Tensor<'T> Type Parameters Name Description 'T Fields Name Description val Axes: Tensor<'T> the axes corresponding to the principal components val Means: Tensor<'T> the means of the features (for centering the data) val Variances: Tensor<'T> the variances of the principal components in descending order"
  },
  "api/Tensor.SingularMatrixException.html": {
    "href": "api/Tensor.SingularMatrixException.html",
    "title": "Class SingularMatrixException | Tensor for F#",
    "keywords": "Class SingularMatrixException A singular matrix was encountered during an operation that does not allow singular matrices. Inheritance System.Object System.Exception SingularMatrixException Namespace : Tensor Assembly : Tensor.dll Syntax exception SingularMatrixException val msg: string Remarks See the documentation of the method that raised this exception for a detailed description of the error conditions. Fields Name Description val msg: string Properties Name Description override property Message: string Detailed error message."
  },
  "api/Tensor.ITensor.html": {
    "href": "api/Tensor.ITensor.html",
    "title": "Interface ITensor | Tensor for F#",
    "keywords": "Interface ITensor Type-neutral interface to Tensor<'T> of any type 'T. Namespace : Tensor Assembly : Tensor.dll Syntax interface ITensor Remarks These functions are useful for working with tensors of unknown types. For most use cases the functions provided by Tensor<'T> are better suited. Properties Name Description abstract property DataType: Type type of data stored in this tensor abstract property Dev: ITensorDevice storage factory abstract property Full: string full contents string abstract property Item: int64 -> ITensor abstract property Item: Rng list -> ITensor n-dimensional slicing using a list of Rngs abstract property Layout: TensorLayout layout of this tensor (shape, offset and strides) abstract property M: ITensor * ITensor * ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property M: ITensor * ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property M: ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property M: ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property M: ITensor list -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property M: ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. abstract property NDims: int number of dimensions abstract property NElems: int64 number of elements abstract property Pretty: string pretty contents string abstract property Shape: int64 list shape abstract property Storage: ITensorStorage storage of this tensor Methods Name Description abstract member Copy: TensorOrder option -> ITensor returns a copy of the tensor abstract member FillZero: unit -> unit fills the tensors with zeros abstract member Relayout: TensorLayout -> ITensor a tensor with the same storage but new layout abstract member Transfer: ITensorDevice -> ITensor Transfers this tensor to the specifed device. See Also Tensor<'T>"
  },
  "api/Tensor.HostTensor.html": {
    "href": "api/Tensor.HostTensor.html",
    "title": "Class HostTensor (mod) | Tensor for F#",
    "keywords": "Class HostTensor (mod) Functions for creating and operating on tensors stored in host memory. Inheritance HostTensor (mod) Namespace : Tensor Assembly : Tensor.dll Syntax module HostTensor Remarks This module contains functions for creating tensors stored in host memory. It further contains functions that only work with tensors stored in host memory. Calling these functions with tensors stored on other devices will result in an System.InvalidOperationException . Examples let x = HostTensor.zeros [3L; 3L] // x.Dev = HostTensor.Dev Fields Name Description val Dev Tensor device using a .NET array in host memory as data storage. Methods Name Description val arange: 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. val counting: int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. val empty: int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. val falses: int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. val Fill: Tensor<'T> -> unit -> 'T -> unit Fills the tensor with the values returned by the function. val filled: int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. val FillFoldAxis: Tensor<'T> -> 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor, threading an accumulator through the computation. val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit Fills the tensor with values returned by the specifed function. val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor using the specified tensor as target. val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified function to all elements of the two tensors using the specified tensor as target. val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified indexed function to all elements of the tensor using the specified tensor as target. val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified indexed function to all elements of the two tensors using the specified tensor as target. val FillSeq: Tensor<'T> -> seq<'T> -> unit Fills the tensor with the values returned by the given sequence. val foldAxis: 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> Tensor<'T> Applies to specified function to all elements of the tensor, threading an accumulator through the computation. val identity: int64 -> Tensor<'T> Creates a new identity matrix. val init: int64 list -> int64 [] -> 'T -> Tensor<'T> Creates a new tensor with values returned by the specified function. val linspace: 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified function to all elements of the tensor. val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified function to all elements of the two tensors. val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified indexed function to all elements of the tensor. val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified indexed function to all elements of the two tensors. val ofArray: 'T [] -> Tensor<'T> Creates a one-dimensional tensor copying the specified data. val ofArray2D: 'T [,] -> Tensor<'T> Creates a two-dimensional tensor copying the specified data. val ofArray3D: 'T [,,] -> Tensor<'T> Creates a three-dimensional tensor copying the specified data. val ofArray4D: 'T [,,,] -> Tensor<'T> Creates a four-dimensional tensor copying the specified data. val ofList: 'T list -> Tensor<'T> Creates a one-dimensional tensor from the specified list. val ofList2D: 'T list list -> Tensor<'T> Creates a two-dimensional tensor from the specified list of lists. val ofSeq: seq<'T> -> Tensor<'T> Creates a one-dimensional tensor from the specified sequence. val ofSeqWithShape: int64 list -> seq<'T> -> Tensor<'T> Creates a one-dimensional Tensor using the specified sequence and shape. val ones: int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). val randomInt: Random -> int * int -> int64 list -> Tensor<int> Creates a tensor filled with random integer numbers from a uniform distribution. val randomNormal: Random -> 'T * 'T -> int64 list -> Tensor<'T> Creates a tensor filled with random numbers from a normale distribution. val randomUniform: Random -> 'T * 'T -> int64 list -> Tensor<'T> Creates a tensor filled with random floating-point numbers from a uniform distribution. val read: HDF5 -> string -> Tensor<'T> Reads a tensor from the specified HDF5 object path in an HDF5 file. val readUntyped: HDF5 -> string -> ITensor Reads a tensor with unspecified data type from the specified HDF5 object path in an HDF5 file. val scalar: 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. val toArray: Tensor<'T> -> 'T [] Creates an array from a one-dimensional tensor. val toArray2D: Tensor<'T> -> 'T [,] Creates an array from a two-dimensional tensor. val toArray3D: Tensor<'T> -> 'T [,,] Creates an array from a three-dimensional tensor. val toArray4D: Tensor<'T> -> 'T [,,,] Creates an array from a four-dimensional tensor. val toList: Tensor<'T> -> 'T list Creates a list from a one-dimensional tensor. val toList2D: Tensor<'T> -> 'T list list Creates a list of lists from a two-dimensional tensor. val toSeq: Tensor<'T> -> seq<'T> A sequence of all elements contained in the tensor. val transfer: Tensor<'T> -> Tensor<'T> Transfers a tensor to the host device. val trues: int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. val usingArray: 'T [] -> Tensor<'T> Creates a one-dimensional tensor referencing the specified data. val write: HDF5 -> string -> ITensor -> unit Writes the tensor into the HDF5 file under the specfied HDF5 object path. val zeros: int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). See Also Tensor<'T> HostTensor.Parallel (mod)"
  },
  "api/Tensor.HostTensor.Parallel.html": {
    "href": "api/Tensor.HostTensor.Parallel.html",
    "title": "Class HostTensor.Parallel (mod) | Tensor for F#",
    "keywords": "Class HostTensor.Parallel (mod) Multi-threaded operations for tensors stored on the host device. Inheritance HostTensor.Parallel (mod) Namespace : Tensor Assembly : Tensor.dll Syntax module HostTensor.Parallel Methods Name Description val Fill: Tensor<'T> -> unit -> 'T -> unit Fills the tensor with the values returned by the function using multiple threads. val FillFoldAxis: Tensor<'T> -> 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor, threading an accumulator through the computation using multiple threads. val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit Fills the tensor with values returned by the specifed function using multiple threads. val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor using the specified tensor as target using multiple threads. val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified function to all elements of the two tensors using the specified tensor as target using multiple threads. val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified indexed function to all elements of the tensor using the specified tensor as target using multiple threads. val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified indexed function to all elements of the two tensors using the specified tensor as target using multiple threads. val foldAxis: 'T -> 'TA -> 'T -> 'T -> int -> Tensor<'TA> -> Tensor<'T> Applies to specified function to all elements of the tensor, threading an accumulator through the computation using multiple threads. val init: int64 list -> int64 [] -> 'T -> Tensor<'T> Creates a new tensor with values returned by the specified function using multiple threads. val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified function to all elements of the tensor using multiple threads. val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified function to all elements of the two tensors using multiple threads. val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified indexed function to all elements of the tensor using multiple threads. val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified indexed function to all elements of the two tensors using multiple threads. See Also HostTensor (mod)"
  },
  "api/Tensor.Host.html": {
    "href": "api/Tensor.Host.html",
    "title": "Namespace Tensor.Host | Tensor for F#",
    "keywords": "Namespace Tensor.Host Classes BLAS BLAS / LAPACK library BLASLib (union) BLAS and LAPACK libraries. BLAS (mod) BLAS / LAPACK library BLAS.blas_int (abrv) BLAS.Impl BLAS/LAPACK native library BLAS.lapack_int (abrv) Cfg Options for configuring operations performed on hosts tensors. PinnedMemory pinned .NET managed memory (wraps a GCHandle) TensorHostBackend<'T> Backend for host tensors. TensorHostDevice Factory for host tensors. TensorHostStorage<'T> Storage (using a .NET array) for host tensors. Interfaces ITensorHostStorage type-neutral interface to TensorHostStorage<'T> Enums BLAS.CBLAS_LAYOUT BLAS.CBLAS_TRANSPOSE BLAS.CBLAS_UPLO Delegates BLAS.__cblas_ddot BLAS.__cblas_dgemm BLAS.__cblas_dgemm_batch BLAS.__cblas_dgemv BLAS.__cblas_sdot BLAS.__cblas_sgemm BLAS.__cblas_sgemm_batch BLAS.__cblas_sgemv BLAS.__LAPACKE_geev BLAS.__LAPACKE_gesdd BLAS.__LAPACKE_getrf BLAS.__LAPACKE_getri BLAS.__LAPACKE_syevd"
  },
  "api/Tensor.Host.ITensorHostStorage.html": {
    "href": "api/Tensor.Host.ITensorHostStorage.html",
    "title": "Interface ITensorHostStorage | Tensor for F#",
    "keywords": "Interface ITensorHostStorage type-neutral interface to TensorHostStorage<'T> Namespace : Tensor.Host Assembly : Tensor.dll Syntax interface ITensorHostStorage Properties Name Description abstract property Data: Array the underlying data array abstract property DataSize: int64 size of underlying data array in elements abstract property DataSizeInBytes: int64 size of underlying data array in bytes Methods Name Description abstract member Pin: unit -> PinnedMemory pins the underlying data array and returns the corresponding pinned memory"
  },
  "api/Tensor.Host.Cfg.html": {
    "href": "api/Tensor.Host.Cfg.html",
    "title": "Class Cfg | Tensor for F#",
    "keywords": "Class Cfg Options for configuring operations performed on hosts tensors. Inheritance System.Object Cfg Namespace : Tensor.Host Assembly : Tensor.dll Syntax type Cfg Properties Name Description static property BLASLib: BLASLib The BLAS and LAPACK library to use. See Also HostTensor (mod)"
  },
  "api/Tensor.Host.BLASModule.html": {
    "href": "api/Tensor.Host.BLASModule.html",
    "title": "Class BLAS (mod) | Tensor for F#",
    "keywords": "Class BLAS (mod) BLAS / LAPACK library Inheritance BLAS (mod) Namespace : Tensor.Host Assembly : Tensor.dll Syntax module BLAS Fields Name Description val LAPACK_COL_MAJOR val LAPACK_ROW_MAJOR"
  },
  "api/Tensor.Host.BLASModule.CBLAS_UPLO.html": {
    "href": "api/Tensor.Host.BLASModule.CBLAS_UPLO.html",
    "title": "Enum BLAS.CBLAS_UPLO | Tensor for F#",
    "keywords": "Enum BLAS.CBLAS_UPLO Implements System.IComparable System.IConvertible System.IFormattable Inherited Members abstract member System.Enum.CompareTo: obj -> int abstract member System.Enum.Equals: obj -> bool static member System.Enum.Format: System.Type * obj * string -> string abstract member System.Enum.GetHashCode: unit -> int static member System.Enum.GetName: System.Type * obj -> string static member System.Enum.GetNames: System.Type -> string [] abstract member System.Enum.GetTypeCode: unit -> System.TypeCode static member System.Enum.GetUnderlyingType: System.Type -> System.Type static member System.Enum.GetValues: System.Type -> System.Array member System.Enum.HasFlag: System.Enum -> bool static member System.Enum.IsDefined: System.Type * obj -> bool static member System.Enum.Parse: System.Type * string * bool -> obj static member System.Enum.Parse: System.Type * string -> obj static member System.Enum.ToObject: System.Type * byte -> obj static member System.Enum.ToObject: System.Type * int -> obj static member System.Enum.ToObject: System.Type * int16 -> obj static member System.Enum.ToObject: System.Type * int64 -> obj static member System.Enum.ToObject: System.Type * obj -> obj static member System.Enum.ToObject: System.Type * sbyte -> obj static member System.Enum.ToObject: System.Type * uint16 -> obj static member System.Enum.ToObject: System.Type * uint32 -> obj static member System.Enum.ToObject: System.Type * uint64 -> obj abstract member System.Enum.ToString: System.IFormatProvider -> string abstract member System.Enum.ToString: string * System.IFormatProvider -> string member System.Enum.ToString: string -> string abstract member System.Enum.ToString: unit -> string static member System.Enum.TryParse: string * 'TEnum byref -> bool static member System.Enum.TryParse: string * bool * 'TEnum byref -> bool Namespace : Tensor.Host Assembly : Tensor.dll Syntax enum BLAS.CBLAS_UPLO val CblasUpper = 121 val CblasLower = 122 Fields Name Description val CblasLower: CBLAS_UPLO val CblasUpper: CBLAS_UPLO"
  },
  "api/Tensor.Host.BLASLib.html": {
    "href": "api/Tensor.Host.BLASLib.html",
    "title": "Class BLASLib (union) | Tensor for F#",
    "keywords": "Class BLASLib (union) BLAS and LAPACK libraries. Inheritance System.Object BLASLib (union) Namespace : Tensor.Host Assembly : Tensor.dll Syntax [<RequireQualifiedAccess>] union BLASLib | Vendor | IntelMKL | OpenBLAS | Custom of blas: NativeLibName * lapack: NativeLibName Properties Name Description Custom of blas: NativeLibName * lapack: NativeLibName Custom BLAS and LAPACK libraries. IntelMKL Intel MKL BLAS and LAPACK OpenBLAS OpenBLAS BLAS and LAPACK Vendor Vendor BLAS and LAPACK. See Also Cfg.BLAS"
  },
  "api/Tensor.Host.BLAS.html": {
    "href": "api/Tensor.Host.BLAS.html",
    "title": "Class BLAS | Tensor for F#",
    "keywords": "Class BLAS BLAS / LAPACK library Inheritance System.Object BLAS Namespace : Tensor.Host Assembly : Tensor.dll Syntax type BLAS Properties Name Description static property F: Impl Access to actual implementation"
  },
  "api/Tensor.Cuda.html": {
    "href": "api/Tensor.Cuda.html",
    "title": "Namespace Tensor.Cuda | Tensor for F#",
    "keywords": "Namespace Tensor.Cuda Classes CannotCudaRegisterMemoryException Cannot register host memory with CUDA, maybe because it is not properly aligned. Cfg Options for configuring operations performed on CUDA tensors. CudaRegMem (mod) Methods for locking a TensorHostStorage into memory and registering the memory with CUDA for fast data transfers with GPU device. CudaRegMemHnd CUDA registered memory for fast data transfer. Dispose to unregister memory with CUDA. NativeIdxTensors (rec) C++ NativeIdx NativeIdxTensorsInfo (rec) C++ NativeIdx template info NativeTensor (rec) C++ tensor marshaling OutOfCudaMemoryException Out of CUDA memory. TensorCudaBackend<'T> CUDA backend for tensors. TensorCudaDevice Creates Tensors on a CUDA device. TensorCudaStorage<'T> Tensor storage on a CUDA device. Interfaces ITensorCudaBackend type-neutral interface to CUDA backend for tensors ITensorCudaStorage type neutral interface to a CudaStorageT"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.html",
    "title": "Class TensorCudaStorage<'T> | Tensor for F#",
    "keywords": "Class TensorCudaStorage<'T> Tensor storage on a CUDA device. Inheritance System.Object TensorCudaStorage<'T> Implements Tensor.Backend.BLASModule.IBLASStorage ITensorStorage ITensorStorage <'T> ITensorCudaStorage Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax type TensorCudaStorage<'T> (data:CudaDeviceVariable<'T>) interface IBLASStorage interface ITensorCudaStorage interface ITensorStorage<'T> interface ITensorStorage Parameters Type Name Description ManagedCuda.CudaDeviceVariable <'T> data Type Parameters Name Description 'T Constructors Name Description new: int64 -> TensorCudaStorage<'T> new: CudaDeviceVariable<'T> -> TensorCudaStorage<'T> Implicit constructor. Properties Name Description property ByteData: CudaDeviceVariable<byte> data device variable as CudaDeviceVariable property Data: CudaDeviceVariable<'T> data device variable property DataSize: int64 data size in elements property DataSizeInBytes: int64 data size in bytes property Item: int64 -> 'T data item access Methods Name Description override member Finalize: unit -> unit Explicit Interface Implementations Name Description interface ITensorStorage<'T> with member Backend: TensorLayout -> ITensorBackend<'T> interface ITensorStorage with member Dev: unit -> ITensorDevice"
  },
  "api/Tensor.Cuda.TensorCudaDevice.html": {
    "href": "api/Tensor.Cuda.TensorCudaDevice.html",
    "title": "Class TensorCudaDevice | Tensor for F#",
    "keywords": "Class TensorCudaDevice Creates Tensors on a CUDA device. Inheritance System.Object BaseTensorDevice TensorCudaDevice Implements System.IComparable System.IComparable < ITensorDevice > System.IEquatable < ITensorDevice > ITensorDevice Inherited Members abstract member BaseTensorDevice.Create: int64 -> ITensorStorage<'T> override member BaseTensorDevice.Equals: obj -> bool override member BaseTensorDevice.GetHashCode: unit -> int abstract property BaseTensorDevice.Id: string interface IComparable with member BaseTensorDevice.CompareTo: obj -> int interface IComparable<ITensorDevice> with member BaseTensorDevice.CompareTo: ITensorDevice -> int interface IEquatable<ITensorDevice> with member BaseTensorDevice.Equals: ITensorDevice -> bool interface ITensorDevice with member BaseTensorDevice.Create: int64 -> ITensorStorage<'?40621> override member BaseTensorDevice.ToString: unit -> string abstract property BaseTensorDevice.Zeroed: bool Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax type TensorCudaDevice inherit BaseTensorDevice interface ITensorDevice interface IEquatable<ITensorDevice> interface IComparable<ITensorDevice> interface IComparable Properties Name Description override property Id: string static property Instance: TensorCudaDevice override property Zeroed: bool Methods Name Description override member Create: int64 -> ITensorStorage<'?153615>"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.html",
    "title": "Class TensorCudaBackend<'T> | Tensor for F#",
    "keywords": "Class TensorCudaBackend<'T> CUDA backend for tensors. Inheritance System.Object TensorCudaBackend<'T> Implements ITensorBackend <'T> ITensorCudaBackend Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax type TensorCudaBackend<'T> (layout:TensorLayout, storage:TensorCudaStorage<'T>) interface ITensorBackend<'T> interface ITensorCudaBackend Parameters Type Name Description TensorLayout layout TensorCudaStorage <'T> storage Type Parameters Name Description 'T Constructors Name Description new: TensorLayout * TensorCudaStorage<'T> -> TensorCudaBackend<'T> Implicit constructor. Properties Name Description property DevicePtr: nativeint device pointer to first element of this tensor Explicit Interface Implementations Name Description interface ITensorBackend<'T> with member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Convert: ITensorFrontend<'T> * ITensorFrontend<'?153486> -> unit interface ITensorBackend<'T> with member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FillConst: 'T * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Item: int64 [] -> 'T interface ITensorBackend<'T> with member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit interface ITensorBackend<'T> with member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Item: int64 [] * 'T -> unit interface ITensorBackend<'T> with member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool interface ITensorBackend<'T> with member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit interface ITensorBackend<'T> with member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit interface ITensorBackend<'T> with member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.ITensorCudaStorage.html": {
    "href": "api/Tensor.Cuda.ITensorCudaStorage.html",
    "title": "Interface ITensorCudaStorage | Tensor for F#",
    "keywords": "Interface ITensorCudaStorage type neutral interface to a CudaStorageT Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax interface ITensorCudaStorage Properties Name Description abstract property ByteData: CudaDeviceVariable<byte> abstract property DataSize: int64 abstract property DataSizeInBytes: int64"
  },
  "api/Tensor.Algorithm.html": {
    "href": "api/Tensor.Algorithm.html",
    "title": "Namespace Tensor.Algorithm | Tensor for F#",
    "keywords": "Namespace Tensor.Algorithm Classes BigIntegerExtensions (mod) Extensions to System.Numerics.BigInteger. Decomposition.PCA Principal Component Analysis (PCA) Decomposition.PCAInfo<'T> (rec) Information about a performed PCA or ZCA. Decomposition.ZCA ZCA whitening LinAlg (mod) Linear algebra algorithms NPYFile (mod) methods for accessing Numpy .npy data files. NPZFile A Numpy .npz data file. RatRecognizers (mod) Active recognizers for rational numbers. Structs Rat A rational number, i.e. a fraction of arbitrary precision."
  },
  "api/Tensor.Algorithm.Rat.html": {
    "href": "api/Tensor.Algorithm.Rat.html",
    "title": "Struct Rat | Tensor for F#",
    "keywords": "Struct Rat A rational number, i.e. a fraction of arbitrary precision. Implements System.IComparable System.IComparable < Rat > System.IEquatable < Rat > Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax [<Struct; CustomEquality; CustomComparison>] type Rat inherit ValueType interface IComparable interface IComparable<Rat> interface IEquatable<Rat> Constructors Name Description new: int32 * int32 -> Rat Constructs a fraction from numerator and denominator. new: int32 -> Rat Constructs an integer rational number. new: int64 * int64 -> Rat Constructs a fraction from numerator and denominator. new: int64 -> Rat Constructs an integer rational number. new: BigInteger * BigInteger -> Rat Constructs a fraction from numerator and denominator. new: BigInteger -> Rat Constructs an integer rational number. new: uint32 * uint32 -> Rat Constructs a fraction from numerator and denominator. new: uint32 -> Rat Constructs an integer rational number. new: uint64 * uint64 -> Rat Constructs a fraction from numerator and denominator. new: uint64 -> Rat Constructs an integer rational number. Fields Name Description val Num: bigint the numerator Properties Name Description property Dnm: bigint the denominator property IsFinite: bool True if this is a finite number (not infinity and not NaN). property IsInf: bool True is this is infinity. property IsInt: bool True if this is an integer, i.e. denominator is one. property IsNaN: bool True if this is not-a-number. property IsNegInf: bool True is this is negative infinity. property IsPosInf: bool True is this is positive infinity. static property MaxValue: Rat static property MinusOne: Rat static property MinValue: Rat static property NaN: Rat static property NegInf: Rat static property One: Rat static property PosInf: Rat property Pretty: string Pretty string representation. static property Zero: Rat Methods Name Description static member Abs: Rat -> Rat static member Ceiling: Rat -> Rat static member dnm: Rat -> bigint denominator override member Equals: obj -> bool static member Floor: Rat -> Rat static member get_Sign: Rat -> int override member GetHashCode: unit -> int static member isFinite: Rat -> bool True if a is a finite number. static member isInf: Rat -> bool True if a is infinity. static member isInteger: Rat -> bool True if a is an integer, i.e. its denominator is one. static member isNaN: Rat -> bool True if a is not-a-number. static member isNegInf: Rat -> bool True if a is negative infinity. static member isPosInf: Rat -> bool True if a is positive infinity. static member num: Rat -> bigint numerator override member ToString: unit -> string static member Truncate: Rat -> Rat Operators Name Description static member ( + ): Rat * Rat -> Rat static member ( / ): Rat * Rat -> Rat static member op_Explicit: Rat -> bigint static member op_Explicit: Rat -> double static member op_Explicit: Rat -> int32 static member op_Explicit: Rat -> int64 static member op_Explicit: Rat -> single static member op_Explicit: Rat -> uint32 static member op_Explicit: Rat -> uint64 static member op_Implicit: bigint -> Rat static member op_Implicit: int32 -> Rat static member op_Implicit: int64 -> Rat static member op_Implicit: uint32 -> Rat static member op_Implicit: uint64 -> Rat static member ( % ): Rat * Rat -> Rat static member ( * ): Rat * Rat -> Rat static member ( - ): Rat * Rat -> Rat static member ( ~- ): Rat -> Rat static member ( ~+ ): Rat -> Rat Explicit Interface Implementations Name Description interface IComparable<Rat> with member CompareTo: Rat -> int interface IComparable with member CompareTo: obj -> int interface IEquatable<Rat> with member Equals: Rat -> bool"
  },
  "api/Tensor.Algorithm.NPYFile.html": {
    "href": "api/Tensor.Algorithm.NPYFile.html",
    "title": "Class NPYFile (mod) | Tensor for F#",
    "keywords": "Class NPYFile (mod) methods for accessing Numpy .npy data files. Inheritance NPYFile (mod) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax module NPYFile Methods Name Description val load: string -> Tensor<'?19684> loads a .npy file from the specified path val loadFromStream: Stream -> string -> Tensor<'T> loads a .npy file from the specified stream"
  },
  "api/Tensor.Algorithm.Decomposition.ZCA.html": {
    "href": "api/Tensor.Algorithm.Decomposition.ZCA.html",
    "title": "Class Decomposition.ZCA | Tensor for F#",
    "keywords": "Class Decomposition.ZCA ZCA whitening Inheritance System.Object Decomposition.ZCA Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax type Decomposition.ZCA () Constructors Name Description new: unit -> ZCA Implicit constructor. Methods Name Description static member Perform: Tensor<'T> -> Tensor<'T> * PCAInfo<'T> Apply ZCA whitening. data must be of the form [sample, feature]. Returns a tensor of the form [sample, component]. static member Reverse: Tensor<'T> * PCAInfo<'T> -> Tensor<'T> Reverses ZCA whitening. whitened must be of the form [sample, component]."
  },
  "api/Tensor.Algorithm.Decomposition.PCA.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCA.html",
    "title": "Class Decomposition.PCA | Tensor for F#",
    "keywords": "Class Decomposition.PCA Principal Component Analysis (PCA) Inheritance System.Object Decomposition.PCA Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax type Decomposition.PCA () Constructors Name Description new: unit -> PCA Implicit constructor. Methods Name Description static member Perform: Tensor<'T> * int64 option -> Tensor<'T> * PCAInfo<'T> Apply Principal Component Analysis (PCA) whitening. data must be of the form [sample, feature]. nComps optionally specifies how many components to keep. Returns a tensor of the form [sample, component]. static member Reverse: Tensor<'T> * PCAInfo<'T> -> Tensor<'T> Reverses PCA whitening. whitened must be of the form [sample, component]."
  },
  "api/Tensor.html": {
    "href": "api/Tensor.html",
    "title": "Namespace Tensor | Tensor for F#",
    "keywords": "Namespace Tensor Classes BlockTensor<'T> (union) Block tensor specification. CudaTensor (mod) Functions for creating and operating on tensors stored on a nVidia CUDA GPU. HDF5 An object representing an HDF5 file. HostTensor (mod) Functions for creating and operating on tensors stored in host memory. HostTensor.Parallel (mod) Multi-threaded operations for tensors stored on the host device. ITensor (mod) Type-neutral interface to Tensor<'T> of any type 'T. MatrixPart (union) Upper or lower trianguler part of a matrix. Operators (mod) Useful core operators. Rng (union) Range over a dimension of a tensor. SingularMatrixException A singular matrix was encountered during an operation that does not allow singular matrices. Tensor<'T> An N-dimensional array with elements of type 'T. TensorOrder (union) Memory ordering of a tensor. TensorVal (mod) Special constants that can be passed instead of indicies or parameter values or be returned from methods. Interfaces ITensor Type-neutral interface to Tensor<'T> of any type 'T."
  },
  "api/Tensor.Rng.html": {
    "href": "api/Tensor.Rng.html",
    "title": "Class Rng (union) | Tensor for F#",
    "keywords": "Class Rng (union) Range over a dimension of a tensor. Inheritance System.Object Rng (union) Namespace : Tensor Assembly : Tensor.dll Syntax [<RequireQualifiedAccess>] union Rng | Elem of int64 | Rng of first: int64 option * last: int64 option | NewAxis | AllFill Properties Name Description static property All: Rng All elements. AllFill Take all elements of remaining dimensions. Elem of int64 The single element specified. NewAxis Insert broadcastable axis of size 1. property Pretty: string Pretty string. Rng of first: int64 option * last: int64 option Range of elements, including first and last."
  },
  "api/Tensor.Operators.html": {
    "href": "api/Tensor.Operators.html",
    "title": "Class Operators (mod) | Tensor for F#",
    "keywords": "Class Operators (mod) Useful core operators. Inheritance Operators (mod) Namespace : Tensor Assembly : Tensor.dll Syntax [<AutoOpen>] module Operators Methods Name Description val sgn: 'T -> 'T Sign of value returned using same type as input."
  },
  "api/Tensor.MatrixPart.html": {
    "href": "api/Tensor.MatrixPart.html",
    "title": "Class MatrixPart (union) | Tensor for F#",
    "keywords": "Class MatrixPart (union) Upper or lower trianguler part of a matrix. Inheritance System.Object MatrixPart (union) Namespace : Tensor Assembly : Tensor.dll Syntax [<RequireQualifiedAccess>] union MatrixPart | Upper | Lower Properties Name Description Lower Lower triangular part of the matrix. Upper Upper triangular part of the matrix."
  },
  "api/Tensor.ITensorModule.html": {
    "href": "api/Tensor.ITensorModule.html",
    "title": "Class ITensor (mod) | Tensor for F#",
    "keywords": "Class ITensor (mod) Type-neutral interface to Tensor<'T> of any type 'T. Inheritance ITensor (mod) Namespace : Tensor Assembly : Tensor.dll Syntax module ITensor Remarks These functions are useful for working with tensors of unknown types. For most use cases the functions provided by Tensor<'T> are better suited. Methods Name Description val allIdx: ITensor -> seq<int64 list> Gets a sequence of all indices to enumerate all elements within the tensor. val atLeast1D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least one dimension. val atLeast2D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least two dimensions. val atLeast3D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least three dimensions. val atLeastND: int -> ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least the specified number of dimensions. val broadcastDim: int -> int64 -> ITensor -> ITensor Broadcast a dimension to a specified size. val broadcastTo: int64 list -> ITensor -> ITensor Broadcasts the specified tensor to the specified shape. val broadcastToSame: ITensor list -> ITensor list Broadcasts all specified tensors to have the same shape. val broadcastToSameInDims: seq<int> * ITensor list -> ITensor list Broadcasts all specified tensors to have the same size in the specified dimensions. val copy: ITensor -> ITensor Returns a copy of the tensor. val cutLeft: ITensor -> ITensor Removes the first dimension. val cutRight: ITensor -> ITensor Removes the last dimension. val dataType: ITensor -> Type Type of data stored within the tensor. val dev: ITensor -> ITensorDevice Device the data of tensor is stored on. val flatten: ITensor -> ITensor Flattens the tensor into a (one-dimensional) vector. val insertAxis: int -> ITensor -> ITensor Insert a dimension of size one before the specifed dimension. val isBroadcasted: ITensor -> bool Checks if the specified tensor is broadcasted in at least one dimension. val layout: ITensor -> TensorLayout Memory layout of the tensor. val nDims: ITensor -> int Dimensionality of the tensor. val nElems: ITensor -> int64 Total number of elements within the tensor. val padLeft: ITensor -> ITensor Insert a dimension of size one as the first dimension. val padRight: ITensor -> ITensor Append a dimension of size one after the last dimension. val padToSame: ITensor list -> ITensor list Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. val permuteAxes: int list -> ITensor -> ITensor Permutes the axes as specified. val range: Rng list -> ITensor -> ITensor Get a slice (part) of the tensor. val relayout: TensorLayout -> ITensor -> ITensor Creates a tensor with the specified layout sharing its storage with the original tensor. val reshape: int64 list -> ITensor -> ITensor Changes the shape of a tensor. val reshapeView: int64 list -> ITensor -> ITensor Creates a reshaped view of the tensor (without copying). val reverseAxis: int -> ITensor -> ITensor Reverses the elements in the specified dimension. val shape: ITensor -> int64 list Shape of the tensor. val swapDim: int -> int -> ITensor -> ITensor Swaps the specified dimensions of the tensor. val transfer: ITensorDevice -> ITensor -> ITensor Transfers a tensor to the specifed device. val transpose: ITensor -> ITensor Transpose of a matrix. val tryReshapeView: int64 list -> ITensor -> ITensor option Tries to create a reshaped view of the tensor (without copying). See Also Tensor<'T>"
  },
  "api/Tensor.Host.TensorHostStorage-1.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.html",
    "title": "Class TensorHostStorage<'T> | Tensor for F#",
    "keywords": "Class TensorHostStorage<'T> Storage (using a .NET array) for host tensors. Inheritance System.Object TensorHostStorage<'T> Implements Tensor.Backend.BLASModule.IBLASStorage ITensorStorage ITensorStorage <'T> ITensorHostStorage Namespace : Tensor.Host Assembly : Tensor.dll Syntax type TensorHostStorage<'T> (data:'T []) interface IBLASStorage interface ITensorHostStorage interface ITensorStorage<'T> interface ITensorStorage Parameters Type Name Description 'T [] data Type Parameters Name Description 'T Constructors Name Description new: int64 -> TensorHostStorage<'T> allocates a new data array with the given number of elements new: 'T [] -> TensorHostStorage<'T> Implicit constructor. Properties Name Description property Data: 'T [] the underlying data array property DataSize: int64 size of underlying data array in elements property DataSizeInBytes: int64 size of underlying data array in bytes Methods Name Description override member Equals: obj -> bool override member GetHashCode: unit -> int member Pin: unit -> PinnedMemory pins the underlying data array and returns the corresponding pinned memory Explicit Interface Implementations Name Description interface ITensorStorage<'T> with member Backend: TensorLayout -> ITensorBackend<'T> interface ITensorStorage with member Dev: unit -> ITensorDevice interface ITensorHostStorage with member Pin: unit -> PinnedMemory"
  },
  "api/Tensor.Host.TensorHostDevice.html": {
    "href": "api/Tensor.Host.TensorHostDevice.html",
    "title": "Class TensorHostDevice | Tensor for F#",
    "keywords": "Class TensorHostDevice Factory for host tensors. Inheritance System.Object BaseTensorDevice TensorHostDevice Implements System.IComparable System.IComparable < ITensorDevice > System.IEquatable < ITensorDevice > ITensorDevice Inherited Members abstract member BaseTensorDevice.Create: int64 -> ITensorStorage<'T> override member BaseTensorDevice.Equals: obj -> bool override member BaseTensorDevice.GetHashCode: unit -> int abstract property BaseTensorDevice.Id: string interface IComparable with member BaseTensorDevice.CompareTo: obj -> int interface IComparable<ITensorDevice> with member BaseTensorDevice.CompareTo: ITensorDevice -> int interface IEquatable<ITensorDevice> with member BaseTensorDevice.Equals: ITensorDevice -> bool interface ITensorDevice with member BaseTensorDevice.Create: int64 -> ITensorStorage<'?40621> override member BaseTensorDevice.ToString: unit -> string abstract property BaseTensorDevice.Zeroed: bool Namespace : Tensor.Host Assembly : Tensor.dll Syntax type TensorHostDevice inherit BaseTensorDevice interface ITensorDevice interface IEquatable<ITensorDevice> interface IComparable<ITensorDevice> interface IComparable Properties Name Description override property Id: string static property Instance: TensorHostDevice override property Zeroed: bool Methods Name Description override member Create: int64 -> ITensorStorage<'?123796>"
  },
  "api/Tensor.HDF5.html": {
    "href": "api/Tensor.HDF5.html",
    "title": "Class HDF5 | Tensor for F#",
    "keywords": "Class HDF5 An object representing an HDF5 file. Inheritance System.Object HDF5 Implements System.IDisposable Namespace : Tensor Assembly : Tensor.dll Syntax type HDF5 interface IDisposable Remarks HDF5 is an open, cross-plattform, industry-standard file format for data exchange. More information is available at https://www.hdfgroup.org . This object represents an HDF5 file. Use static member OpenRead: string -> HDF5 and static member OpenWrite: string -> HDF5 to open an HDF5 file for reading or writing. This object does not aim to expose all functions provided by the HDF5 standard. Instead, it focuses on providing a simple interface for reading and writing arrays as well as attributes. Methods Name Description member CreateGroups: string -> unit Creates the given group path. member Dispose: unit -> unit Closes the HDF5 file. member Exists: string -> bool Checks whether an object (array or group) with the given name exists. override member Finalize: unit -> unit Closes the HDF5 file. member GetAttribute: string * string -> 'T Get attribute value on an HDF5 object. member GetDataType: string -> Type Get data type of array in HDF5 file. member GetRecord: string -> 'R Get attribute values on an HDF5 object and returns them as a record. static member OpenRead: string -> HDF5 Opens the specified HDF5 file for reading. static member OpenWrite: string -> HDF5 Opens the specified HDF5 file for writing. member Read: string -> array<'T> * int64 list Read data array from HDF5 file. member SetAttribute: string * string * 'T -> unit Set attribute value on an HDF5 object. member SetRecord: string * 'R -> unit Set attribute values on an HDF5 object using the provided record. member Write: string * array<'T> * int64 list -> unit Write data array to HDF5 file. Explicit Interface Implementations Name Description interface IDisposable with member Dispose: unit -> unit Closes the HDF5 file."
  },
  "api/Tensor.CudaTensor.html": {
    "href": "api/Tensor.CudaTensor.html",
    "title": "Class CudaTensor (mod) | Tensor for F#",
    "keywords": "Class CudaTensor (mod) Functions for creating and operating on tensors stored on a nVidia CUDA GPU. Inheritance CudaTensor (mod) Namespace : Tensor Assembly : Tensor.dll Syntax module CudaTensor Remarks This module contains functions for creating tensors stored on a nVidia CUDA GPU. It further contains functions that only work with tensors stored on a nVidia CUDA GPU. Calling these functions with tensors stored on other devices will result in an System.InvalidOperationException . The CUDA backend provides options that can be configured via Cfg . Examples let x = CudaTensor.zeros [3L; 3L] // x.Dev = CudaTensor.Dev Fields Name Description val Dev Tensor device using CUDA GPU memory as data storage. Methods Name Description val arange: 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. val counting: int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. val empty: int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. val falses: int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. val filled: int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. val identity: int64 -> Tensor<'T> Creates a new identity matrix. val linspace: 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. val ones: int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). val scalar: 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. val transfer: Tensor<'T> -> Tensor<'T> Transfers a tensor to the CUDA device. val trues: int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. val usingPtr: CUdeviceptr -> SizeT -> TensorLayout -> Tensor<'T> Creates a tensor from the given CUDA pointer, allocation size in bytes and layout. val usingPtrAndType: CUdeviceptr -> SizeT -> Type -> TensorLayout -> ITensor Creates a tensor from the given CUDA pointer, allocation size in bytes, type and layout. val zeros: int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). See Also Tensor<'T> Cfg"
  },
  "api/Tensor.Cuda.NativeIdxTensorsInfo.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensorsInfo.html",
    "title": "Class NativeIdxTensorsInfo (rec) | Tensor for F#",
    "keywords": "Class NativeIdxTensorsInfo (rec) C++ NativeIdx template info Inheritance System.Object NativeIdxTensorsInfo (rec) Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax record NativeIdxTensorsInfo val NDims: int val NIdxs: int Fields Name Description val NDims: int val NIdxs: int"
  },
  "api/Tensor.Cuda.NativeIdxTensors.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensors.html",
    "title": "Class NativeIdxTensors (rec) | Tensor for F#",
    "keywords": "Class NativeIdxTensors (rec) C++ NativeIdx Inheritance System.Object NativeIdxTensors (rec) Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax record NativeIdxTensors val NDims: int val Idxs: NativeTensor option list Fields Name Description val Idxs: NativeTensor option list val NDims: int"
  },
  "api/Tensor.Backend.ITensorDevice.html": {
    "href": "api/Tensor.Backend.ITensorDevice.html",
    "title": "Interface ITensorDevice | Tensor for F#",
    "keywords": "Interface ITensorDevice Tensor device. Implements System.IComparable System.IComparable < ITensorDevice > System.IEquatable < ITensorDevice > Inherited Members abstract member System.IComparable.CompareTo: obj -> int abstract member System.IComparable.CompareTo: 'T -> int abstract member System.IEquatable.Equals: 'T -> bool Namespace : Tensor.Backend Assembly : Tensor.dll Syntax interface ITensorDevice Properties Name Description abstract property Id: string abstract property Zeroed: bool Methods Name Description abstract member Create: int64 -> ITensorStorage<'T>"
  },
  "api/Tensor.Backend.BaseTensorDevice.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.html",
    "title": "Class BaseTensorDevice | Tensor for F#",
    "keywords": "Class BaseTensorDevice Base tensor device. Inheritance System.Object BaseTensorDevice Implements System.IComparable System.IComparable < ITensorDevice > System.IEquatable < ITensorDevice > ITensorDevice Namespace : Tensor.Backend Assembly : Tensor.dll Syntax [<AbstractClass>] type BaseTensorDevice () interface ITensorDevice interface IEquatable<ITensorDevice> interface IComparable<ITensorDevice> interface IComparable Constructors Name Description new: unit -> BaseTensorDevice Implicit constructor. Properties Name Description abstract property Id: string abstract property Zeroed: bool Methods Name Description abstract member Create: int64 -> ITensorStorage<'T> override member Equals: obj -> bool override member GetHashCode: unit -> int override member ToString: unit -> string Explicit Interface Implementations Name Description interface IComparable<ITensorDevice> with member CompareTo: ITensorDevice -> int interface IComparable with member CompareTo: obj -> int interface IEquatable<ITensorDevice> with member Equals: ITensorDevice -> bool interface ITensorDevice with member Create: int64 -> ITensorStorage<'?40621>"
  },
  "api/Tensor.Algorithm.RatRecognizers.html": {
    "href": "api/Tensor.Algorithm.RatRecognizers.html",
    "title": "Class RatRecognizers (mod) | Tensor for F#",
    "keywords": "Class RatRecognizers (mod) Active recognizers for rational numbers. Inheritance RatRecognizers (mod) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax [<AutoOpen>] module RatRecognizers Methods Name Description val ( |Rat| ): Rat -> bigint * bigint decomposes a rational into its numerator and denominator val ( |RatFrac|RatInt|RatPosInf|RatNegInf|RatNaN| ): Rat RatFrac(num,dnm) matches a true (finite) fraction and RatInteger(value) matches an integer rational number."
  },
  "api/Tensor.Algorithm.LinAlg.html": {
    "href": "api/Tensor.Algorithm.LinAlg.html",
    "title": "Class LinAlg (mod) | Tensor for F#",
    "keywords": "Class LinAlg (mod) Linear algebra algorithms Inheritance LinAlg (mod) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax module LinAlg Methods Name Description val generalInverse: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Computes the generalized inverse I, solvability constraints S and null-space N of the specified matrix L. L can be of any shape and rank. The return values is a tuple (I, S, N). The following properties are fulfilled. Inverse: M .* I .* M = M. Solvability: S .* M = 0. Null-space: M .* N = 0. This has the following consequences for a linear equation system of the form y = M .* x: If y comes from the solvable space (i.e. S .* y = 0), then the value x = I .* y gives one solution of y = M .* x. Adding any linear combination of the columns of N to this x yields another solution, i.e. y = M .* x = M .* (x + N .* z) for any z. If x contains no component from the null-space (i.e. N^T .* x = 0), then we can recover x from y = M .* x by x = I .* y. (TODO: check last sentence, because it was violated in test1) val integerInverse: Tensor<bigint> -> Tensor<Rat> * Tensor<bigint> * Tensor<bigint> Computes the inverse I, solvability constraints S and null-space N of the specified integer matrix M, which can be of any shape and rank. The inversion is carried out over the domain of integers. The return values is a tuple (I, S, N), which fulfilles the following properties: Inverse: M .* I .* M = M. Solvability: S .* M = 0. Null-space: M .* N = 0. The equation system M .* x = y is solvable when S .* y = 0 and I .* y is an integer vector. In this case, the set of solutions is given by x = I .* y + N .* z where z is any integer vector. val rowEchelon: Tensor<'T> -> Tensor<'T> * int64 * int64 list Computes the reduced row echelon form of the specified matrix. Returns a tuple of (row echelon form, number of non-zero rows, list of non-normalized columns). val rowEchelonAugmented: Tensor<'T> -> Tensor<'T> -> Tensor<'T> * int64 * int64 list * Tensor<'T> Computes the reduced row echelon form of matrix L augmented with matrix A. Returns a tuple of (row echelon form, number of non-zero rows, list of non-normalized columns, transformed augmentation matrix). val smithNormalForm: Tensor<bigint> -> Tensor<bigint> * Tensor<bigint> * Tensor<bigint> Computes the Smith Normal Form S of integer matrix A and returns a tuple (U, S, V) so that S = U .* A .* V, where U and V are invertible matrices and S is a positive, diagonal matrix with the property that each element of the diagonal divides all of its successors."
  },
  "api/Tensor.Algorithm.BigIntegerExtensions.html": {
    "href": "api/Tensor.Algorithm.BigIntegerExtensions.html",
    "title": "Class BigIntegerExtensions (mod) | Tensor for F#",
    "keywords": "Class BigIntegerExtensions (mod) Extensions to System.Numerics.BigInteger. Inheritance BigIntegerExtensions (mod) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax [<AutoOpen>] module BigIntegerExtensions Methods Name Description extension System.Numerics.BigInteger.Bezout: bigint * bigint -> bigint * bigint * bigint Computes the GCD of a and b and the coefficients of Bezout's identity using the extended Euclidean algorithm. Returns a tuple of (gcd, x, y) so that: a x + b y = gcd(a,b). The returned GCD is always non-negative and gcd(0, 0)=0."
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemv.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemv.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * alpha:double * a:nativeint * lda:blas_int * x:nativeint * incx:blas_int * beta:double * y:nativeint * incy:blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE transA blas_int m blas_int n double alpha nativeint a blas_int lda nativeint x blas_int incx double beta nativeint y blas_int incy"
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemm_batch.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemm_batch.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE [] * transB:CBLAS_TRANSPOSE [] * m:blas_int [] * n:blas_int [] * k:blas_int [] * alpha:double [] * a:nativeint [] * lda:blas_int [] * b:nativeint [] * ldb:blas_int [] * beta:double [] * c:nativeint [] * ldc:blas_int [] * group_count:blas_int * group_size:blas_int [] -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE [] transA CBLAS_TRANSPOSE [] transB blas_int [] m blas_int [] n blas_int [] k double [] alpha nativeint [] a blas_int [] lda nativeint [] b blas_int [] ldb double [] beta nativeint [] c blas_int [] ldc blas_int group_count blas_int [] group_size"
  },
  "api/Tensor.Host.BLASModule.__cblas_dgemm.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_dgemm.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * transB:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * k:blas_int * alpha:double * a:nativeint * lda:blas_int * b:nativeint * ldb:blas_int * beta:double * c:nativeint * ldc:blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE transA CBLAS_TRANSPOSE transB blas_int m blas_int n blas_int k double alpha nativeint a blas_int lda nativeint b blas_int ldb double beta nativeint c blas_int ldc"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_getri.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_getri.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration abstract member Invoke: matrix_layout:int * n:lapack_int * a:nativeint * lda:lapack_int * ipiv:lapack_int [] -> lapack_int Parameters Type Name Description int matrix_layout lapack_int n nativeint a lapack_int lda lapack_int [] ipiv Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_getrf.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_getrf.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration abstract member Invoke: matrix_layout:int * m:lapack_int * n:lapack_int * a:nativeint * lda:lapack_int * ipiv:lapack_int [] -> lapack_int Parameters Type Name Description int matrix_layout lapack_int m lapack_int n nativeint a lapack_int lda lapack_int [] ipiv Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.-ctor.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: NativeLibName * NativeLibName -> Impl Implicit constructor. Declaration new: blasName:NativeLibName * lapackName:NativeLibName -> Impl Parameters Type Name Description Tensor.Utils.NativeLibName blasName Tensor.Utils.NativeLibName lapackName Returns Type Description Impl"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgeev.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgeev.html",
    "title": "Method LAPACKE_dgeev | Tensor for F#",
    "keywords": "Method LAPACKE_dgeev member LAPACKE_dgeev: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration member LAPACKE_dgeev: args:int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Parameters Type Name Description int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgesdd.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgesdd.html",
    "title": "Method LAPACKE_dgesdd | Tensor for F#",
    "keywords": "Method LAPACKE_dgesdd member LAPACKE_dgesdd: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration member LAPACKE_dgesdd: args:int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Parameters Type Name Description int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgetrf.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgetrf.html",
    "title": "Method LAPACKE_dgetrf | Tensor for F#",
    "keywords": "Method LAPACKE_dgetrf member LAPACKE_dgetrf: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration member LAPACKE_dgetrf: args:int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Parameters Type Name Description int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgetri.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_dgetri.html",
    "title": "Method LAPACKE_dgetri | Tensor for F#",
    "keywords": "Method LAPACKE_dgetri member LAPACKE_dgetri: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration member LAPACKE_dgetri: args:int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Parameters Type Name Description int * lapack_int * nativeint * lapack_int * lapack_int [] args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_dsyevd.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_dsyevd.html",
    "title": "Method LAPACKE_dsyevd | Tensor for F#",
    "keywords": "Method LAPACKE_dsyevd member LAPACKE_dsyevd: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int Declaration member LAPACKE_dsyevd: args:int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int Parameters Type Name Description int * char * char * lapack_int * nativeint * lapack_int * nativeint args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgeev.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgeev.html",
    "title": "Method LAPACKE_sgeev | Tensor for F#",
    "keywords": "Method LAPACKE_sgeev member LAPACKE_sgeev: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration member LAPACKE_sgeev: args:int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Parameters Type Name Description int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgesdd.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgesdd.html",
    "title": "Method LAPACKE_sgesdd | Tensor for F#",
    "keywords": "Method LAPACKE_sgesdd member LAPACKE_sgesdd: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration member LAPACKE_sgesdd: args:int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Parameters Type Name Description int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgetrf.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgetrf.html",
    "title": "Method LAPACKE_sgetrf | Tensor for F#",
    "keywords": "Method LAPACKE_sgetrf member LAPACKE_sgetrf: int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration member LAPACKE_sgetrf: args:int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Parameters Type Name Description int * lapack_int * lapack_int * nativeint * lapack_int * lapack_int [] args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgetri.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_sgetri.html",
    "title": "Method LAPACKE_sgetri | Tensor for F#",
    "keywords": "Method LAPACKE_sgetri member LAPACKE_sgetri: int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Declaration member LAPACKE_sgetri: args:int * lapack_int * nativeint * lapack_int * lapack_int [] -> lapack_int Parameters Type Name Description int * lapack_int * nativeint * lapack_int * lapack_int [] args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.LAPACKE_ssyevd.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.LAPACKE_ssyevd.html",
    "title": "Method LAPACKE_ssyevd | Tensor for F#",
    "keywords": "Method LAPACKE_ssyevd member LAPACKE_ssyevd: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int Declaration member LAPACKE_ssyevd: args:int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int Parameters Type Name Description int * char * char * lapack_int * nativeint * lapack_int * nativeint args Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_ddot.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_ddot.html",
    "title": "Method cblas_ddot | Tensor for F#",
    "keywords": "Method cblas_ddot member cblas_ddot: blas_int * nativeint * blas_int * nativeint * blas_int -> double Declaration member cblas_ddot: args:blas_int * nativeint * blas_int * nativeint * blas_int -> double Parameters Type Name Description blas_int * nativeint * blas_int * nativeint * blas_int args Returns Type Description double"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_dgemm.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_dgemm.html",
    "title": "Method cblas_dgemm | Tensor for F#",
    "keywords": "Method cblas_dgemm member cblas_dgemm: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Declaration member cblas_dgemm: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int args"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_dgemm_batch.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_dgemm_batch.html",
    "title": "Method cblas_dgemm_batch | Tensor for F#",
    "keywords": "Method cblas_dgemm_batch member cblas_dgemm_batch: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Declaration member cblas_dgemm_batch: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * double [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * double [] * nativeint [] * blas_int [] * blas_int * blas_int [] args"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_dgemv.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_dgemv.html",
    "title": "Method cblas_dgemv | Tensor for F#",
    "keywords": "Method cblas_dgemv member cblas_dgemv: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Declaration member cblas_dgemv: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * double * nativeint * blas_int * nativeint * blas_int * double * nativeint * blas_int args"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_sdot.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_sdot.html",
    "title": "Method cblas_sdot | Tensor for F#",
    "keywords": "Method cblas_sdot member cblas_sdot: blas_int * nativeint * blas_int * nativeint * blas_int -> single Declaration member cblas_sdot: args:blas_int * nativeint * blas_int * nativeint * blas_int -> single Parameters Type Name Description blas_int * nativeint * blas_int * nativeint * blas_int args Returns Type Description single"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_sgemm.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_sgemm.html",
    "title": "Method cblas_sgemm | Tensor for F#",
    "keywords": "Method cblas_sgemm member cblas_sgemm: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Declaration member cblas_sgemm: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int args"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_sgemm_batch.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_sgemm_batch.html",
    "title": "Method cblas_sgemm_batch | Tensor for F#",
    "keywords": "Method cblas_sgemm_batch member cblas_sgemm_batch: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Declaration member cblas_sgemm_batch: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] args"
  },
  "api/Tensor.Host.BLASModule.Impl.cblas_sgemv.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.cblas_sgemv.html",
    "title": "Method cblas_sgemv | Tensor for F#",
    "keywords": "Method cblas_sgemv member cblas_sgemv: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Declaration member cblas_sgemv: args:CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int args"
  },
  "api/Tensor.Host.BLASModule.Impl.Has_cblas_gemm_batch.html": {
    "href": "api/Tensor.Host.BLASModule.Impl.Has_cblas_gemm_batch.html",
    "title": "Property Has_cblas_gemm_batch | Tensor for F#",
    "keywords": "Property Has_cblas_gemm_batch property Has_cblas_gemm_batch: bool Declaration property Has_cblas_gemm_batch: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Cuda.ITensorCudaBackend.NativeTensor.html": {
    "href": "api/Tensor.Cuda.ITensorCudaBackend.NativeTensor.html",
    "title": "Property NativeTensor | Tensor for F#",
    "keywords": "Property NativeTensor abstract property NativeTensor: NativeTensor Declaration abstract property NativeTensor: NativeTensor with get Property Value Type Description NativeTensor"
  },
  "api/Tensor.Cuda.Cfg.Stream.html": {
    "href": "api/Tensor.Cuda.Cfg.Stream.html",
    "title": "Property Stream | Tensor for F#",
    "keywords": "Property Stream static property Stream: CUstream The CUDA stream to execute CUDA operations on. Declaration static property Stream: CUstream with get, set Property Value Type Description ManagedCuda.BasicTypes.CUstream Remarks This setting is local to the calling thread and defaults to the null stream."
  },
  "api/Tensor.Cuda.Cfg.Stacktrace.html": {
    "href": "api/Tensor.Cuda.Cfg.Stacktrace.html",
    "title": "Property Stacktrace | Tensor for F#",
    "keywords": "Property Stacktrace static property Stacktrace: bool If set to true, CUDA operations produce an acurate stack trace when an error is encountered. Declaration static property Stacktrace: bool with get, set Property Value Type Description bool Remarks Setting this to true affects performance, even if no error occurs. This setting is local to the calling thread and defaults to false ."
  },
  "api/Tensor.Cuda.Cfg.RestrictKernels.html": {
    "href": "api/Tensor.Cuda.Cfg.RestrictKernels.html",
    "title": "Property RestrictKernels | Tensor for F#",
    "keywords": "Property RestrictKernels static property RestrictKernels: bool If set to true, all arguments are passed as restriced to CUDA kernels (experimental). Declaration static property RestrictKernels: bool with get, set Property Value Type Description bool Remarks This setting is local to the calling thread and defaults to false ."
  },
  "api/Tensor.Cuda.Cfg.FastKernelMath.html": {
    "href": "api/Tensor.Cuda.Cfg.FastKernelMath.html",
    "title": "Property FastKernelMath | Tensor for F#",
    "keywords": "Property FastKernelMath static property FastKernelMath: bool If set to true, CUDA uses fast math functions with lower accuracy. Declaration static property FastKernelMath: bool with get, set Property Value Type Description bool Remarks This setting is local to the calling thread and defaults to false ."
  },
  "api/Tensor.Cuda.Cfg.DisableKernelCache.html": {
    "href": "api/Tensor.Cuda.Cfg.DisableKernelCache.html",
    "title": "Property DisableKernelCache | Tensor for F#",
    "keywords": "Property DisableKernelCache static property DisableKernelCache: bool If set to true, the CUDA kernel cache is disabled. Declaration static property DisableKernelCache: bool with get, set Property Value Type Description bool Remarks This setting is local to the calling thread and defaults to false ."
  },
  "api/Tensor.Cuda.Cfg.DebugCompile.html": {
    "href": "api/Tensor.Cuda.Cfg.DebugCompile.html",
    "title": "Property DebugCompile | Tensor for F#",
    "keywords": "Property DebugCompile static property DebugCompile: bool If set to true, all CUDA kernels are compiled with debug flags. Declaration static property DebugCompile: bool with get, set Property Value Type Description bool Remarks This setting is local to the calling thread and defaults to false ."
  },
  "api/Tensor.Cuda.CannotCudaRegisterMemoryException.Message.html": {
    "href": "api/Tensor.Cuda.CannotCudaRegisterMemoryException.Message.html",
    "title": "Property Message | Tensor for F#",
    "keywords": "Property Message override property Message: string Declaration override property Message: string with get Property Value Type Description string Overrides abstract property System.Exception.Message: string"
  },
  "api/Tensor.Cuda.CannotCudaRegisterMemoryException.msg.html": {
    "href": "api/Tensor.Cuda.CannotCudaRegisterMemoryException.msg.html",
    "title": "Field val msg: string | Tensor for F#",
    "keywords": "Field val msg: string Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val msg: string Returns Type Description string"
  },
  "api/Tensor.Backend.TensorLayoutModule.check.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.check.html",
    "title": "Method check | Tensor for F#",
    "keywords": "Method check val check: TensorLayout -> unit checks that the layout is valid Declaration val check: layout:TensorLayout -> unit Parameters Type Name Description TensorLayout layout"
  },
  "api/Tensor.Backend.TensorLayoutModule.checkIndex.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.checkIndex.html",
    "title": "Method checkIndex | Tensor for F#",
    "keywords": "Method checkIndex val checkIndex: int64 list -> int64 list -> unit checks that the given index is valid for the given shape Declaration val checkIndex: shp:int64 list -> idx:int64 list -> unit Parameters Type Name Description int64 list shp int64 list idx"
  },
  "api/Tensor.Backend.TensorLayoutModule.addr.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.addr.html",
    "title": "Method addr | Tensor for F#",
    "keywords": "Method addr val addr: int64 list -> TensorLayout -> int64 address of element Declaration val addr: idx:int64 list -> a:TensorLayout -> int64 Parameters Type Name Description int64 list idx TensorLayout a Returns Type Description int64"
  },
  "api/Tensor.Backend.TensorLayoutModule.shape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.shape.html",
    "title": "Method shape | Tensor for F#",
    "keywords": "Method shape val shape: TensorLayout -> int64 list shape Declaration val shape: a:TensorLayout -> int64 list Parameters Type Name Description TensorLayout a Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayoutModule.stride.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.stride.html",
    "title": "Method stride | Tensor for F#",
    "keywords": "Method stride val stride: TensorLayout -> int64 list stride Declaration val stride: a:TensorLayout -> int64 list Parameters Type Name Description TensorLayout a Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayoutModule.offset.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.offset.html",
    "title": "Method offset | Tensor for F#",
    "keywords": "Method offset val offset: TensorLayout -> int64 offset Declaration val offset: a:TensorLayout -> int64 Parameters Type Name Description TensorLayout a Returns Type Description int64"
  },
  "api/Tensor.Backend.TensorLayoutModule.nDims.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.nDims.html",
    "title": "Method nDims | Tensor for F#",
    "keywords": "Method nDims val nDims: TensorLayout -> int number of dimensions Declaration val nDims: a:TensorLayout -> int Parameters Type Name Description TensorLayout a Returns Type Description int"
  },
  "api/Tensor.Backend.TensorLayoutModule.nElems.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.nElems.html",
    "title": "Method nElems | Tensor for F#",
    "keywords": "Method nElems val nElems: TensorLayout -> int64 number of elements Declaration val nElems: a:TensorLayout -> int64 Parameters Type Name Description TensorLayout a Returns Type Description int64"
  },
  "api/Tensor.Backend.TensorLayoutModule.checkAxis.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.checkAxis.html",
    "title": "Method checkAxis | Tensor for F#",
    "keywords": "Method checkAxis val checkAxis: int -> TensorLayout -> unit checks that the given axis is valid Declaration val checkAxis: ax:int -> a:TensorLayout -> unit Parameters Type Name Description int ax TensorLayout a"
  },
  "api/Tensor.Backend.TensorLayoutModule.allIdxOfShape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.allIdxOfShape.html",
    "title": "Method allIdxOfShape | Tensor for F#",
    "keywords": "Method allIdxOfShape val allIdxOfShape: int64 list -> seq<int64 list> a sequence of indicies enumerating all elements of the array with the given shape Declaration val allIdxOfShape: shp:int64 list -> seq<int64 list> Parameters Type Name Description int64 list shp Returns Type Description seq < int64 list >"
  },
  "api/Tensor.Backend.TensorLayoutModule.allIdx.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.allIdx.html",
    "title": "Method allIdx | Tensor for F#",
    "keywords": "Method allIdx val allIdx: TensorLayout -> seq<int64 list> sequence of all indices Declaration val allIdx: a:TensorLayout -> seq<int64 list> Parameters Type Name Description TensorLayout a Returns Type Description seq < int64 list >"
  },
  "api/Tensor.Backend.TensorLayoutModule.allIdxOfDim.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.allIdxOfDim.html",
    "title": "Method allIdxOfDim | Tensor for F#",
    "keywords": "Method allIdxOfDim val allIdxOfDim: int -> TensorLayout -> seq<int64> all indices of the given dimension Declaration val allIdxOfDim: dim:int -> a:TensorLayout -> seq<int64> Parameters Type Name Description int dim TensorLayout a Returns Type Description seq < int64 >"
  },
  "api/Tensor.Backend.TensorLayoutModule.orderedStride.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.orderedStride.html",
    "title": "Method orderedStride | Tensor for F#",
    "keywords": "Method orderedStride val orderedStride: int64 list -> int list -> int64 list Computes the strides for the given shape using the specified ordering. The axis that is first in the ordering gets stride 1. The resulting strides will be independent of the shape of the axis that appears last in the ordering. A C-order stride corresponds to the ordering: [n; n-1; ...; 2; 1; 0]. A Fortran-order stride corresponds to the ordering: [0; 1; 2; ...; n-1; n]. Declaration val orderedStride: shape:int64 list -> order:int list -> int64 list Parameters Type Name Description int64 list shape int list order Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayoutModule.cStride.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.cStride.html",
    "title": "Method cStride | Tensor for F#",
    "keywords": "Method cStride val cStride: int64 list -> int64 list computes the stride given the shape for the ArrayND to be in C-order (row-major) Declaration val cStride: shape:int64 list -> int64 list Parameters Type Name Description int64 list shape Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayoutModule.fStride.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.fStride.html",
    "title": "Method fStride | Tensor for F#",
    "keywords": "Method fStride val fStride: int64 list -> int64 list computes the stride given the shape for the ArrayND to be in Fortran-order (column-major) Declaration val fStride: shape:int64 list -> int64 list Parameters Type Name Description int64 list shape Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayoutModule.newOrdered.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.newOrdered.html",
    "title": "Method newOrdered | Tensor for F#",
    "keywords": "Method newOrdered val newOrdered: int64 list -> int list -> TensorLayout a ArrayND layout of the given shape and stride order Declaration val newOrdered: shp:int64 list -> strideOrder:int list -> TensorLayout Parameters Type Name Description int64 list shp int list strideOrder Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.newC.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.newC.html",
    "title": "Method newC | Tensor for F#",
    "keywords": "Method newC val newC: int64 list -> TensorLayout a C-order (row-major) ArrayND layout of the given shape Declaration val newC: shp:int64 list -> TensorLayout Parameters Type Name Description int64 list shp Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.newF.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.newF.html",
    "title": "Method newF | Tensor for F#",
    "keywords": "Method newF val newF: int64 list -> TensorLayout a Fortran-order (column-major) ArrayND layout of the given shape Declaration val newF: shp:int64 list -> TensorLayout Parameters Type Name Description int64 list shp Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.emptyVector().html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.emptyVector().html",
    "title": "Field val emptyVector | Tensor for F#",
    "keywords": "Field val emptyVector an ArrayND layout for an empty (zero elements) vector (1D) Namespace : Tensor.Backend Assembly : Tensor.dll Syntax val emptyVector: TensorLayout Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.stridesEqual.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.stridesEqual.html",
    "title": "Method stridesEqual | Tensor for F#",
    "keywords": "Method stridesEqual val stridesEqual: int64 list -> int64 list -> int64 list -> bool True if strides are equal at all dimensions with size > 1. Declaration val stridesEqual: shp:int64 list -> aStr:int64 list -> bStr:int64 list -> bool Parameters Type Name Description int64 list shp int64 list aStr int64 list bStr Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.isC.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.isC.html",
    "title": "Method isC | Tensor for F#",
    "keywords": "Method isC val isC: TensorLayout -> bool true if the ArrayND is contiguous Declaration val isC: a:TensorLayout -> bool Parameters Type Name Description TensorLayout a Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.isF.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.isF.html",
    "title": "Method isF | Tensor for F#",
    "keywords": "Method isF val isF: TensorLayout -> bool true if the ArrayND is in Fortran order Declaration val isF: a:TensorLayout -> bool Parameters Type Name Description TensorLayout a Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.hasContiguousMemory.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.hasContiguousMemory.html",
    "title": "Method hasContiguousMemory | Tensor for F#",
    "keywords": "Method hasContiguousMemory val hasContiguousMemory: TensorLayout -> bool true if the memory of the ArrayND is a contiguous block Declaration val hasContiguousMemory: a:TensorLayout -> bool Parameters Type Name Description TensorLayout a Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.padLeft.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.padLeft.html",
    "title": "Method padLeft | Tensor for F#",
    "keywords": "Method padLeft val padLeft: TensorLayout -> TensorLayout adds a new dimension of size one to the left Declaration val padLeft: a:TensorLayout -> TensorLayout Parameters Type Name Description TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.padRight.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.padRight.html",
    "title": "Method padRight | Tensor for F#",
    "keywords": "Method padRight val padRight: TensorLayout -> TensorLayout adds a new dimension of size one to the right Declaration val padRight: a:TensorLayout -> TensorLayout Parameters Type Name Description TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.insertAxis.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.insertAxis.html",
    "title": "Method insertAxis | Tensor for F#",
    "keywords": "Method insertAxis val insertAxis: int -> TensorLayout -> TensorLayout Inserts an axis of size 1 before the specified position. Declaration val insertAxis: ax:int -> a:TensorLayout -> TensorLayout Parameters Type Name Description int ax TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.cutLeft.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.cutLeft.html",
    "title": "Method cutLeft | Tensor for F#",
    "keywords": "Method cutLeft val cutLeft: TensorLayout -> TensorLayout cuts one dimension from the left Declaration val cutLeft: a:TensorLayout -> TensorLayout Parameters Type Name Description TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.cutRight.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.cutRight.html",
    "title": "Method cutRight | Tensor for F#",
    "keywords": "Method cutRight val cutRight: TensorLayout -> TensorLayout cuts one dimension from the right Declaration val cutRight: a:TensorLayout -> TensorLayout Parameters Type Name Description TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastDim.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastDim.html",
    "title": "Method broadcastDim | Tensor for F#",
    "keywords": "Method broadcastDim val broadcastDim: int -> int64 -> TensorLayout -> TensorLayout broadcast the given dimension to the given size Declaration val broadcastDim: dim:int -> size:int64 -> a:TensorLayout -> TensorLayout Parameters Type Name Description int dim int64 size TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.padToSame.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.padToSame.html",
    "title": "Method padToSame | Tensor for F#",
    "keywords": "Method padToSame val padToSame: TensorLayout -> TensorLayout -> TensorLayout * TensorLayout pads shapes from the left until they have same rank Declaration val padToSame: a:TensorLayout -> b:TensorLayout -> TensorLayout * TensorLayout Parameters Type Name Description TensorLayout a TensorLayout b Returns Type Description TensorLayout * TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.padToSameMany.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.padToSameMany.html",
    "title": "Method padToSameMany | Tensor for F#",
    "keywords": "Method padToSameMany val padToSameMany: TensorLayout list -> TensorLayout list pads shapes from the left until they have same rank Declaration val padToSameMany: sas:TensorLayout list -> TensorLayout list Parameters Type Name Description TensorLayout list sas Returns Type Description TensorLayout list"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastToSameInDims.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastToSameInDims.html",
    "title": "Method broadcastToSameInDims | Tensor for F#",
    "keywords": "Method broadcastToSameInDims val broadcastToSameInDims: seq<int> -> TensorLayout -> TensorLayout -> TensorLayout * TensorLayout broadcasts to have the same size in the given dimensions Declaration val broadcastToSameInDims: dims:seq<int> -> ain:TensorLayout -> bin:TensorLayout -> TensorLayout * TensorLayout Parameters Type Name Description seq < int > dims TensorLayout ain TensorLayout bin Returns Type Description TensorLayout * TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastToSameInDimsMany.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastToSameInDimsMany.html",
    "title": "Method broadcastToSameInDimsMany | Tensor for F#",
    "keywords": "Method broadcastToSameInDimsMany val broadcastToSameInDimsMany: seq<int> -> TensorLayout list -> TensorLayout list broadcasts to have the same size in the given dimensions Declaration val broadcastToSameInDimsMany: dims:seq<int> -> sas:TensorLayout list -> TensorLayout list Parameters Type Name Description seq < int > dims TensorLayout list sas Returns Type Description TensorLayout list"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastToSame.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastToSame.html",
    "title": "Method broadcastToSame | Tensor for F#",
    "keywords": "Method broadcastToSame val broadcastToSame: TensorLayout -> TensorLayout -> TensorLayout * TensorLayout broadcasts to have the same size Declaration val broadcastToSame: ain:TensorLayout -> bin:TensorLayout -> TensorLayout * TensorLayout Parameters Type Name Description TensorLayout ain TensorLayout bin Returns Type Description TensorLayout * TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastToSameMany.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastToSameMany.html",
    "title": "Method broadcastToSameMany | Tensor for F#",
    "keywords": "Method broadcastToSameMany val broadcastToSameMany: TensorLayout list -> TensorLayout list broadcasts to have the same size Declaration val broadcastToSameMany: sas:TensorLayout list -> TensorLayout list Parameters Type Name Description TensorLayout list sas Returns Type Description TensorLayout list"
  },
  "api/Tensor.Backend.TensorLayoutModule.broadcastToShape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.broadcastToShape.html",
    "title": "Method broadcastToShape | Tensor for F#",
    "keywords": "Method broadcastToShape val broadcastToShape: int64 list -> TensorLayout -> TensorLayout broadcasts a tensor to the given shape Declaration val broadcastToShape: bs:int64 list -> ain:TensorLayout -> TensorLayout Parameters Type Name Description int64 list bs TensorLayout ain Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.isBroadcasted.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.isBroadcasted.html",
    "title": "Method isBroadcasted | Tensor for F#",
    "keywords": "Method isBroadcasted val isBroadcasted: TensorLayout -> bool returns true if at least one dimension is broadcasted Declaration val isBroadcasted: a:TensorLayout -> bool Parameters Type Name Description TensorLayout a Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.tryReshape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.tryReshape.html",
    "title": "Method tryReshape | Tensor for F#",
    "keywords": "Method tryReshape val tryReshape: int64 list -> TensorLayout -> TensorLayout option Reshape layout under the assumption that it is contiguous. The number of elements must not change. Returns Some newLayout when reshape is possible without copy Returns None when a copy is required. Declaration val tryReshape: shp:int64 list -> a:TensorLayout -> TensorLayout option Parameters Type Name Description int64 list shp TensorLayout a Returns Type Description TensorLayout option"
  },
  "api/Tensor.Backend.TensorLayoutModule.canReshape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.canReshape.html",
    "title": "Method canReshape | Tensor for F#",
    "keywords": "Method canReshape val canReshape: int64 list -> TensorLayout -> bool Returns true if a can be reshaped into shp without copying. The number of elements must not change. Declaration val canReshape: shp:int64 list -> a:TensorLayout -> bool Parameters Type Name Description int64 list shp TensorLayout a Returns Type Description bool"
  },
  "api/Tensor.Backend.TensorLayoutModule.reshape.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.reshape.html",
    "title": "Method reshape | Tensor for F#",
    "keywords": "Method reshape val reshape: int64 list -> TensorLayout -> TensorLayout Reshape layout under the assumption that it is contiguous. The number of elements must not change. An error is raised, if reshape is impossible without copying. Declaration val reshape: shp:int64 list -> a:TensorLayout -> TensorLayout Parameters Type Name Description int64 list shp TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.swapDim.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.swapDim.html",
    "title": "Method swapDim | Tensor for F#",
    "keywords": "Method swapDim val swapDim: int -> int -> TensorLayout -> TensorLayout swaps the given dimensions Declaration val swapDim: ax1:int -> ax2:int -> a:TensorLayout -> TensorLayout Parameters Type Name Description int ax1 int ax2 TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.transpose.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.transpose.html",
    "title": "Method transpose | Tensor for F#",
    "keywords": "Method transpose val transpose: TensorLayout -> TensorLayout Transposes the given layout of a matrix. If the array has more then two dimensions, the last two axes are swapped. Declaration val transpose: a:TensorLayout -> TensorLayout Parameters Type Name Description TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.permuteAxes.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.permuteAxes.html",
    "title": "Method permuteAxes | Tensor for F#",
    "keywords": "Method permuteAxes val permuteAxes: int list -> TensorLayout -> TensorLayout Permutes the axes as specified. Each entry in the specified permutation specifies the new position of the corresponding axis, i.e. to which position the axis should move. Declaration val permuteAxes: permut:int list -> a:TensorLayout -> TensorLayout Parameters Type Name Description int list permut TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.reverseAxis.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.reverseAxis.html",
    "title": "Method reverseAxis | Tensor for F#",
    "keywords": "Method reverseAxis val reverseAxis: int -> TensorLayout -> TensorLayout Reverses the elements in the specified dimension. Declaration val reverseAxis: ax:int -> a:TensorLayout -> TensorLayout Parameters Type Name Description int ax TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.view.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.view.html",
    "title": "Method view | Tensor for F#",
    "keywords": "Method view val view: Rng list -> TensorLayout -> TensorLayout creates a subview layout Declaration val view: ranges:Rng list -> a:TensorLayout -> TensorLayout Parameters Type Name Description Rng list ranges TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.allSrcRngsAndTrgtIdxsForAxisReduce.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.allSrcRngsAndTrgtIdxsForAxisReduce.html",
    "title": "Method allSrcRngsAndTrgtIdxsForAxisReduce | Tensor for F#",
    "keywords": "Method allSrcRngsAndTrgtIdxsForAxisReduce val allSrcRngsAndTrgtIdxsForAxisReduce: int -> TensorLayout -> seq<Rng list * int64 list> Declaration val allSrcRngsAndTrgtIdxsForAxisReduce: dim:int -> a:TensorLayout -> seq<Rng list * int64 list> Parameters Type Name Description int dim TensorLayout a Returns Type Description seq < Rng list * int64 list >"
  },
  "api/Tensor.Backend.TensorLayoutModule.diagAxis.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.diagAxis.html",
    "title": "Method diagAxis | Tensor for F#",
    "keywords": "Method diagAxis val diagAxis: int -> int -> TensorLayout -> TensorLayout Creates a layout that extracts the diagonal along the given axes. The first axis is replaced with the diagonal and the second axis is removed. Declaration val diagAxis: ax1:int -> ax2:int -> a:TensorLayout -> TensorLayout Parameters Type Name Description int ax1 int ax2 TensorLayout a Returns Type Description TensorLayout"
  },
  "api/Tensor.Backend.TensorLayoutModule.idxToLinear.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.idxToLinear.html",
    "title": "Method idxToLinear | Tensor for F#",
    "keywords": "Method idxToLinear val idxToLinear: TensorLayout -> int64 list -> int64 Computes the linear index of a given index. Linear indexing is performed in row-major order. Declaration val idxToLinear: a:TensorLayout -> idx:int64 list -> int64 Parameters Type Name Description TensorLayout a int64 list idx Returns Type Description int64"
  },
  "api/Tensor.Backend.TensorLayoutModule.linearToIdx.html": {
    "href": "api/Tensor.Backend.TensorLayoutModule.linearToIdx.html",
    "title": "Method linearToIdx | Tensor for F#",
    "keywords": "Method linearToIdx val linearToIdx: TensorLayout -> int64 -> int64 list Computes the index of a given linear index. Declaration val linearToIdx: a:TensorLayout -> linear:int64 -> int64 list Parameters Type Name Description TensorLayout a int64 linear Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayout.NElems.html": {
    "href": "api/Tensor.Backend.TensorLayout.NElems.html",
    "title": "Property NElems | Tensor for F#",
    "keywords": "Property NElems property NElems: int64 Number of elements. Declaration property NElems: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Backend.TensorLayout.NDims.html": {
    "href": "api/Tensor.Backend.TensorLayout.NDims.html",
    "title": "Property NDims | Tensor for F#",
    "keywords": "Property NDims property NDims: int Number of dimensions. Declaration property NDims: int with get Property Value Type Description int"
  },
  "api/Tensor.Backend.TensorLayout.Shape.html": {
    "href": "api/Tensor.Backend.TensorLayout.Shape.html",
    "title": "Field val Shape: int64 list | Tensor for F#",
    "keywords": "Field val Shape: int64 list Shape. Namespace : Tensor.Backend Assembly : Tensor.dll Syntax val Shape: int64 list Returns Type Description int64 list"
  },
  "api/Tensor.Backend.TensorLayout.Offset.html": {
    "href": "api/Tensor.Backend.TensorLayout.Offset.html",
    "title": "Field val Offset: int64 | Tensor for F#",
    "keywords": "Field val Offset: int64 Offset (to first element) in elements. Namespace : Tensor.Backend Assembly : Tensor.dll Syntax val Offset: int64 Returns Type Description int64"
  },
  "api/Tensor.Backend.TensorLayout.Stride.html": {
    "href": "api/Tensor.Backend.TensorLayout.Stride.html",
    "title": "Field val Stride: int64 list | Tensor for F#",
    "keywords": "Field val Stride: int64 list Stride in elements. Namespace : Tensor.Backend Assembly : Tensor.dll Syntax val Stride: int64 list Returns Type Description int64 list"
  },
  "api/Tensor.Backend.ITensorStorage.Dev.html": {
    "href": "api/Tensor.Backend.ITensorStorage.Dev.html",
    "title": "Property Dev | Tensor for F#",
    "keywords": "Property Dev abstract property Dev: ITensorDevice Declaration abstract property Dev: ITensorDevice with get Property Value Type Description ITensorDevice"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Copy.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Copy.html",
    "title": "Method Copy | Tensor for F#",
    "keywords": "Method Copy abstract member Copy: TensorOrder option -> ITensorFrontend<'T> returns a copy of the tensor Declaration abstract member Copy: order:TensorOrder option -> ITensorFrontend<'T> Parameters Type Name Description TensorOrder option order Returns Type Description ITensorFrontend <'T>"
  },
  "api/Tensor.Backend.ITensorFrontend-1.CopyFrom.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.CopyFrom.html",
    "title": "Method CopyFrom | Tensor for F#",
    "keywords": "Method CopyFrom abstract member CopyFrom: ITensorFrontend<'T> -> unit Copies the specifed tensor into this tensor. Declaration abstract member CopyFrom: src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Relayout.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Relayout.html",
    "title": "Method Relayout | Tensor for F#",
    "keywords": "Method Relayout abstract member Relayout: TensorLayout -> ITensorFrontend<'T> a tensor with the same storage but new layout Declaration abstract member Relayout: layout:TensorLayout -> ITensorFrontend<'T> Parameters Type Name Description TensorLayout layout Returns Type Description ITensorFrontend <'T>"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Transfer.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Transfer.html",
    "title": "Method Transfer | Tensor for F#",
    "keywords": "Method Transfer abstract member Transfer: ITensorDevice -> ITensorFrontend<'T> Transfers this tensor to the specifed device. Declaration abstract member Transfer: dev:ITensorDevice -> ITensorFrontend<'T> Parameters Type Name Description ITensorDevice dev Returns Type Description ITensorFrontend <'T>"
  },
  "api/Tensor.Backend.ITensorFrontend-1.T.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.T.html",
    "title": "Property T | Tensor for F#",
    "keywords": "Property T abstract property T: ITensorFrontend<'T> Transpose Declaration abstract property T: ITensorFrontend<'T> with get Property Value Type Description ITensorFrontend <'T>"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Stride.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Stride.html",
    "title": "Property Stride | Tensor for F#",
    "keywords": "Property Stride abstract property Stride: int64 list stride Declaration abstract property Stride: int64 list with get Property Value Type Description int64 list"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Storage.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Storage.html",
    "title": "Property Storage | Tensor for F#",
    "keywords": "Property Storage abstract property Storage: ITensorStorage<'T> storage of this tensor Declaration abstract property Storage: ITensorStorage<'T> with get Property Value Type Description ITensorStorage <'T>"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Shape.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Shape.html",
    "title": "Property Shape | Tensor for F#",
    "keywords": "Property Shape abstract property Shape: int64 list shape Declaration abstract property Shape: int64 list with get Property Value Type Description int64 list"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Offset.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Offset.html",
    "title": "Property Offset | Tensor for F#",
    "keywords": "Property Offset abstract property Offset: int64 stride Declaration abstract property Offset: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Backend.ITensorFrontend-1.NElems.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.NElems.html",
    "title": "Property NElems | Tensor for F#",
    "keywords": "Property NElems abstract property NElems: int64 number of elements Declaration abstract property NElems: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Backend.ITensorFrontend-1.NDims.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.NDims.html",
    "title": "Property NDims | Tensor for F#",
    "keywords": "Property NDims abstract property NDims: int number of dimensions Declaration abstract property NDims: int with get Property Value Type Description int"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Layout.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Layout.html",
    "title": "Property Layout | Tensor for F#",
    "keywords": "Property Layout abstract property Layout: TensorLayout layout of this tensor (shape, offset and strides) Declaration abstract property Layout: TensorLayout with get Property Value Type Description TensorLayout"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Dev.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Dev.html",
    "title": "Property Dev | Tensor for F#",
    "keywords": "Property Dev abstract property Dev: ITensorDevice storage factory Declaration abstract property Dev: ITensorDevice with get Property Value Type Description ITensorDevice"
  },
  "api/Tensor.Backend.ITensorFrontend-1.Backend.html": {
    "href": "api/Tensor.Backend.ITensorFrontend-1.Backend.html",
    "title": "Property Backend | Tensor for F#",
    "keywords": "Property Backend abstract property Backend: ITensorBackend<'T> the backend Declaration abstract property Backend: ITensorBackend<'T> with get Property Value Type Description ITensorBackend <'T>"
  },
  "api/Tensor.Backend.ITensorBackend-1.Abs.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Abs.html",
    "title": "Method Abs | Tensor for F#",
    "keywords": "Method Abs abstract member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Abs: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Acos.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Acos.html",
    "title": "Method Acos | Tensor for F#",
    "keywords": "Method Acos abstract member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Acos: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Add.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Add.html",
    "title": "Method Add | Tensor for F#",
    "keywords": "Method Add abstract member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Add: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.AllLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.AllLastAxis.html",
    "title": "Method AllLastAxis | Tensor for F#",
    "keywords": "Method AllLastAxis abstract member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member AllLastAxis: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.And.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.And.html",
    "title": "Method And | Tensor for F#",
    "keywords": "Method And abstract member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member And: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.AnyLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.AnyLastAxis.html",
    "title": "Method AnyLastAxis | Tensor for F#",
    "keywords": "Method AnyLastAxis abstract member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member AnyLastAxis: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.ArgMaxLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.ArgMaxLastAxis.html",
    "title": "Method ArgMaxLastAxis | Tensor for F#",
    "keywords": "Method ArgMaxLastAxis abstract member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration abstract member ArgMaxLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.ArgMinLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.ArgMinLastAxis.html",
    "title": "Method ArgMinLastAxis | Tensor for F#",
    "keywords": "Method ArgMinLastAxis abstract member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration abstract member ArgMinLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Asin.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Asin.html",
    "title": "Method Asin | Tensor for F#",
    "keywords": "Method Asin abstract member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Asin: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Atan.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Atan.html",
    "title": "Method Atan | Tensor for F#",
    "keywords": "Method Atan abstract member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Atan: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.BatchedInvert.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.BatchedInvert.html",
    "title": "Method BatchedInvert | Tensor for F#",
    "keywords": "Method BatchedInvert abstract member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member BatchedInvert: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.BatchedMatMatDot.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.BatchedMatMatDot.html",
    "title": "Method BatchedMatMatDot | Tensor for F#",
    "keywords": "Method BatchedMatMatDot abstract member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member BatchedMatMatDot: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.BatchedSVD.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.BatchedSVD.html",
    "title": "Method BatchedSVD | Tensor for F#",
    "keywords": "Method BatchedSVD abstract member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit Declaration abstract member BatchedSVD: trgtS:ITensorFrontend<'T> * trgtUV:ITensorFrontend<'T> * ITensorFrontend<'T> option * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgtS ITensorFrontend <'T> * ITensorFrontend <'T> option trgtUV ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Ceiling.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Ceiling.html",
    "title": "Method Ceiling | Tensor for F#",
    "keywords": "Method Ceiling abstract member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Ceiling: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Convert.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Convert.html",
    "title": "Method Convert | Tensor for F#",
    "keywords": "Method Convert abstract member Convert: ITensorFrontend<'T> * ITensorFrontend<'T1> -> unit Declaration abstract member Convert: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T1> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T1> src Type Parameters Name Description 'T1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Copy.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Copy.html",
    "title": "Method Copy | Tensor for F#",
    "keywords": "Method Copy abstract member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Copy: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorBackend-1.Cos.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Cos.html",
    "title": "Method Cos | Tensor for F#",
    "keywords": "Method Cos abstract member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Cos: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Cosh.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Cosh.html",
    "title": "Method Cosh | Tensor for F#",
    "keywords": "Method Cosh abstract member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Cosh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.CountTrueLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.CountTrueLastAxis.html",
    "title": "Method CountTrueLastAxis | Tensor for F#",
    "keywords": "Method CountTrueLastAxis abstract member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration abstract member CountTrueLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Divide.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Divide.html",
    "title": "Method Divide | Tensor for F#",
    "keywords": "Method Divide abstract member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Divide: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Equal.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Equal.html",
    "title": "Method Equal | Tensor for F#",
    "keywords": "Method Equal abstract member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Equal: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Exp.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Exp.html",
    "title": "Method Exp | Tensor for F#",
    "keywords": "Method Exp abstract member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Exp: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.FillConst.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.FillConst.html",
    "title": "Method FillConst | Tensor for F#",
    "keywords": "Method FillConst abstract member FillConst: 'T * ITensorFrontend<'T> -> unit Declaration abstract member FillConst: value:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend <'T> trgt"
  },
  "api/Tensor.Backend.ITensorBackend-1.FillIncrementing.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.FillIncrementing.html",
    "title": "Method FillIncrementing | Tensor for F#",
    "keywords": "Method FillIncrementing abstract member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit Declaration abstract member FillIncrementing: start:'T * incr:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T start 'T incr ITensorFrontend <'T> trgt"
  },
  "api/Tensor.Backend.ITensorBackend-1.FindLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.FindLastAxis.html",
    "title": "Method FindLastAxis | Tensor for F#",
    "keywords": "Method FindLastAxis abstract member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration abstract member FindLastAxis: value:'T * trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Floor.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Floor.html",
    "title": "Method Floor | Tensor for F#",
    "keywords": "Method Floor abstract member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Floor: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Gather.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Gather.html",
    "title": "Method Gather | Tensor for F#",
    "keywords": "Method Gather abstract member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration abstract member Gather: trgt:ITensorFrontend<'T> * srcIdxs:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list srcIdxs ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorBackend-1.Greater.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Greater.html",
    "title": "Method Greater | Tensor for F#",
    "keywords": "Method Greater abstract member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Greater: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.GreaterOrEqual.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.GreaterOrEqual.html",
    "title": "Method GreaterOrEqual | Tensor for F#",
    "keywords": "Method GreaterOrEqual abstract member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member GreaterOrEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.IfThenElse.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.IfThenElse.html",
    "title": "Method IfThenElse | Tensor for F#",
    "keywords": "Method IfThenElse abstract member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member IfThenElse: trgt:ITensorFrontend<'T> * cond:ITensorFrontend<bool> * ifTrue:ITensorFrontend<'T> * ifFalse:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > cond ITensorFrontend <'T> ifTrue ITensorFrontend <'T> ifFalse"
  },
  "api/Tensor.Backend.ITensorBackend-1.IsFinite.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.IsFinite.html",
    "title": "Method IsFinite | Tensor for F#",
    "keywords": "Method IsFinite abstract member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit Declaration abstract member IsFinite: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Less.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Less.html",
    "title": "Method Less | Tensor for F#",
    "keywords": "Method Less abstract member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Less: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.LessOrEqual.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.LessOrEqual.html",
    "title": "Method LessOrEqual | Tensor for F#",
    "keywords": "Method LessOrEqual abstract member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member LessOrEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Log.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Log.html",
    "title": "Method Log | Tensor for F#",
    "keywords": "Method Log abstract member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Log: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Log10.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Log10.html",
    "title": "Method Log10 | Tensor for F#",
    "keywords": "Method Log10 abstract member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Log10: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.MaskedGet.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MaskedGet.html",
    "title": "Method MaskedGet | Tensor for F#",
    "keywords": "Method MaskedGet abstract member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit Declaration abstract member MaskedGet: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> * masks:ITensorFrontend<bool> option [] -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src ITensorFrontend < bool > option [] masks"
  },
  "api/Tensor.Backend.ITensorBackend-1.MaskedSet.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MaskedSet.html",
    "title": "Method MaskedSet | Tensor for F#",
    "keywords": "Method MaskedSet abstract member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit Declaration abstract member MaskedSet: trgt:ITensorFrontend<'T> * masks:ITensorFrontend<bool> option [] * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > option [] masks ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorBackend-1.MatMatDot.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MatMatDot.html",
    "title": "Method MatMatDot | Tensor for F#",
    "keywords": "Method MatMatDot abstract member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MatMatDot: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.MatVecDot.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MatVecDot.html",
    "title": "Method MatVecDot | Tensor for F#",
    "keywords": "Method MatVecDot abstract member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MatVecDot: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.MaxElemwise.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MaxElemwise.html",
    "title": "Method MaxElemwise | Tensor for F#",
    "keywords": "Method MaxElemwise abstract member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MaxElemwise: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.MaxLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MaxLastAxis.html",
    "title": "Method MaxLastAxis | Tensor for F#",
    "keywords": "Method MaxLastAxis abstract member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MaxLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.MinElemwise.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MinElemwise.html",
    "title": "Method MinElemwise | Tensor for F#",
    "keywords": "Method MinElemwise abstract member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MinElemwise: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.MinLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.MinLastAxis.html",
    "title": "Method MinLastAxis | Tensor for F#",
    "keywords": "Method MinLastAxis abstract member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member MinLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Modulo.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Modulo.html",
    "title": "Method Modulo | Tensor for F#",
    "keywords": "Method Modulo abstract member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Modulo: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Multiply.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Multiply.html",
    "title": "Method Multiply | Tensor for F#",
    "keywords": "Method Multiply abstract member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Multiply: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Negate.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Negate.html",
    "title": "Method Negate | Tensor for F#",
    "keywords": "Method Negate abstract member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member Negate: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.NotEqual.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.NotEqual.html",
    "title": "Method NotEqual | Tensor for F#",
    "keywords": "Method NotEqual abstract member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member NotEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Or.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Or.html",
    "title": "Method Or | Tensor for F#",
    "keywords": "Method Or abstract member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member Or: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Power.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Power.html",
    "title": "Method Power | Tensor for F#",
    "keywords": "Method Power abstract member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Power: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.ProductLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.ProductLastAxis.html",
    "title": "Method ProductLastAxis | Tensor for F#",
    "keywords": "Method ProductLastAxis abstract member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member ProductLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Round.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Round.html",
    "title": "Method Round | Tensor for F#",
    "keywords": "Method Round abstract member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Round: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Scatter.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Scatter.html",
    "title": "Method Scatter | Tensor for F#",
    "keywords": "Method Scatter abstract member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration abstract member Scatter: trgt:ITensorFrontend<'T> * trgtIdxs:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list trgtIdxs ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorBackend-1.Sgn.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Sgn.html",
    "title": "Method Sgn | Tensor for F#",
    "keywords": "Method Sgn abstract member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Sgn: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Sin.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Sin.html",
    "title": "Method Sin | Tensor for F#",
    "keywords": "Method Sin abstract member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Sin: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Sinh.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Sinh.html",
    "title": "Method Sinh | Tensor for F#",
    "keywords": "Method Sinh abstract member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Sinh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Sqrt.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Sqrt.html",
    "title": "Method Sqrt | Tensor for F#",
    "keywords": "Method Sqrt abstract member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Sqrt: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Subtract.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Subtract.html",
    "title": "Method Subtract | Tensor for F#",
    "keywords": "Method Subtract abstract member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Subtract: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.SumLastAxis.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.SumLastAxis.html",
    "title": "Method SumLastAxis | Tensor for F#",
    "keywords": "Method SumLastAxis abstract member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member SumLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.SymmetricEigenDecomposition.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.SymmetricEigenDecomposition.html",
    "title": "Method SymmetricEigenDecomposition | Tensor for F#",
    "keywords": "Method SymmetricEigenDecomposition abstract member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member SymmetricEigenDecomposition: part:MatrixPart * trgtEigVals:ITensorFrontend<'T> * trgtEigVecs:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description MatrixPart part ITensorFrontend <'T> trgtEigVals ITensorFrontend <'T> trgtEigVecs ITensorFrontend <'T> src"
  },
  "api/Tensor.Backend.ITensorBackend-1.Tan.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Tan.html",
    "title": "Method Tan | Tensor for F#",
    "keywords": "Method Tan abstract member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Tan: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Tanh.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Tanh.html",
    "title": "Method Tanh | Tensor for F#",
    "keywords": "Method Tanh abstract member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Tanh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Transfer.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Transfer.html",
    "title": "Method Transfer | Tensor for F#",
    "keywords": "Method Transfer abstract member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool Declaration abstract member Transfer: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> bool Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Returns Type Description bool"
  },
  "api/Tensor.Backend.ITensorBackend-1.TrueIndices.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.TrueIndices.html",
    "title": "Method TrueIndices | Tensor for F#",
    "keywords": "Method TrueIndices abstract member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration abstract member TrueIndices: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.Truncate.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Truncate.html",
    "title": "Method Truncate | Tensor for F#",
    "keywords": "Method Truncate abstract member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member Truncate: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.UnaryMinus.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.UnaryMinus.html",
    "title": "Method UnaryMinus | Tensor for F#",
    "keywords": "Method UnaryMinus abstract member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member UnaryMinus: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.UnaryPlus.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.UnaryPlus.html",
    "title": "Method UnaryPlus | Tensor for F#",
    "keywords": "Method UnaryPlus abstract member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member UnaryPlus: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1"
  },
  "api/Tensor.Backend.ITensorBackend-1.VecVecDot.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.VecVecDot.html",
    "title": "Method VecVecDot | Tensor for F#",
    "keywords": "Method VecVecDot abstract member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration abstract member VecVecDot: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Xor.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Xor.html",
    "title": "Method Xor | Tensor for F#",
    "keywords": "Method Xor abstract member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration abstract member Xor: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2"
  },
  "api/Tensor.Backend.ITensorBackend-1.Item.html": {
    "href": "api/Tensor.Backend.ITensorBackend-1.Item.html",
    "title": "Property Item | Tensor for F#",
    "keywords": "Property Item abstract property Item: int64 [] -> 'T Declaration abstract property Item: int64 [] -> 'T with get, set Parameters Type Name Description int64 [] Property Value Type Description 'T"
  },
  "api/Tensor.TensorVal.NewAxis().html": {
    "href": "api/Tensor.TensorVal.NewAxis().html",
    "title": "Field val NewAxis | Tensor for F#",
    "keywords": "Field val NewAxis For slicing: inserts a new axis of size one. Namespace : Tensor Assembly : Tensor.dll Syntax val NewAxis: int64 Returns Type Description int64"
  },
  "api/Tensor.TensorVal.Fill().html": {
    "href": "api/Tensor.TensorVal.Fill().html",
    "title": "Field val Fill | Tensor for F#",
    "keywords": "Field val Fill For slicing: fills all remaining axes with size one. Namespace : Tensor Assembly : Tensor.dll Syntax val Fill: int64 Returns Type Description int64 Remarks Cannot be used together with val NewAxis ."
  },
  "api/Tensor.TensorVal.Remainder().html": {
    "href": "api/Tensor.TensorVal.Remainder().html",
    "title": "Field val Remainder | Tensor for F#",
    "keywords": "Field val Remainder For reshape: remainder, so that number of elements stays constant. Namespace : Tensor Assembly : Tensor.dll Syntax val Remainder: int64 Returns Type Description int64"
  },
  "api/Tensor.TensorVal.NotFound().html": {
    "href": "api/Tensor.TensorVal.NotFound().html",
    "title": "Field val NotFound | Tensor for F#",
    "keywords": "Field val NotFound For search: value was not found. Namespace : Tensor Assembly : Tensor.dll Syntax val NotFound: int64 Returns Type Description int64"
  },
  "api/Tensor.TensorVal.NoMask().html": {
    "href": "api/Tensor.TensorVal.NoMask().html",
    "title": "Field val NoMask | Tensor for F#",
    "keywords": "Field val NoMask Indicates that the dimension is unmasked, i.e. equals specifying a tensor filled with trues. Namespace : Tensor Assembly : Tensor.dll Syntax val NoMask: Tensor<bool> Returns Type Description Tensor < bool >"
  },
  "api/Tensor.TensorOrder.RowMajor.html": {
    "href": "api/Tensor.TensorOrder.RowMajor.html",
    "title": "Property RowMajor | Tensor for F#",
    "keywords": "Property RowMajor Row-major (C) memory order. Namespace : Tensor Assembly : Tensor.dll Syntax | RowMajor"
  },
  "api/Tensor.TensorOrder.ColumnMajor.html": {
    "href": "api/Tensor.TensorOrder.ColumnMajor.html",
    "title": "Property ColumnMajor | Tensor for F#",
    "keywords": "Property ColumnMajor Column-major (Fortran) memory order. Namespace : Tensor Assembly : Tensor.dll Syntax | ColumnMajor"
  },
  "api/Tensor.TensorOrder.CustomOrder.html": {
    "href": "api/Tensor.TensorOrder.CustomOrder.html",
    "title": "Property CustomOrder of int list | Tensor for F#",
    "keywords": "Property CustomOrder of int list The specified custom memory ordering of dimensions. Namespace : Tensor Assembly : Tensor.dll Syntax | CustomOrder of int list Parameters Type Name Description int list"
  },
  "api/Tensor.Tensor-1.-ctor.html": {
    "href": "api/Tensor.Tensor-1.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: TensorLayout * ITensorStorage<'T> -> Tensor<'T> Implicit constructor. Declaration new: layout:TensorLayout * storage:ITensorStorage<'T> -> Tensor<'T> Parameters Type Name Description TensorLayout layout The memory layout to use. ITensorStorage <'T> storage The storage to use. Returns Type Description Tensor <'T> A tensor using the specified memory layout and storage. new: int64 list * ITensorDevice * TensorOrder option -> Tensor<'T> Creates a new, uninitialized tensor with a new storage. Declaration new: shape:int64 list * dev:ITensorDevice * order:TensorOrder option -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the tensor to create. ITensorDevice dev The device to store the data of the tensor on. TensorOrder option order The memory layout to use for the new tensor. (default: row-major) Returns Type Description Tensor <'T> The new, uninitialized tensor. Remarks The contents of the new tensor are undefined. The default memory layout is row-major. The recommended way to create a new tensor is to use static member zeros: ITensorDevice -> int64 list -> Tensor<'T> . See Also static member NewOfType: int64 list * Type * ITensorDevice * TensorOrder option -> ITensor static member zeros: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Abs.html": {
    "href": "api/Tensor.Tensor-1.Abs.html",
    "title": "Method Abs | Tensor for F#",
    "keywords": "Method Abs static member Abs: Tensor<'T> -> Tensor<'T> Element-wise absolute value. Declaration static member Abs: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the absolute value of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# abs function. Examples let a = HostTensor.ofList [-2; -1; 1] let b = abs a // b = [2; 1; 1] See Also member FillAbs: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Acos.html": {
    "href": "api/Tensor.Tensor-1.Acos.html",
    "title": "Method Acos | Tensor for F#",
    "keywords": "Method Acos static member Acos: Tensor<'T> -> Tensor<'T> Element-wise arccosine (inverse cosine). Declaration static member Acos: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the arccosine (inverse cosine) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# acos function. Examples let a = HostTensor.ofList [-1.0; 0.0; 1.0] let b = acos a // b = [3.15159; 1.57079; 0.0] See Also member FillAcos: Tensor<'T> -> unit static member Cos: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Asin.html": {
    "href": "api/Tensor.Tensor-1.Asin.html",
    "title": "Method Asin | Tensor for F#",
    "keywords": "Method Asin static member Asin: Tensor<'T> -> Tensor<'T> Element-wise arcsine (inverse sine). Declaration static member Asin: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the arcsine (inverse sine) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# asin function. Examples let a = HostTensor.ofList [-1.0; 0.0; 1.0] let b = asin a // b = [-1.57079; 0.0; 1.57079] See Also member FillAsin: Tensor<'T> -> unit static member Sin: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Atan.html": {
    "href": "api/Tensor.Tensor-1.Atan.html",
    "title": "Method Atan | Tensor for F#",
    "keywords": "Method Atan static member Atan: Tensor<'T> -> Tensor<'T> Element-wise arctanget (inverse tangent). Declaration static member Atan: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the arctanget (inverse tangent) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# atan function. Examples let a = HostTensor.ofList [-1.0; 0.0; 1.0] let b = atan a // b = [-0.78539; 0.0; 0.78539] See Also member FillAcos: Tensor<'T> -> unit static member Tan: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Ceiling.html": {
    "href": "api/Tensor.Tensor-1.Ceiling.html",
    "title": "Method Ceiling | Tensor for F#",
    "keywords": "Method Ceiling static member Ceiling: Tensor<'T> -> Tensor<'T> Element-wise ceiling (round towards positive infinity). Declaration static member Ceiling: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the ceiling (round towards positive infinity) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# ceil function. Examples let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0] let b = ceil a // b = [-3.0; -2.0; 3.0; 3.0] See Also member FillCeiling: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.CheckAxis.html": {
    "href": "api/Tensor.Tensor-1.CheckAxis.html",
    "title": "Method CheckAxis | Tensor for F#",
    "keywords": "Method CheckAxis member CheckAxis: int -> unit Checks the the specified axis is valid for this tensor. Declaration member CheckAxis: ax:int -> unit Parameters Type Name Description int ax The axis number to check. Remarks If the axis is valid, this function does nothing. Exceptions Type Condition System.IndexOutOfRangeException Raised when the axis is invalid."
  },
  "api/Tensor.Tensor-1.CopyFrom.html": {
    "href": "api/Tensor.Tensor-1.CopyFrom.html",
    "title": "Method CopyFrom | Tensor for F#",
    "keywords": "Method CopyFrom member CopyFrom: Tensor<'T> -> unit Fills this tensor with a copy of the specified tensor. Declaration member CopyFrom: src:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> src The tensor to copy from. Remarks The source tensor must have the same shape and be stored on the same device as this tensor. See Also static member copy: Tensor<'T> * TensorOrder option -> Tensor<'T> member FillFrom: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Cos.html": {
    "href": "api/Tensor.Tensor-1.Cos.html",
    "title": "Method Cos | Tensor for F#",
    "keywords": "Method Cos static member Cos: Tensor<'T> -> Tensor<'T> Element-wise cosine. Declaration static member Cos: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the cosine of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# cos function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = cos a // b = [0.0; 1.0; 0.0] See Also member FillCos: Tensor<'T> -> unit static member Acos: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Cosh.html": {
    "href": "api/Tensor.Tensor-1.Cosh.html",
    "title": "Method Cosh | Tensor for F#",
    "keywords": "Method Cosh static member Cosh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic cosine. Declaration static member Cosh: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the hyperbolic cosine of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# cosh function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = cosh a // b = [2.50916; 1.0; 2.50916] See Also member FillCosh: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Equals.html": {
    "href": "api/Tensor.Tensor-1.Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals override member Equals: obj -> bool Tests for equality to another object. Declaration override member Equals: other:obj -> bool Parameters Type Name Description obj other The other object. Returns Type Description bool true if the objects are equal. Otherwise false. Remarks Two tensors are equal if they have the same storage and same layout. In this case, changing one tensor will have the exact same effect on the other tensor. Two tensors can overlap, i.e. one can partially or fully affect the other, without being equal. The elements of a tensor do not affect equality, i.e. two tensors can contain exactly the same values without being equal. See Also static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member almostEqual: Tensor<'T> * Tensor<'T> * 'T option * 'T option -> bool"
  },
  "api/Tensor.Tensor-1.Exp.html": {
    "href": "api/Tensor.Tensor-1.Exp.html",
    "title": "Method Exp | Tensor for F#",
    "keywords": "Method Exp static member Exp: Tensor<'T> -> Tensor<'T> Element-wise exponential function. Declaration static member Exp: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the exponential function of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# exp function. Examples let a = HostTensor.ofList [-1.0; 0.0; 1.0; 10.0] let b = exp a // b = [0.36787; 1.0; 2.71828; 22026.4657] See Also member FillExp: Tensor<'T> -> unit static member Log: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillAbs.html": {
    "href": "api/Tensor.Tensor-1.FillAbs.html",
    "title": "Method FillAbs | Tensor for F#",
    "keywords": "Method FillAbs member FillAbs: Tensor<'T> -> unit Fills this tensor with the element-wise absolute value of the argument. Declaration member FillAbs: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Abs: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillAcos.html": {
    "href": "api/Tensor.Tensor-1.FillAcos.html",
    "title": "Method FillAcos | Tensor for F#",
    "keywords": "Method FillAcos member FillAcos: Tensor<'T> -> unit Fills this tensor with the element-wise arccosine (inverse cosine) of the argument. Declaration member FillAcos: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Acos: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillAdd.html": {
    "href": "api/Tensor.Tensor-1.FillAdd.html",
    "title": "Method FillAdd | Tensor for F#",
    "keywords": "Method FillAdd member FillAdd: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise addition of the arguments. Declaration member FillAdd: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( + ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillAllAxis.html": {
    "href": "api/Tensor.Tensor-1.FillAllAxis.html",
    "title": "Method FillAllAxis | Tensor for F#",
    "keywords": "Method FillAllAxis member FillAllAxis: int -> Tensor<bool> -> unit Checks if all elements along the specified axis are true using this tensor as target. Declaration member FillAllAxis: ax:int -> src:Tensor<bool> -> unit Parameters Type Name Description int ax The axis to check along. Tensor < bool > src The tensor containing the source values. See Also static member allAxis: int -> Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillAnd.html": {
    "href": "api/Tensor.Tensor-1.FillAnd.html",
    "title": "Method FillAnd | Tensor for F#",
    "keywords": "Method FillAnd member FillAnd: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical and of the arguments. Declaration member FillAnd: a:Tensor<bool> -> b:Tensor<bool> -> unit Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. See Also static member ( &&&& ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillAnyAxis.html": {
    "href": "api/Tensor.Tensor-1.FillAnyAxis.html",
    "title": "Method FillAnyAxis | Tensor for F#",
    "keywords": "Method FillAnyAxis member FillAnyAxis: int -> Tensor<bool> -> unit Checks if any element along the specified axis is true using this tensor as target. Declaration member FillAnyAxis: ax:int -> src:Tensor<bool> -> unit Parameters Type Name Description int ax The axis to check along. Tensor < bool > src The tensor containing the source values. See Also static member anyAxis: int -> Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillArgMaxAxis.html": {
    "href": "api/Tensor.Tensor-1.FillArgMaxAxis.html",
    "title": "Method FillArgMaxAxis | Tensor for F#",
    "keywords": "Method FillArgMaxAxis member FillArgMaxAxis: int -> Tensor<'R> -> unit Finds the index of the maximum value along the specified axis and writes it into this tensor. Declaration member FillArgMaxAxis: ax:int -> src:Tensor<'R> -> unit Parameters Type Name Description int ax The axis to calculate the maximum along. Tensor <'R> src The tensor containing the source values. Type Parameters Name Description 'R See Also static member argMaxAxis: int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.FillArgMinAxis.html": {
    "href": "api/Tensor.Tensor-1.FillArgMinAxis.html",
    "title": "Method FillArgMinAxis | Tensor for F#",
    "keywords": "Method FillArgMinAxis member FillArgMinAxis: int -> Tensor<'R> -> unit Finds the index of the minimum value along the specified axis and writes it into this tensor. Declaration member FillArgMinAxis: ax:int -> src:Tensor<'R> -> unit Parameters Type Name Description int ax The axis to calculate the minimum along. Tensor <'R> src The tensor containing the source values. Type Parameters Name Description 'R See Also static member argMinAxis: int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.FillAsin.html": {
    "href": "api/Tensor.Tensor-1.FillAsin.html",
    "title": "Method FillAsin | Tensor for F#",
    "keywords": "Method FillAsin member FillAsin: Tensor<'T> -> unit Fills this tensor with the element-wise arcsine (inverse sine) of the argument. Declaration member FillAsin: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Asin: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillAtan.html": {
    "href": "api/Tensor.Tensor-1.FillAtan.html",
    "title": "Method FillAtan | Tensor for F#",
    "keywords": "Method FillAtan member FillAtan: Tensor<'T> -> unit Fills this tensor with the element-wise arctanget (inverse tangent) of the argument. Declaration member FillAtan: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Atan: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillCeiling.html": {
    "href": "api/Tensor.Tensor-1.FillCeiling.html",
    "title": "Method FillCeiling | Tensor for F#",
    "keywords": "Method FillCeiling member FillCeiling: Tensor<'T> -> unit Fills this tensor with the element-wise ceiling (round towards positive infinity) of the argument. Declaration member FillCeiling: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Ceiling: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillConst.html": {
    "href": "api/Tensor.Tensor-1.FillConst.html",
    "title": "Method FillConst | Tensor for F#",
    "keywords": "Method FillConst member FillConst: 'T -> unit Fills this tensor with the specified constant value. Declaration member FillConst: value:'T -> unit Parameters Type Name Description 'T value The value to use. See Also static member filled: ITensorDevice -> int64 list -> 'T -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillConvert.html": {
    "href": "api/Tensor.Tensor-1.FillConvert.html",
    "title": "Method FillConvert | Tensor for F#",
    "keywords": "Method FillConvert member FillConvert: Tensor<'C> -> unit Copies elements from a tensor of different data type into this tensor and converts their type. Declaration member FillConvert: a:Tensor<'C> -> unit Parameters Type Name Description Tensor <'C> a The tensor to copy from. Type Parameters Name Description 'C The data type to convert from. See Also static member convert: Tensor<'C> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillCos.html": {
    "href": "api/Tensor.Tensor-1.FillCos.html",
    "title": "Method FillCos | Tensor for F#",
    "keywords": "Method FillCos member FillCos: Tensor<'T> -> unit Fills this tensor with the element-wise cosine of the argument. Declaration member FillCos: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Cos: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillCosh.html": {
    "href": "api/Tensor.Tensor-1.FillCosh.html",
    "title": "Method FillCosh | Tensor for F#",
    "keywords": "Method FillCosh member FillCosh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic cosine of the argument. Declaration member FillCosh: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Cosh: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillCountTrueAxis.html": {
    "href": "api/Tensor.Tensor-1.FillCountTrueAxis.html",
    "title": "Method FillCountTrueAxis | Tensor for F#",
    "keywords": "Method FillCountTrueAxis member FillCountTrueAxis: int -> Tensor<bool> -> unit Counts the elements being true along the specified axis and writes the result into this tensor. Declaration member FillCountTrueAxis: ax:int -> src:Tensor<bool> -> unit Parameters Type Name Description int ax The axis the count along. Tensor < bool > src The tensor containing the source values. See Also static member countTrueAxis: int -> Tensor<bool> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.FillDivide.html": {
    "href": "api/Tensor.Tensor-1.FillDivide.html",
    "title": "Method FillDivide | Tensor for F#",
    "keywords": "Method FillDivide member FillDivide: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise division of the arguments. Declaration member FillDivide: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( / ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillDot.html": {
    "href": "api/Tensor.Tensor-1.FillDot.html",
    "title": "Method FillDot | Tensor for F#",
    "keywords": "Method FillDot member FillDot: Tensor<'T> -> Tensor<'T> -> unit Fill this tensor with the (batched) matrix product, matrix-vector product or scalar product of the arguments. Declaration member FillDot: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( .* ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillEqual.html": {
    "href": "api/Tensor.Tensor-1.FillEqual.html",
    "title": "Method FillEqual | Tensor for F#",
    "keywords": "Method FillEqual member FillEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise equality test of the arguments. Declaration member FillEqual: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillExp.html": {
    "href": "api/Tensor.Tensor-1.FillExp.html",
    "title": "Method FillExp | Tensor for F#",
    "keywords": "Method FillExp member FillExp: Tensor<'T> -> unit Fills this tensor with the element-wise exponential function of the argument. Declaration member FillExp: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Exp: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillFindAxis.html": {
    "href": "api/Tensor.Tensor-1.FillFindAxis.html",
    "title": "Method FillFindAxis | Tensor for F#",
    "keywords": "Method FillFindAxis member FillFindAxis: 'R -> int -> Tensor<'R> -> unit Finds the first occurence of the specfied value along the specified axis and write its index into this tensor. Declaration member FillFindAxis: value:'R -> ax:int -> src:Tensor<'R> -> unit Parameters Type Name Description 'R value The value to find. int ax The axis to find the value along. Tensor <'R> src The tensor containing the source values. Type Parameters Name Description 'R See Also static member findAxis: 'T -> int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.FillFloor.html": {
    "href": "api/Tensor.Tensor-1.FillFloor.html",
    "title": "Method FillFloor | Tensor for F#",
    "keywords": "Method FillFloor member FillFloor: Tensor<'T> -> unit Fills this tensor with the element-wise floor (round towards negative infinity) of the argument. Declaration member FillFloor: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Floor: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillFrom.html": {
    "href": "api/Tensor.Tensor-1.FillFrom.html",
    "title": "Method FillFrom | Tensor for F#",
    "keywords": "Method FillFrom member FillFrom: Tensor<'T> -> unit Fills this tensor with a copy of the specified tensor. Declaration member FillFrom: src:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> src The tensor to copy from. Remarks The source tensor is broadcasted to the size of this tensor. The source tensor must be stored on the same device as this tensor. See Also member CopyFrom: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.FillGather.html": {
    "href": "api/Tensor.Tensor-1.FillGather.html",
    "title": "Method FillGather | Tensor for F#",
    "keywords": "Method FillGather member FillGather: Tensor<int64> option list -> Tensor<'T> -> unit Selects elements from a tensor according to specified indices. Declaration member FillGather: indices:Tensor<int64> option list -> src:Tensor<'T> -> unit Parameters Type Name Description Tensor < int64 > option list indices A list of tensors, one per dimension of src , containing the indicies to pick from src for each output element. Tensor <'T> src The tensor containing the source values. See Also static member gather: Tensor<int64> option list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillGreater.html": {
    "href": "api/Tensor.Tensor-1.FillGreater.html",
    "title": "Method FillGreater | Tensor for F#",
    "keywords": "Method FillGreater member FillGreater: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise greater-than test of the arguments. Declaration member FillGreater: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( >>>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillGreaterOrEqual.html": {
    "href": "api/Tensor.Tensor-1.FillGreaterOrEqual.html",
    "title": "Method FillGreaterOrEqual | Tensor for F#",
    "keywords": "Method FillGreaterOrEqual member FillGreaterOrEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise greater-than-or-equal test of the arguments. Declaration member FillGreaterOrEqual: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( >>== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillIfThenElse.html": {
    "href": "api/Tensor.Tensor-1.FillIfThenElse.html",
    "title": "Method FillIfThenElse | Tensor for F#",
    "keywords": "Method FillIfThenElse member FillIfThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with an element-wise choice between two sources depending on a condition. Declaration member FillIfThenElse: cond:Tensor<bool> -> ifTrue:Tensor<'T> -> ifFalse:Tensor<'T> -> unit Parameters Type Name Description Tensor < bool > cond The condition tensor. Tensor <'T> ifTrue The tensor containing the values to use for when an element of the condition is true. Tensor <'T> ifFalse The tensor containing the values to use for when an element of the condition is false. See Also static member ifThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillIncrementing.html": {
    "href": "api/Tensor.Tensor-1.FillIncrementing.html",
    "title": "Method FillIncrementing | Tensor for F#",
    "keywords": "Method FillIncrementing member FillIncrementing: 'T * 'T -> unit Fills this vector with an equispaced sequence of elements. Declaration member FillIncrementing: start:'T * incr:'T -> unit Parameters Type Name Description 'T start The starting value. 'T incr The increment between successive elements. Remarks This tensor must be one dimensional. See Also arange``3"
  },
  "api/Tensor.Tensor-1.FillInvert.html": {
    "href": "api/Tensor.Tensor-1.FillInvert.html",
    "title": "Method FillInvert | Tensor for F#",
    "keywords": "Method FillInvert member FillInvert: Tensor<'T> -> unit Fills this tensor with the (batch) inverse of a matrix. Declaration member FillInvert: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The input to this operation. See Also static member invert: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillIsFinite.html": {
    "href": "api/Tensor.Tensor-1.FillIsFinite.html",
    "title": "Method FillIsFinite | Tensor for F#",
    "keywords": "Method FillIsFinite member FillIsFinite: Tensor<'R> -> unit Fills this tensor with the element-wise finity check (not -Inf, Inf or NaN) of the argument. Declaration member FillIsFinite: a:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor to apply this operation to. Type Parameters Name Description 'R See Also static member isFinite: Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillLess.html": {
    "href": "api/Tensor.Tensor-1.FillLess.html",
    "title": "Method FillLess | Tensor for F#",
    "keywords": "Method FillLess member FillLess: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise less-than test of the arguments. Declaration member FillLess: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( <<<< ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillLessOrEqual.html": {
    "href": "api/Tensor.Tensor-1.FillLessOrEqual.html",
    "title": "Method FillLessOrEqual | Tensor for F#",
    "keywords": "Method FillLessOrEqual member FillLessOrEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise less-than-or-equal test of the arguments. Declaration member FillLessOrEqual: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( <<== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillLog.html": {
    "href": "api/Tensor.Tensor-1.FillLog.html",
    "title": "Method FillLog | Tensor for F#",
    "keywords": "Method FillLog member FillLog: Tensor<'T> -> unit Fills this tensor with the element-wise natural logarithm of the argument. Declaration member FillLog: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Log: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillLog10.html": {
    "href": "api/Tensor.Tensor-1.FillLog10.html",
    "title": "Method FillLog10 | Tensor for F#",
    "keywords": "Method FillLog10 member FillLog10: Tensor<'T> -> unit Fills this tensor with the element-wise common logarithm of the argument. Declaration member FillLog10: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Log10: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillMaxAxis.html": {
    "href": "api/Tensor.Tensor-1.FillMaxAxis.html",
    "title": "Method FillMaxAxis | Tensor for F#",
    "keywords": "Method FillMaxAxis member FillMaxAxis: int -> Tensor<'T> -> unit Calculates the maximum value of the elements over the specified axis and writes the result into this tensor. Declaration member FillMaxAxis: ax:int -> src:Tensor<'T> -> unit Parameters Type Name Description int ax The axis to calculate the maximum along. Tensor <'T> src The tensor containing the source values. See Also static member maxAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillMaxElemwise.html": {
    "href": "api/Tensor.Tensor-1.FillMaxElemwise.html",
    "title": "Method FillMaxElemwise | Tensor for F#",
    "keywords": "Method FillMaxElemwise member FillMaxElemwise: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise maximum of the arguments. Declaration member FillMaxElemwise: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member maxElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillMinAxis.html": {
    "href": "api/Tensor.Tensor-1.FillMinAxis.html",
    "title": "Method FillMinAxis | Tensor for F#",
    "keywords": "Method FillMinAxis member FillMinAxis: int -> Tensor<'T> -> unit Calculates the minimum value of the elements over the specified axis and writes the result into this tensor. Declaration member FillMinAxis: ax:int -> src:Tensor<'T> -> unit Parameters Type Name Description int ax The axis to calculate the minimum along. Tensor <'T> src The tensor containing the source values. See Also static member minAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillMinElemwise.html": {
    "href": "api/Tensor.Tensor-1.FillMinElemwise.html",
    "title": "Method FillMinElemwise | Tensor for F#",
    "keywords": "Method FillMinElemwise member FillMinElemwise: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise minimum of the arguments. Declaration member FillMinElemwise: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member minElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillModulo.html": {
    "href": "api/Tensor.Tensor-1.FillModulo.html",
    "title": "Method FillModulo | Tensor for F#",
    "keywords": "Method FillModulo member FillModulo: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise remainder of the division of the arguments. Declaration member FillModulo: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( % ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillMultiply.html": {
    "href": "api/Tensor.Tensor-1.FillMultiply.html",
    "title": "Method FillMultiply | Tensor for F#",
    "keywords": "Method FillMultiply member FillMultiply: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise multiplication of the arguments. Declaration member FillMultiply: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( * ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillNegate.html": {
    "href": "api/Tensor.Tensor-1.FillNegate.html",
    "title": "Method FillNegate | Tensor for F#",
    "keywords": "Method FillNegate member FillNegate: Tensor<bool> -> unit Fills this tensor with the element-wise logical negation of the argument. Declaration member FillNegate: a:Tensor<bool> -> unit Parameters Type Name Description Tensor < bool > a The tensor to apply this operation to. See Also static member ( ~~~~ ): Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillNotEqual.html": {
    "href": "api/Tensor.Tensor-1.FillNotEqual.html",
    "title": "Method FillNotEqual | Tensor for F#",
    "keywords": "Method FillNotEqual member FillNotEqual: Tensor<'R> -> Tensor<'R> -> unit Fills this tensor with the element-wise not-equality test or of the arguments. Declaration member FillNotEqual: a:Tensor<'R> -> b:Tensor<'R> -> unit Parameters Type Name Description Tensor <'R> a The tensor on the left side of this binary operation. Tensor <'R> b The tensor on the right side of this binary operation. Type Parameters Name Description 'R See Also static member ( <<>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillOr.html": {
    "href": "api/Tensor.Tensor-1.FillOr.html",
    "title": "Method FillOr | Tensor for F#",
    "keywords": "Method FillOr member FillOr: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical or of the arguments. Declaration member FillOr: a:Tensor<bool> -> b:Tensor<bool> -> unit Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. See Also static member ( |||| ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.FillPower.html": {
    "href": "api/Tensor.Tensor-1.FillPower.html",
    "title": "Method FillPower | Tensor for F#",
    "keywords": "Method FillPower member FillPower: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise exponentiation. Declaration member FillPower: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member Pow: Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillProductAxis.html": {
    "href": "api/Tensor.Tensor-1.FillProductAxis.html",
    "title": "Method FillProductAxis | Tensor for F#",
    "keywords": "Method FillProductAxis member FillProductAxis: int -> Tensor<'T> -> unit Calculates the product of the elements over the specified axis and writes the result into this tensor. Declaration member FillProductAxis: ax:int -> src:Tensor<'T> -> unit Parameters Type Name Description int ax The axis to calculate the product along. Tensor <'T> src The tensor containing the source values. See Also static member productAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillPseudoInvert.html": {
    "href": "api/Tensor.Tensor-1.FillPseudoInvert.html",
    "title": "Method FillPseudoInvert | Tensor for F#",
    "keywords": "Method FillPseudoInvert member FillPseudoInvert: Tensor<'T> * 'T option -> unit Fills this tensor with the (batched) Moore-Penrose pseudo-inverse of the specified matrix. Declaration member FillPseudoInvert: a:Tensor<'T> * rCond:'T option -> unit Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. 'T option rCond The cut-off value for the singular values. (default: 1e-15) See Also static member pseudoInvert: Tensor<'T> * 'T option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillRound.html": {
    "href": "api/Tensor.Tensor-1.FillRound.html",
    "title": "Method FillRound | Tensor for F#",
    "keywords": "Method FillRound member FillRound: Tensor<'T> -> unit Fills this tensor with the element-wise rounding of the argument. Declaration member FillRound: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Round: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSVD.html": {
    "href": "api/Tensor.Tensor-1.FillSVD.html",
    "title": "Method FillSVD | Tensor for F#",
    "keywords": "Method FillSVD member FillSVD: Tensor<'T> * Tensor<'T> * Tensor<'T> option -> unit Fills this tensor with the (batched) singular values of the specified matrix. Declaration member FillSVD: a:Tensor<'T> * trgtUV:Tensor<'T> * Tensor<'T> option -> unit Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. Tensor <'T> * Tensor <'T> option trgtUV The optional target tensors for the transformation matrices. Remarks The singular values are stored in this vector. See Also static member SVD: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> static member SVDWithoutUV: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillScatter.html": {
    "href": "api/Tensor.Tensor-1.FillScatter.html",
    "title": "Method FillScatter | Tensor for F#",
    "keywords": "Method FillScatter member FillScatter: Tensor<int64> option list -> Tensor<'T> -> unit Disperses elements from a source tensor to this tensor according to the specified indices. Declaration member FillScatter: indices:Tensor<int64> option list -> src:Tensor<'T> -> unit Parameters Type Name Description Tensor < int64 > option list indices A list of tensors, one per dimension of this tensor, containing the target indicies for each element of src . Tensor <'T> src The tensor containing the source values. See Also static member scatter: Tensor<int64> option list -> int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSgn.html": {
    "href": "api/Tensor.Tensor-1.FillSgn.html",
    "title": "Method FillSgn | Tensor for F#",
    "keywords": "Method FillSgn member FillSgn: Tensor<'T> -> unit Fills this tensor with the element-wise sign of the argument. Declaration member FillSgn: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Sgn: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSin.html": {
    "href": "api/Tensor.Tensor-1.FillSin.html",
    "title": "Method FillSin | Tensor for F#",
    "keywords": "Method FillSin member FillSin: Tensor<'T> -> unit Fills this tensor with the element-wise sine of the argument. Declaration member FillSin: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Sin: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSinh.html": {
    "href": "api/Tensor.Tensor-1.FillSinh.html",
    "title": "Method FillSinh | Tensor for F#",
    "keywords": "Method FillSinh member FillSinh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic sine of the argument. Declaration member FillSinh: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Sinh: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSqrt.html": {
    "href": "api/Tensor.Tensor-1.FillSqrt.html",
    "title": "Method FillSqrt | Tensor for F#",
    "keywords": "Method FillSqrt member FillSqrt: Tensor<'T> -> unit Fills this tensor with the element-wise square root of the argument. Declaration member FillSqrt: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Sqrt: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSubtract.html": {
    "href": "api/Tensor.Tensor-1.FillSubtract.html",
    "title": "Method FillSubtract | Tensor for F#",
    "keywords": "Method FillSubtract member FillSubtract: Tensor<'T> -> Tensor<'T> -> unit Fills this tensor with the element-wise substraction of the arguments. Declaration member FillSubtract: a:Tensor<'T> -> b:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. See Also static member ( - ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSumAxis.html": {
    "href": "api/Tensor.Tensor-1.FillSumAxis.html",
    "title": "Method FillSumAxis | Tensor for F#",
    "keywords": "Method FillSumAxis member FillSumAxis: int -> Tensor<'T> -> unit Sums the elements over the specified axis and writes the result into this tensor. Declaration member FillSumAxis: ax:int -> src:Tensor<'T> -> unit Parameters Type Name Description int ax The axis to sum along. Tensor <'T> src The tensor containing the source values. See Also static member sumAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillSymmetricEigenDecomposition.html": {
    "href": "api/Tensor.Tensor-1.FillSymmetricEigenDecomposition.html",
    "title": "Method FillSymmetricEigenDecomposition | Tensor for F#",
    "keywords": "Method FillSymmetricEigenDecomposition static member FillSymmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> -> Tensor<'T> -> unit Computes the (real) eigendecomposition of a symmetric matrix and writes it into the specified target tensors. Declaration static member FillSymmetricEigenDecomposition: part:MatrixPart -> trgtEigVals:Tensor<'T> -> trgtEigVecs:Tensor<'T> -> a:Tensor<'T> -> unit Parameters Type Name Description MatrixPart part Specifies which part of the matrix should be used. Tensor <'T> trgtEigVals The target vector that will receive the eigenvalues. Tensor <'T> trgtEigVecs The target matrix that will receive the eigenvectors. Tensor <'T> a The input matrix to this operation. See Also static member symmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> * Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillTan.html": {
    "href": "api/Tensor.Tensor-1.FillTan.html",
    "title": "Method FillTan | Tensor for F#",
    "keywords": "Method FillTan member FillTan: Tensor<'T> -> unit Fills this tensor with the element-wise tangent of the argument. Declaration member FillTan: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Tan: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillTanh.html": {
    "href": "api/Tensor.Tensor-1.FillTanh.html",
    "title": "Method FillTanh | Tensor for F#",
    "keywords": "Method FillTanh member FillTanh: Tensor<'T> -> unit Fills this tensor with the element-wise hyperbolic tangent of the argument. Declaration member FillTanh: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Tanh: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillTruncate.html": {
    "href": "api/Tensor.Tensor-1.FillTruncate.html",
    "title": "Method FillTruncate | Tensor for F#",
    "keywords": "Method FillTruncate member FillTruncate: Tensor<'T> -> unit Fills this tensor with the element-wise truncation (rounding towards zero) of the argument. Declaration member FillTruncate: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. See Also static member Truncate: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillUnaryMinus.html": {
    "href": "api/Tensor.Tensor-1.FillUnaryMinus.html",
    "title": "Method FillUnaryMinus | Tensor for F#",
    "keywords": "Method FillUnaryMinus member FillUnaryMinus: Tensor<'T> -> unit Fills this tensor with the element-wise negation of the argument. Declaration member FillUnaryMinus: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to operate on. See Also static member ( ~- ): Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillUnaryPlus.html": {
    "href": "api/Tensor.Tensor-1.FillUnaryPlus.html",
    "title": "Method FillUnaryPlus | Tensor for F#",
    "keywords": "Method FillUnaryPlus member FillUnaryPlus: Tensor<'T> -> unit Fills this tensor with the element-wise prefix plus of the argument. Declaration member FillUnaryPlus: a:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> a The tensor to operate on. See Also static member ( ~+ ): Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.FillXor.html": {
    "href": "api/Tensor.Tensor-1.FillXor.html",
    "title": "Method FillXor | Tensor for F#",
    "keywords": "Method FillXor member FillXor: Tensor<bool> -> Tensor<bool> -> unit Fills this tensor with the element-wise logical xor of the arguments. Declaration member FillXor: a:Tensor<bool> -> b:Tensor<bool> -> unit Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. See Also static member ( ^^^^ ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.Floor.html": {
    "href": "api/Tensor.Tensor-1.Floor.html",
    "title": "Method Floor | Tensor for F#",
    "keywords": "Method Floor static member Floor: Tensor<'T> -> Tensor<'T> Element-wise floor (round towards negative infinity). Declaration static member Floor: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the floor (round towards negative infinity) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# floor function. Examples let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0] let b = floor a // b = [-3.0; -3.0; 2.0; 3.0] See Also member FillFloor: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.GetHashCode.html": {
    "href": "api/Tensor.Tensor-1.GetHashCode.html",
    "title": "Method GetHashCode | Tensor for F#",
    "keywords": "Method GetHashCode override member GetHashCode: unit -> int Calculates the hash code of the tensor. Declaration override member GetHashCode: unit -> int Returns Type Description int The hash code. Remarks The hash code is calculated from the storage and layout of the tensor. If two tensors are equal, they will have the same hash code. See Also override member Equals: obj -> bool"
  },
  "api/Tensor.Tensor-1.Log.html": {
    "href": "api/Tensor.Tensor-1.Log.html",
    "title": "Method Log | Tensor for F#",
    "keywords": "Method Log static member Log: Tensor<'T> -> Tensor<'T> Element-wise natural logarithm. Declaration static member Log: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the natural logarithm of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# log function. Examples let a = HostTensor.ofList [1.0; 2.71828; 4.0] let b = log a // b = [0.0; 1.0; 1.38529] See Also member FillLog: Tensor<'T> -> unit static member Log10: Tensor<'T> -> Tensor<'T> static member Exp: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Log10.html": {
    "href": "api/Tensor.Tensor-1.Log10.html",
    "title": "Method Log10 | Tensor for F#",
    "keywords": "Method Log10 static member Log10: Tensor<'T> -> Tensor<'T> Element-wise common logarithm. Declaration static member Log10: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the common logarithm (to base 10) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# log10 function. Examples let a = HostTensor.ofList [1.0; 10.0; 100.0] let b = log10 a // b = [0.0; 1.0; 2.0] See Also member FillLog10: Tensor<'T> -> unit static member Log: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.NewOfType.html": {
    "href": "api/Tensor.Tensor-1.NewOfType.html",
    "title": "Method NewOfType | Tensor for F#",
    "keywords": "Method NewOfType static member NewOfType: int64 list * Type * ITensorDevice * TensorOrder option -> ITensor Type-neutral function for creating a new, uninitialized tensor with a new storage. Declaration static member NewOfType: shape:int64 list * dataType:Type * dev:ITensorDevice * order:TensorOrder option -> ITensor Parameters Type Name Description int64 list shape The shape of the tensor to create. System.Type dataType The data type of the tensor to create. ITensorDevice dev The device to store the data of the tensor on. TensorOrder option order The memory layout to use for the new tensor. Returns Type Description ITensor The new, uninitialized tensor. Remarks The contents of the new tensor are undefined. Use this function only if you require a type-neutral function. The recommended way is to use static member zeros: ITensorDevice -> int64 list -> Tensor<'T> to create a typed tensor. See Also new: TensorLayout * ITensorStorage<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Pow.html": {
    "href": "api/Tensor.Tensor-1.Pow.html",
    "title": "Method Pow | Tensor for F#",
    "keywords": "Method Pow static member Pow: Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise exponentiation. Declaration static member Pow: a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the exponentiation of each element of tensor a to the power given by the corresponding element of tensor b and returns the results as a new tensor. Do not call this function directly; instead use the F# ** operator. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a ** b // c = [25.0; 216.0; 2401.0] See Also member FillPower: Tensor<'T> -> Tensor<'T> -> unit static member Pow: Tensor<'T> * 'T -> Tensor<'T> Element-wise exponentiation with scalar. Declaration static member Pow: a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member Pow: Tensor<'T> * Tensor<'T> -> Tensor<'T> static member Pow: 'T * Tensor<'T> -> Tensor<'T> Element-wise exponentiation with scalar. Declaration static member Pow: a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member Pow: Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Round.html": {
    "href": "api/Tensor.Tensor-1.Round.html",
    "title": "Method Round | Tensor for F#",
    "keywords": "Method Round static member Round: Tensor<'T> -> Tensor<'T> Element-wise rounding. Declaration static member Round: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the rounding of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# round function. Examples let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0] let b = round a // b = [-3.0; -3.0; 3.0; 3.0] See Also member FillRound: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.SVD.html": {
    "href": "api/Tensor.Tensor-1.SVD.html",
    "title": "Method SVD | Tensor for F#",
    "keywords": "Method SVD static member SVD: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Computes the (batched) singular value decomposition (SVD) of the specified matrix. Declaration static member SVD: a:Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. Returns Type Description Tensor <'T> * Tensor <'T> * Tensor <'T> A tuple consisting of (U, S, V) where S is a vector consisting of the singular values and U , V are the transformation matrices. Remarks The singular value decomposition of matrix a is computed. It is defined by the property that a = U .* Tensor.diagMat(S) .* V.T . If a is a tensor, the operation is batched over the matrices consisting of the last two dimensions. See Also member FillSVD: Tensor<'T> * Tensor<'T> * Tensor<'T> option -> unit static member SVDWithoutUV: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.SVDWithoutUV.html": {
    "href": "api/Tensor.Tensor-1.SVDWithoutUV.html",
    "title": "Method SVDWithoutUV | Tensor for F#",
    "keywords": "Method SVDWithoutUV static member SVDWithoutUV: Tensor<'T> -> Tensor<'T> Computes the (batched) singular values of the specified matrix. Declaration static member SVDWithoutUV: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. Returns Type Description Tensor <'T> A vector consisting of the singular values. See Also static member SVD: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Sgn.html": {
    "href": "api/Tensor.Tensor-1.Sgn.html",
    "title": "Method Sgn | Tensor for F#",
    "keywords": "Method Sgn static member Sgn: Tensor<'T> -> Tensor<'T> Element-wise sign. Declaration static member Sgn: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the sign of each element of the specified tensor and returns them as a new tensor. The type of the returned tensor matches the type of the argument tensor. Do not call this function directly; instead use the F# sgn function. Examples let a = HostTensor.ofList [-2; -1; 0; 2] let b = sgn a // b = [-1; -1; 0; 1] See Also member FillSgn: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Sin.html": {
    "href": "api/Tensor.Tensor-1.Sin.html",
    "title": "Method Sin | Tensor for F#",
    "keywords": "Method Sin static member Sin: Tensor<'T> -> Tensor<'T> Element-wise sine. Declaration static member Sin: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the sine of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# sin function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = sin a // b = [-1.0; 0.0; 1.0] See Also member FillSin: Tensor<'T> -> unit static member Asin: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Sinh.html": {
    "href": "api/Tensor.Tensor-1.Sinh.html",
    "title": "Method Sinh | Tensor for F#",
    "keywords": "Method Sinh static member Sinh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic sine. Declaration static member Sinh: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the hyperbolic sine of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# sinh function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = sinh a // b = [-2.30128; 0.0; 2.30128] See Also member FillSinh: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Sqrt.html": {
    "href": "api/Tensor.Tensor-1.Sqrt.html",
    "title": "Method Sqrt | Tensor for F#",
    "keywords": "Method Sqrt static member Sqrt: Tensor<'T> -> Tensor<'T> Element-wise square root. Declaration static member Sqrt: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the square root of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# sqrt function. Examples let a = HostTensor.ofList [1.0; 4.0; 16.0] let b = sqrt a // b = [1.0; 2.0; 4.0] See Also member FillSqrt: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.Tan.html": {
    "href": "api/Tensor.Tensor-1.Tan.html",
    "title": "Method Tan | Tensor for F#",
    "keywords": "Method Tan static member Tan: Tensor<'T> -> Tensor<'T> Element-wise tangent. Declaration static member Tan: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the tangent of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# tan function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = tan a // b = [-158057.9134; 0.0; 158057.9134] See Also member FillTan: Tensor<'T> -> unit static member Atan: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Tanh.html": {
    "href": "api/Tensor.Tensor-1.Tanh.html",
    "title": "Method Tanh | Tensor for F#",
    "keywords": "Method Tanh static member Tanh: Tensor<'T> -> Tensor<'T> Element-wise hyperbolic tangent. Declaration static member Tanh: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the hyperbolic tangent of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# tanh function. Examples let a = HostTensor.ofList [-1.57079; 0.0; 1.57079] let b = tanh a // b = [-0.91715; 0.0; 0.91715] See Also member FillTanh: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.ToString.html": {
    "href": "api/Tensor.Tensor-1.ToString.html",
    "title": "Method ToString | Tensor for F#",
    "keywords": "Method ToString member ToString: int64 -> string String representation of the tensor limited to a specific number of elements per dimension. Declaration member ToString: maxElems:int64 -> string Parameters Type Name Description int64 maxElems Maximum number of element per dimension to include in string representation. Returns Type Description string A (shortened) string representation of this tensor See Also member Full: unit -> string member Pretty: unit -> string override member ToString: unit -> string String representation of the tensor limited to 10 elements per dimension. Declaration override member ToString: unit -> string Returns Type Description string A (shortened) string representation of this tensor See Also member ToString: int64 -> string member Pretty: unit -> string member Full: unit -> string"
  },
  "api/Tensor.Tensor-1.TransferFrom.html": {
    "href": "api/Tensor.Tensor-1.TransferFrom.html",
    "title": "Method TransferFrom | Tensor for F#",
    "keywords": "Method TransferFrom member TransferFrom: Tensor<'T> -> unit Transfers the specified tensor located on another device into this tensor. Declaration member TransferFrom: src:Tensor<'T> -> unit Parameters Type Name Description Tensor <'T> src The tensor to transfer from. Remarks The elements of the original tensor are copied into the new tensor. Both tensors must have same shape and type. If both tensors are located on the same device, a copy is performed."
  },
  "api/Tensor.Tensor-1.Truncate.html": {
    "href": "api/Tensor.Tensor-1.Truncate.html",
    "title": "Method Truncate | Tensor for F#",
    "keywords": "Method Truncate static member Truncate: Tensor<'T> -> Tensor<'T> Element-wise truncation (rounding towards zero). Declaration static member Truncate: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the truncation (rounding towards zero) of each element of the specified tensor and returns them as a new tensor. Do not call this function directly; instead use the F# truncate function. Examples let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0] let b = truncate a // b = [-3.0; -2.0; 2.0; 3.0] See Also member FillTruncate: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.all.html": {
    "href": "api/Tensor.Tensor-1.all.html",
    "title": "Method all | Tensor for F#",
    "keywords": "Method all static member all: Tensor<bool> -> bool Checks if all elements of the tensor are true. Declaration static member all: src:Tensor<bool> -> bool Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description bool A scalar containing the result of this operation. Remarks It is checked whether all elements of the tensor are true. If so, true is returned; otherwise false is returned. If the tensor is empty true is returned. Examples let a = HostTensor.ofList2D [[true; true; true] [false; true; true]] let b = Tensor.all a // b = false See Also static member allTensor: Tensor<bool> -> Tensor<bool> static member allAxis: int -> Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.allAxis.html": {
    "href": "api/Tensor.Tensor-1.allAxis.html",
    "title": "Method allAxis | Tensor for F#",
    "keywords": "Method allAxis static member allAxis: int -> Tensor<bool> -> Tensor<bool> Checks if all elements along the specified axis are true. Declaration static member allAxis: ax:int -> src:Tensor<bool> -> Tensor<bool> Parameters Type Name Description int ax The axis to check along. Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks It is checked whether all elements along the specified axis are true. If so, true is returned; otherwise false is returned. If the tensor is empty true is returned. Examples let a = HostTensor.ofList2D [[true; true; true] [false; true; true]] let b = Tensor.allAxis 1 a // b = [true; false] See Also member FillAllAxis: int -> Tensor<bool> -> unit static member all: Tensor<bool> -> bool"
  },
  "api/Tensor.Tensor-1.allElems.html": {
    "href": "api/Tensor.Tensor-1.allElems.html",
    "title": "Method allElems | Tensor for F#",
    "keywords": "Method allElems static member allElems: Tensor<'T> -> seq<'T> Gets a sequence of all all elements within the tensor. Declaration static member allElems: a:Tensor<'T> -> seq<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description seq <'T> Sequence of elements. Remarks The sequence sequentially enumerates all elements of the tensor. See Also static member allIdx: Tensor<'T> -> seq<int64 list>"
  },
  "api/Tensor.Tensor-1.allFinite.html": {
    "href": "api/Tensor.Tensor-1.allFinite.html",
    "title": "Method allFinite | Tensor for F#",
    "keywords": "Method allFinite static member allFinite: Tensor<'T> -> bool Checks that all elements of the tensor are finite. Declaration static member allFinite: a:Tensor<'T> -> bool Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description bool true if all elements are finite, otherwise false. Remarks Checks each element of the specified tensor for finity (not -Inf, Inf or NaN)."
  },
  "api/Tensor.Tensor-1.allIdx.html": {
    "href": "api/Tensor.Tensor-1.allIdx.html",
    "title": "Method allIdx | Tensor for F#",
    "keywords": "Method allIdx static member allIdx: Tensor<'T> -> seq<int64 list> Gets a sequence of all indices to enumerate all elements within the tensor. Declaration static member allIdx: a:Tensor<'T> -> seq<int64 list> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description seq < int64 list > Sequence of indicies. Remarks The sequence sequentially enumerates the indices of all elements of the tensor. See Also allIdxOfDim static member allElems: Tensor<'T> -> seq<'T>"
  },
  "api/Tensor.Tensor-1.allTensor.html": {
    "href": "api/Tensor.Tensor-1.allTensor.html",
    "title": "Method allTensor | Tensor for F#",
    "keywords": "Method allTensor static member allTensor: Tensor<bool> -> Tensor<bool> Checks if all elements of the tensor are true returning the result as a tensor. Declaration static member allTensor: src:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member all: Tensor<bool> -> bool"
  },
  "api/Tensor.Tensor-1.almostEqual.html": {
    "href": "api/Tensor.Tensor-1.almostEqual.html",
    "title": "Method almostEqual | Tensor for F#",
    "keywords": "Method almostEqual static member almostEqual: Tensor<'T> * Tensor<'T> * 'T option * 'T option -> bool Checks if two tensors have the same (within machine precision) values in all elements. Declaration static member almostEqual: a:Tensor<'T> * b:Tensor<'T> * absTol:'T option * relTol:'T option -> bool Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. 'T option absTol The absolute tolerance. (default 1e-8) 'T option relTol The relative tolerance. (default 1e-5) Returns Type Description bool true if two tensors have same (within specified precision) values in all elements, otherwise false. Remarks Test each element of tensor a for being almost equal to the corresponding element of tensor b . For integer data types the check is exact. If tensors have different shape, then false is returned. The tensors a and b must have the same storage and type."
  },
  "api/Tensor.Tensor-1.any.html": {
    "href": "api/Tensor.Tensor-1.any.html",
    "title": "Method any | Tensor for F#",
    "keywords": "Method any static member any: Tensor<bool> -> bool Checks if any elements of the tensor are true. Declaration static member any: src:Tensor<bool> -> bool Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description bool A scalar containing the result of this operation. Remarks It is checked whether any element of the tensor is true. If so, true is returned; otherwise false is returned. If the tensor is empty false is returned. Examples let a = HostTensor.ofList2D [[true; true; true] [false; true; true]] let b = Tensor.any a // b = true See Also static member anyTensor: Tensor<bool> -> Tensor<bool> static member anyAxis: int -> Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.anyAxis.html": {
    "href": "api/Tensor.Tensor-1.anyAxis.html",
    "title": "Method anyAxis | Tensor for F#",
    "keywords": "Method anyAxis static member anyAxis: int -> Tensor<bool> -> Tensor<bool> Checks if any element along the specified axis is true. Declaration static member anyAxis: ax:int -> src:Tensor<bool> -> Tensor<bool> Parameters Type Name Description int ax The axis to check along. Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks It is checked whether any element along the specified axis is true. If so, true is returned; otherwise false is returned. If the tensor is empty false is returned. Examples let a = HostTensor.ofList2D [[true; true; true] [false; true; true]] let b = Tensor.anyAxis 1 a // b = [true; true] See Also member FillAnyAxis: int -> Tensor<bool> -> unit static member any: Tensor<bool> -> bool"
  },
  "api/Tensor.Tensor-1.anyTensor.html": {
    "href": "api/Tensor.Tensor-1.anyTensor.html",
    "title": "Method anyTensor | Tensor for F#",
    "keywords": "Method anyTensor static member anyTensor: Tensor<bool> -> Tensor<bool> Checks if any element of the tensor is true returning the result as a tensor. Declaration static member anyTensor: src:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member any: Tensor<bool> -> bool"
  },
  "api/Tensor.Tensor-1.arange.html": {
    "href": "api/Tensor.Tensor-1.arange.html",
    "title": "Method arange | Tensor for F#",
    "keywords": "Method arange static member arange: ITensorDevice -> 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. Declaration static member arange: dev:ITensorDevice -> start:'T -> incr:'T -> stop:'T -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. 'T start The starting value. 'T incr The increment between successive element. 'T stop The end value, which is not included. Returns Type Description Tensor <'T> The new tensor. Remarks A new vector with floor ((stop - start) / incr) elements is created on the specified device. The vector is filled with [start; start+1 incr; start+2 incr; ...] . If stop is smaller or equal to start, an empty vector is returned. Examples let a = Tensor.arange HostTensor.Dev 1.0 0.1 2.0 // a = [1.0; 1.1; 1.2; 1.3; 1.4; 1.5; 1.6; 1.7; 1.8; 1.9] See Also static member counting: ITensorDevice -> int64 -> Tensor<int64> val linspace: 'T -> 'T -> int64 -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.argMax.html": {
    "href": "api/Tensor.Tensor-1.argMax.html",
    "title": "Method argMax | Tensor for F#",
    "keywords": "Method argMax static member argMax: Tensor<'T> -> int64 list Finds the indicies of the maximum value of the tensor. Declaration static member argMax: a:Tensor<'T> -> int64 list Parameters Type Name Description Tensor <'T> a The tensor containing the source values. Returns Type Description int64 list The indices of the position of the maximum value. Remarks The maximum value within the specified tensor is found and its indicies are returned. The function fails for an empty tensor. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.argMax a // b = [1L; 3L] See Also static member argMaxAxis: int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.argMaxAxis.html": {
    "href": "api/Tensor.Tensor-1.argMaxAxis.html",
    "title": "Method argMaxAxis | Tensor for F#",
    "keywords": "Method argMaxAxis static member argMaxAxis: int -> Tensor<'T> -> Tensor<int64> Finds the index of the maximum value along the specified axis. Declaration static member argMaxAxis: ax:int -> src:Tensor<'T> -> Tensor<int64> Parameters Type Name Description int ax The axis to calculate the maximum along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor < int64 > A new tensor containing the result of this operation. Remarks The index of the maximum is calculated along the specified axis. An empty tensor gives val NotFound . Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.argMaxAxis 1 a // b = [3L; 3L] See Also member FillArgMaxAxis: int -> Tensor<'R> -> unit static member argMax: Tensor<'T> -> int64 list"
  },
  "api/Tensor.Tensor-1.argMin.html": {
    "href": "api/Tensor.Tensor-1.argMin.html",
    "title": "Method argMin | Tensor for F#",
    "keywords": "Method argMin static member argMin: Tensor<'T> -> int64 list Finds the indicies of the minimum value of the tensor. Declaration static member argMin: a:Tensor<'T> -> int64 list Parameters Type Name Description Tensor <'T> a The tensor containing the source values. Returns Type Description int64 list The indices of the position of the minimum value. Remarks The minimum value within the specified tensor is found and its indicies are returned. The function fails for an empty tensor. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.argMin 1 a // b = [0L; 0L] See Also static member argMinAxis: int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.argMinAxis.html": {
    "href": "api/Tensor.Tensor-1.argMinAxis.html",
    "title": "Method argMinAxis | Tensor for F#",
    "keywords": "Method argMinAxis static member argMinAxis: int -> Tensor<'T> -> Tensor<int64> Finds the index of the minimum value along the specified axis. Declaration static member argMinAxis: ax:int -> src:Tensor<'T> -> Tensor<int64> Parameters Type Name Description int ax The axis to calculate the minimum along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor < int64 > A new tensor containing the result of this operation. Remarks The index of the minimum is calculated along the specified axis. An empty tensor gives val NotFound . Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.argMinAxis 1 a // b = [0L; 0L] See Also member FillArgMinAxis: int -> Tensor<'R> -> unit static member argMin: Tensor<'T> -> int64 list"
  },
  "api/Tensor.Tensor-1.atLeast1D.html": {
    "href": "api/Tensor.Tensor-1.atLeast1D.html",
    "title": "Method atLeast1D | Tensor for F#",
    "keywords": "Method atLeast1D static member atLeast1D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least one dimension. Declaration static member atLeast1D: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor with at least one dimensions. See Also static member atLeastND: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.atLeast2D.html": {
    "href": "api/Tensor.Tensor-1.atLeast2D.html",
    "title": "Method atLeast2D | Tensor for F#",
    "keywords": "Method atLeast2D static member atLeast2D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least two dimensions. Declaration static member atLeast2D: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor with at least two dimensions. See Also static member atLeastND: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.atLeast3D.html": {
    "href": "api/Tensor.Tensor-1.atLeast3D.html",
    "title": "Method atLeast3D | Tensor for F#",
    "keywords": "Method atLeast3D static member atLeast3D: Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least three dimensions. Declaration static member atLeast3D: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor with at least three dimensions. See Also static member atLeastND: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.atLeastND.html": {
    "href": "api/Tensor.Tensor-1.atLeastND.html",
    "title": "Method atLeastND | Tensor for F#",
    "keywords": "Method atLeastND static member atLeastND: int -> Tensor<'T> -> Tensor<'T> Pads the tensor from the left with size-one dimensions until it has at least the specified number of dimensions. Declaration static member atLeastND: minDims:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int minDims The minimum number of dimensions. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor with at least minDims dimensions. Remarks Size-one dimensions are inserted at the front until the tensor has at least the specified number of dimensions. If it already has the specified number of dimensions or more, it is returned unchanged. A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [2L; 3L] let b = Tensor.atLeastND 5 a // b.Shape = [1L; 1L; 1L; 2L; 3L] See Also static member padLeft: Tensor<'T> -> Tensor<'T> static member reshape: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.broadcastDim.html": {
    "href": "api/Tensor.Tensor-1.broadcastDim.html",
    "title": "Method broadcastDim | Tensor for F#",
    "keywords": "Method broadcastDim static member broadcastDim: int -> int64 -> Tensor<'T> -> Tensor<'T> Broadcast a dimension to a specified size. Declaration static member broadcastDim: dim:int -> size:int64 -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int dim The size-one dimension to broadcast. int64 size The size to broadcast to. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The broadcasted dimension must be of size one. The tensor is repeated size times along the axis dim . Broadcasting is usually performed automatically when the shapes allow for it. See broadcasting rules for details. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 1L; 5L] let b = Tensor.broadCastDim 1 9L a // b.Shape = [3L; 9L; 5L] See Also static member insertAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.broadcastTo.html": {
    "href": "api/Tensor.Tensor-1.broadcastTo.html",
    "title": "Method broadcastTo | Tensor for F#",
    "keywords": "Method broadcastTo static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T> Broadcasts the specified tensor to the specified shape. Declaration static member broadcastTo: shp:int64 list -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int64 list shp The target shape. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> Tensor of shape shp . Remarks Size one dimensions are broadcasted to match the corresponding dimension of the target shape shp . Non-size-one dimensions must match the target shape. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [1L; 7L; 1L] let pa = Tensor.broadcastTo [2L; 7L; 3L] a // pa.Shape = [2L; 7L; 3L] Exceptions Type Condition System.InvalidOperationException Raised when broadcasting to the specified shape is impossible. See Also static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB>"
  },
  "api/Tensor.Tensor-1.broadcastToSame.html": {
    "href": "api/Tensor.Tensor-1.broadcastToSame.html",
    "title": "Method broadcastToSame | Tensor for F#",
    "keywords": "Method broadcastToSame static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Broadcasts all specified tensors to have the same shape. Declaration static member broadcastToSame: a:Tensor<'TA> * b:Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Parameters Type Name Description Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> A tuple of the resulting tensors, all having the same shape. Type Parameters Name Description 'TA 'TB Remarks First, size one dimensions are added from the left to each tensor until all of them have the same dimensionality. Then, size one dimensions are broadcasted to match the size of non-size-one dimensions. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [4L; 5L] let b = HostTensor.zeros [3L; 4L; 5L] let pa, pb = Tensor.broadcastToSame (a, b) // pa.Shape = [3L; 4L; 5L]; pb.Shape = [3L; 4L; 5L] Exceptions Type Condition System.InvalidOperationException Raised when broadcasting to a common shape is impossible. See Also static member padToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T> static member broadcastToSame: Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Broadcasts all specified tensors to have the same shape. Declaration static member broadcastToSame: a:Tensor<'TA> * b:Tensor<'TB> * c:Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Parameters Type Name Description Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Tensor <'TC> c The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> * Tensor <'TC> A tuple of the resulting tensors, all having the same shape. Type Parameters Name Description 'TA 'TB 'TC See Also static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastToSame: Tensor<'T> list -> Tensor<'T> list Broadcasts all specified tensors to have the same shape. Declaration static member broadcastToSame: xs:Tensor<'T> list -> Tensor<'T> list Parameters Type Name Description Tensor <'T> list xs A list of tensors to operate on. Returns Type Description Tensor <'T> list A list of the resulting tensors, all having the same shape. See Also static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB>"
  },
  "api/Tensor.Tensor-1.broadcastToSameInDims.html": {
    "href": "api/Tensor.Tensor-1.broadcastToSameInDims.html",
    "title": "Method broadcastToSameInDims | Tensor for F#",
    "keywords": "Method broadcastToSameInDims static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Broadcasts all specified tensors to have the same size in the specified dimensions. Declaration static member broadcastToSameInDims: dims:seq<int> * a:Tensor<'TA> * b:Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Parameters Type Name Description seq < int > dims A list of dimensions that should be broadcasted to have the same size. Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> A tuple of the resulting tensors, all having the same size in the specified dimensions. Type Parameters Name Description 'TA 'TB Remarks The specified dimensions are broadcasted to match the size of non-size-one dimensions. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [1L; 7L; 1L] let b = HostTensor.zeros [3L; 4L; 5L] let pa, pb = Tensor.broadcastToSameInDims ([0; 2], a, b) // pa.Shape = [3L; 7L; 5L]; pb.Shape = [3L; 4L; 5L] Exceptions Type Condition System.InvalidOperationException Raised when broadcasting to a common shape is impossible. See Also static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T> static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Broadcasts all specified tensors to have the same size in the specified dimensions. Declaration static member broadcastToSameInDims: dims:seq<int> * a:Tensor<'TA> * b:Tensor<'TB> * c:Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Parameters Type Name Description seq < int > dims A list of dimensions that should be broadcasted to have the same size. Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Tensor <'TC> c The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> * Tensor <'TC> A tuple of the resulting tensors, all having the same size in the specified dimensions. Type Parameters Name Description 'TA 'TB 'TC See Also static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastToSameInDims: seq<int> * Tensor<'T> list -> Tensor<'T> list Broadcasts all specified tensors to have the same size in the specified dimensions. Declaration static member broadcastToSameInDims: dims:seq<int> * xs:Tensor<'T> list -> Tensor<'T> list Parameters Type Name Description seq < int > dims A list of dimensions that should be broadcasted to have the same size. Tensor <'T> list xs A list of tensors to operate on. Returns Type Description Tensor <'T> list A list of the resulting tensors, all having the same size in the specified dimensions. See Also static member broadcastToSameInDims: seq<int> * Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB>"
  },
  "api/Tensor.Tensor-1.concat.html": {
    "href": "api/Tensor.Tensor-1.concat.html",
    "title": "Method concat | Tensor for F#",
    "keywords": "Method concat static member concat: int -> seq<Tensor<'T>> -> Tensor<'T> Concatenates tensors along an axis. Declaration static member concat: ax:int -> ts:seq<Tensor<'T>> -> Tensor<'T> Parameters Type Name Description int ax The concatenation axis. seq < Tensor <'T>> ts Sequence of tensors to concatenate. Returns Type Description Tensor <'T> The concatenated tensor. Remarks The contents of a the tensors are concatenated in the specifed dimension. The sizes of the tensors in all other dimensions must be equal. Examples let a = HostTensor.zeros [4L; 28L] let b = HostTensor.zeros [4L; 15L] let c = HostTensor.zeros [4L; 10L] let d = Tensor.concat 1 [a; b; c] // d.Shape = [4L; 53L] See Also static member ofBlocks: BlockTensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.convert.html": {
    "href": "api/Tensor.Tensor-1.convert.html",
    "title": "Method convert | Tensor for F#",
    "keywords": "Method convert static member convert: Tensor<'C> -> Tensor<'T> Convert the elements of a tensor to the specifed type. Declaration static member convert: a:Tensor<'C> -> Tensor<'T> Parameters Type Name Description Tensor <'C> a The tensor to convert. Returns Type Description Tensor <'T> A tensor of the new data type. Type Parameters Name Description 'C The data type to convert from. Remarks The elements of the original tensor are copied into the new tensor and their type is converted during the copy. For tensors that contain data of non-primitive types and are stored on the host, the op_Explicit or op_Implicit methods of the source or destination type are used to perform the conversion. Examples let a = HostTensor.ofList [1; 2; 3] let b = Tensor<float>.convert a // b = [1.0; 2.0; 3.0] See Also member FillConvert: Tensor<'C> -> unit"
  },
  "api/Tensor.Tensor-1.copy.html": {
    "href": "api/Tensor.Tensor-1.copy.html",
    "title": "Method copy | Tensor for F#",
    "keywords": "Method copy static member copy: Tensor<'T> * TensorOrder option -> Tensor<'T> Returns a copy of the tensor. Declaration static member copy: a:Tensor<'T> * order:TensorOrder option -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to copy. TensorOrder option order The memory layout of the copy. (default: row-major) Returns Type Description Tensor <'T> A copy of the tensor. Remarks A new tensor is created with the specified memory layout on the same device as the orignal tensor. The elements of the original tensor are copied into the new tensor. See Also member CopyFrom: Tensor<'T> -> unit val transfer: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.countTrue.html": {
    "href": "api/Tensor.Tensor-1.countTrue.html",
    "title": "Method countTrue | Tensor for F#",
    "keywords": "Method countTrue static member countTrue: Tensor<bool> -> int64 Counts the elements being true. Declaration static member countTrue: src:Tensor<bool> -> int64 Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description int64 A scalar containing the result of this operation. Remarks The number of elements that are true is counted and returned as a scalar. Examples let a = HostTensor.ofList2D [[true; false; true; false] [false; true; true; false]] let b = Tensor.countTrue a // b = 4L See Also static member countTrueTensor: Tensor<bool> -> Tensor<int64> static member countTrueAxis: int -> Tensor<bool> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.countTrueAxis.html": {
    "href": "api/Tensor.Tensor-1.countTrueAxis.html",
    "title": "Method countTrueAxis | Tensor for F#",
    "keywords": "Method countTrueAxis static member countTrueAxis: int -> Tensor<bool> -> Tensor<int64> Counts the elements being true along the specified axis. Declaration static member countTrueAxis: ax:int -> src:Tensor<bool> -> Tensor<int64> Parameters Type Name Description int ax The axis the count along. Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < int64 > A new tensor containing the result of this operation. Remarks The number of elements that are true is accumulated along the specified axis. Examples let a = HostTensor.ofList2D [[true; false; true; false] [false; true; true; false]] let b = Tensor.countTrueAxis 1 a // b = [2L; 2L] See Also member FillCountTrueAxis: int -> Tensor<bool> -> unit static member countTrue: Tensor<bool> -> int64"
  },
  "api/Tensor.Tensor-1.countTrueTensor.html": {
    "href": "api/Tensor.Tensor-1.countTrueTensor.html",
    "title": "Method countTrueTensor | Tensor for F#",
    "keywords": "Method countTrueTensor static member countTrueTensor: Tensor<bool> -> Tensor<int64> Counts the elements being true returning the result as a Tensor. Declaration static member countTrueTensor: src:Tensor<bool> -> Tensor<int64> Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < int64 > A new scalar tensor containing the result of this operation. See Also static member countTrue: Tensor<bool> -> int64"
  },
  "api/Tensor.Tensor-1.counting.html": {
    "href": "api/Tensor.Tensor-1.counting.html",
    "title": "Method counting | Tensor for F#",
    "keywords": "Method counting static member counting: ITensorDevice -> int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. Declaration static member counting: dev:ITensorDevice -> nElems:int64 -> Tensor<int64> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 nElems The number of elements of the new vector. Returns Type Description Tensor < int64 > The new tensor. Remarks A new vector with the specified number of elements is created on the specified device. The tensor is filled with [0L; 1L; 2L; ...; nElems-1L] . Examples let a = Tensor.counting HostTensor.Dev 5L // a = [0L; 1L; 2L; 3L; 4L] See Also val arange: 'T -> 'T -> 'T -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.cutLeft.html": {
    "href": "api/Tensor.Tensor-1.cutLeft.html",
    "title": "Method cutLeft | Tensor for F#",
    "keywords": "Method cutLeft static member cutLeft: Tensor<'T> -> Tensor<'T> Removes the first dimension. Declaration static member cutLeft: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 4L; 5L] let b = Tensor.cutLeft a // b.Shape = [4L; 5L] See Also static member cutRight: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.cutRight.html": {
    "href": "api/Tensor.Tensor-1.cutRight.html",
    "title": "Method cutRight | Tensor for F#",
    "keywords": "Method cutRight static member cutRight: Tensor<'T> -> Tensor<'T> Removes the last dimension. Declaration static member cutRight: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 4L; 5L] let b = Tensor.cutRight a // b.Shape = [3L; 4L] See Also static member cutLeft: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.dataType.html": {
    "href": "api/Tensor.Tensor-1.dataType.html",
    "title": "Method dataType | Tensor for F#",
    "keywords": "Method dataType static member dataType: Tensor<'T> -> Type Type of data stored within the tensor. Declaration static member dataType: a:Tensor<'T> -> Type Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description System.Type Data type. See Also member DataType: unit -> Type"
  },
  "api/Tensor.Tensor-1.dev.html": {
    "href": "api/Tensor.Tensor-1.dev.html",
    "title": "Method dev | Tensor for F#",
    "keywords": "Method dev static member dev: Tensor<'T> -> ITensorDevice Device the data of tensor is stored on. Declaration static member dev: a:Tensor<'T> -> ITensorDevice Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description ITensorDevice Data storage device. See Also member Dev: unit -> ITensorDevice val transfer: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diag.html": {
    "href": "api/Tensor.Tensor-1.diag.html",
    "title": "Method diag | Tensor for F#",
    "keywords": "Method diag static member diag: Tensor<'T> -> Tensor<'T> Returns a view of the diagonal of the matrix. Declaration static member diag: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a A square matrix. Returns Type Description Tensor <'T> The diagonal vector. Remarks The matrix must be square. If the specified tensor has more than two dimensions, the diagonals along the last two dimensions are returned as a tensor. A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [3L; 3L] let b = Tensor.diag a // b.Shape = [3L] See Also static member diagAxis: int -> int -> Tensor<'T> -> Tensor<'T> static member diagMat: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diagAxis.html": {
    "href": "api/Tensor.Tensor-1.diagAxis.html",
    "title": "Method diagAxis | Tensor for F#",
    "keywords": "Method diagAxis static member diagAxis: int -> int -> Tensor<'T> -> Tensor<'T> Returns a view of the diagonal along the given axes. Declaration static member diagAxis: ax1:int -> ax2:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax1 The first dimension of the diagonal. int ax2 The seconds dimension of the diagonal. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor where dimension ax1 is the diagonal and dimension ax2 is removed. Remarks The dimensions specified by ax1 and ax2 must have the same size. A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [4L; 3L; 3L; 5L] let b = Tensor.diagAxis 1 2 a // b.Shape = [4L; 3L; 5L] See Also static member diag: Tensor<'T> -> Tensor<'T> static member diagMatAxis: int -> int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diagMat.html": {
    "href": "api/Tensor.Tensor-1.diagMat.html",
    "title": "Method diagMat | Tensor for F#",
    "keywords": "Method diagMat static member diagMat: Tensor<'T> -> Tensor<'T> Creates a matrix with the specified diagonal. Declaration static member diagMat: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The vector containing the values for the diagonal. Returns Type Description Tensor <'T> A matrix having the values a on its diagonal. Remarks A square matrix with the same size as a is created. The diagonal is filled with the elements of vector a . The other elements are set to zero. If the specified tensor has more than one dimension, the operation is performed batch-wise on the last dimension. Examples let a = HostTensor.zeros [5L] let b = Tensor.diag a // b.Shape = [5L; 5L] See Also static member diagMatAxis: int -> int -> Tensor<'T> -> Tensor<'T> static member diag: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diagMatAxis.html": {
    "href": "api/Tensor.Tensor-1.diagMatAxis.html",
    "title": "Method diagMatAxis | Tensor for F#",
    "keywords": "Method diagMatAxis static member diagMatAxis: int -> int -> Tensor<'T> -> Tensor<'T> Creates a tensor with the specified diagonal along the given axes. Declaration static member diagMatAxis: ax1:int -> ax2:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax1 The first dimension of the diagonal. int ax2 The seconds dimension of the diagonal. Tensor <'T> a The values for the diagonal. Returns Type Description Tensor <'T> A tensor having the values a on the diagonal specified by the axes ax1 and ax2 . Remarks A new tensor with the same shape as a but with axis ax2 inserted is created. The size of axis ax2 is set to the size of axis ax1 . The diagonal over axes ax1 and ax2 is filled with the elements of tensor a . The other elements are set to zero. Examples let a = HostTensor.zeros [4L; 3L] let b = Tensor.diagMatAxis 0 1 a // b.Shape = [4L; 4L; 3L] See Also static member diagMat: Tensor<'T> -> Tensor<'T> static member diagAxis: int -> int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diff.html": {
    "href": "api/Tensor.Tensor-1.diff.html",
    "title": "Method diff | Tensor for F#",
    "keywords": "Method diff static member diff: Tensor<'T> -> Tensor<'T> Calculates the difference between adjoining elements of the vector. Declaration static member diff: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The vector containing the source values. Returns Type Description Tensor <'T> The differences vector. It has one element less than the input tensor. Remarks The value of output element i is given by d_i = a_(i+1) - a_i . The resulting vector has one element less in the last dimension than the original vector. If the input tensor has more than one dimension, this operation is applied batch-wise on the last dimension. Examples let a = HostTensor.zeros [5L] let b = Tensor.diff a // b.Shape = [4L] See Also static member diffAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.diffAxis.html": {
    "href": "api/Tensor.Tensor-1.diffAxis.html",
    "title": "Method diffAxis | Tensor for F#",
    "keywords": "Method diffAxis static member diffAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the difference between adjoining elements along the specified axes. Declaration static member diffAxis: ax:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to operate along. Tensor <'T> a The tensor containing the source values. Returns Type Description Tensor <'T> The differences tensor. It has one element less in dimension ax as the input tensor. Remarks The resulting tensor has one element less in the differentiation dimension than the original tensor. Examples let a = HostTensor.zeros [10L; 5L] let b = Tensor.diffAxis 0 a // b.Shape = [9L; 5L] See Also static member diff: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.dot.html": {
    "href": "api/Tensor.Tensor-1.dot.html",
    "title": "Method dot | Tensor for F#",
    "keywords": "Method dot static member dot: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Computes the (batched) matrix product, (batched) matrix-vector product or scalar product. Declaration static member dot: a:Tensor<'T> -> b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( .* ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.empty.html": {
    "href": "api/Tensor.Tensor-1.empty.html",
    "title": "Method empty | Tensor for F#",
    "keywords": "Method empty static member empty: ITensorDevice -> int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. Declaration static member empty: dev:ITensorDevice -> nDims:int -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int nDims The number of dimensions of the new, empty tensor. Returns Type Description Tensor <'T> The new, empty tensor. Remarks The shape of the tensor is [0L; ...; 0L] . It contains no elements."
  },
  "api/Tensor.Tensor-1.falses.html": {
    "href": "api/Tensor.Tensor-1.falses.html",
    "title": "Method falses | Tensor for F#",
    "keywords": "Method falses static member falses: ITensorDevice -> int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. Declaration static member falses: dev:ITensorDevice -> shape:int64 list -> Tensor<bool> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. Remarks A new tensor of the specified shape is created on the specified device. The tensor is filled with falses. Examples let a = Tensor.falses HostTensor.Dev [2L; 3L] // a = [[false; false; false] // [false; false; false]] See Also static member trues: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.filled.html": {
    "href": "api/Tensor.Tensor-1.filled.html",
    "title": "Method filled | Tensor for F#",
    "keywords": "Method filled static member filled: ITensorDevice -> int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. Declaration static member filled: dev:ITensorDevice -> shape:int64 list -> value:'T -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 list shape The shape of the new tensor. 'T value The value to fill the new tensor with. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor of the specified shape is created on the specified device. The tensor is filled with the specified value. Examples let a = Tensor.filled HostTensor.Dev [2L; 3L] 1.5 // a = [[1.5; 1.5; 1.5] // [1.5; 1.5; 1.5]] See Also member FillConst: 'T -> unit"
  },
  "api/Tensor.Tensor-1.find.html": {
    "href": "api/Tensor.Tensor-1.find.html",
    "title": "Method find | Tensor for F#",
    "keywords": "Method find static member find: 'T -> Tensor<'T> -> int64 list Finds the first occurence of the specfied value and returns its indices. Declaration static member find: value:'T -> a:Tensor<'T> -> int64 list Parameters Type Name Description 'T value The value to find. Tensor <'T> a The tensor containing the source values. Returns Type Description int64 list The indices of the value. Remarks The values is searched for an the index of the first occurence is returned. If the value is not found, an System.InvalidOperationException is raised. Use static member tryFind: 'T -> Tensor<'T> -> int64 list option instead, if the value might not be present. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 3.0]] let b = Tensor.find 3.0 a // b = [0L; 2L] Exceptions Type Condition System.InvalidOperationException Raised if value is not found. See Also static member tryFind: 'T -> Tensor<'T> -> int64 list option static member findAxis: 'T -> int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.findAxis.html": {
    "href": "api/Tensor.Tensor-1.findAxis.html",
    "title": "Method findAxis | Tensor for F#",
    "keywords": "Method findAxis static member findAxis: 'T -> int -> Tensor<'T> -> Tensor<int64> Finds the first occurence of the specfied value along the specified axis and returns its index. Declaration static member findAxis: value:'T -> ax:int -> src:Tensor<'T> -> Tensor<int64> Parameters Type Name Description 'T value The value to find. int ax The axis to find the value along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor < int64 > A new tensor containing the indices of the first occurence of value . Remarks The values is searched for an the index of the first occurence is returned. If the value is not found val NotFound is returned instead. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 3.0]] let b = Tensor.findAxis 3.0 1 a // b = [2L; 3L] See Also member FillFindAxis: 'R -> int -> Tensor<'R> -> unit"
  },
  "api/Tensor.Tensor-1.flatten.html": {
    "href": "api/Tensor.Tensor-1.flatten.html",
    "title": "Method flatten | Tensor for F#",
    "keywords": "Method flatten static member flatten: Tensor<'T> -> Tensor<'T> Flattens the tensor into a (one-dimensional) vector. Declaration static member flatten: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A vector. Remarks If a reshape is possible without copying the data of the tensor, a view of the original tensor is returned and the storage is shared. In this case, modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [2L; 3L; 4L] let b = Tensor.flatten a // b.Shape = [24L] See Also static member reshape: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.gather.html": {
    "href": "api/Tensor.Tensor-1.gather.html",
    "title": "Method gather | Tensor for F#",
    "keywords": "Method gather static member gather: Tensor<int64> option list -> Tensor<'T> -> Tensor<'T> Selects elements from a tensor according to specified indices. Declaration static member gather: indices:Tensor<int64> option list -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor < int64 > option list indices A list of tensors, one per dimension of src , containing the indicies to pick from src for each output element. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> Result with the shape of the (broadcasted) tensors specified in indices . Remarks The output element with indices [i_0; i_1; i_2; ...] is given by the source element with indices [j_0; j_1; j_2; ...] , where each index j_k is given by j_k = indices.[k].[i_0; i_1; i_2; ...] . If indices.[k] is None , then j_k = i_k is assumed instead. Index dimensions beyond the number of target dimensions must not be None . The tensors indices and src must have the same storage. All index tensors are broadcasted to the same size. Examples let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3] [1.0; 1.1; 1.2; 1.3] [2.0; 2.1; 2.2; 2.3]] let i0 = HostTensor.ofList [1L; 2L; 0L; 0L] let i1 = HostTensor.ofList [3L; 1L; 0L; 3L] let g = Tensor.gather [Some i0; Some i1] src // g = [1.3000 2.1000 0.0000 0.3000] // Using None instead of an index tensor. let j1 = HostTensor.ofList [3L; 1L; 0L] let g2 = Tensor.gather [None; Some j1] src // g2 = [0.3000 1.1000 2.0000] See Also member FillGather: Tensor<int64> option list -> Tensor<'T> -> unit static member scatter: Tensor<int64> option list -> int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.get.html": {
    "href": "api/Tensor.Tensor-1.get.html",
    "title": "Method get | Tensor for F#",
    "keywords": "Method get static member get: Tensor<'T> -> int64 list -> 'T Gets the value of a single element of the tensor. Declaration static member get: a:Tensor<'T> -> pos:int64 list -> 'T Parameters Type Name Description Tensor <'T> a The tensor to read from. int64 list pos A list consisting of the indicies of the element to access. The list must have one entry per dimension of this tensor. Returns Type Description 'T The value of the selected element. See Also member Item: int64 list -> 'T"
  },
  "api/Tensor.Tensor-1.identity.html": {
    "href": "api/Tensor.Tensor-1.identity.html",
    "title": "Method identity | Tensor for F#",
    "keywords": "Method identity static member identity: ITensorDevice -> int64 -> Tensor<'T> Creates a new identity matrix. Declaration static member identity: dev:ITensorDevice -> size:int64 -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the matrix on. int64 size The size of the square identity matrix. Returns Type Description Tensor <'T> The new tensor. Remarks A new square matrix of the specified size is created on the specified device. The tensor is filled with ones on the diagonal and zeros elsewhere. Examples let a = Tensor<float>.identity HostTensor.Dev 3L // a = [[1.0; 0.0; 0.0] // [0.0; 1.0; 0.0] // [0.0; 0.0; 1.0]]"
  },
  "api/Tensor.Tensor-1.ifThenElse.html": {
    "href": "api/Tensor.Tensor-1.ifThenElse.html",
    "title": "Method ifThenElse | Tensor for F#",
    "keywords": "Method ifThenElse static member ifThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise choice between two sources depending on a condition. Declaration static member ifThenElse: cond:Tensor<bool> -> ifTrue:Tensor<'T> -> ifFalse:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor < bool > cond The condition tensor. Tensor <'T> ifTrue The tensor containing the values to use for when an element of the condition is true. Tensor <'T> ifFalse The tensor containing the values to use for when an element of the condition is false. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Evaluates each element of tensor cond . If it evaluates to true, the corresponding element of tensor ifTrue is written into the result. Otherwise, the corresponding element of tensor ifFalse is written into the result. The tensors cond , ifTrue and ifFalse must have the same storage. Broadcasting rules apply if cond , ifTrue and ifFalse have different shapes. Examples let cond = HostTensor.ofList [true; false; false] let ifTrue = HostTensor.ofList [2.0; 3.0; 4.0] let ifFalse = HostTensor.ofList [5.0; 6.0; 7.0] let target = Tensor.ifThenElse cond ifTrue ifFalse // target = [2.0; 6.0; 7.0] See Also member FillIfThenElse: Tensor<bool> -> Tensor<'T> -> Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.insertAxis.html": {
    "href": "api/Tensor.Tensor-1.insertAxis.html",
    "title": "Method insertAxis | Tensor for F#",
    "keywords": "Method insertAxis static member insertAxis: int -> Tensor<'T> -> Tensor<'T> Insert a dimension of size one before the specifed dimension. Declaration static member insertAxis: ax:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The dimension to insert before. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 4L; 5L] let b = Tensor.insertAxis 1 a // b.Shape = [3L; 1L 4L; 5L] See Also static member padLeft: Tensor<'T> -> Tensor<'T> static member padRight: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.invert.html": {
    "href": "api/Tensor.Tensor-1.invert.html",
    "title": "Method invert | Tensor for F#",
    "keywords": "Method invert static member invert: Tensor<'T> -> Tensor<'T> (Batch) inverts a matrix. Declaration static member invert: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. Returns Type Description Tensor <'T> A new matrix or tensor containing the result of this operation. Remarks If a is a square matrix, its inverse is computed. The result is a matrix. If a is a tensor of shape [b_1; ...; b_n; i; i] , the inverse of all square matrices consisting of the last two dimensions of the tensor are computed. The result is a tensor of same shape. If the matrix is not invertible a SingularMatrixException is raised. Use static member pseudoInvert: Tensor<'T> * 'T option -> Tensor<'T> for such matrices instead. Examples let a = HostTensor.ofList [[1.0; 2.0] [3.0; 4.0]] let c = Tensor.invert a // c = [[-2.0; 1.0] // [1.5; -0.5]] Exceptions Type Condition SingularMatrixException Raised when the matrix is not invertible. See Also member FillInvert: Tensor<'T> -> unit static member pseudoInvert: Tensor<'T> * 'T option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.isBroadcasted.html": {
    "href": "api/Tensor.Tensor-1.isBroadcasted.html",
    "title": "Method isBroadcasted | Tensor for F#",
    "keywords": "Method isBroadcasted static member isBroadcasted: Tensor<'T> -> bool Checks if the specified tensor is broadcasted in at least one dimension. Declaration static member isBroadcasted: a:Tensor<'T> -> bool Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description bool true if at least one dimension is broadcasted, otherwise false. Remarks If any stride is zero, it is assumed that the tensor is broadcasted. If this is the case, changing an element of the tensor may change other elements as well. See Also static member broadcastToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.isClose.html": {
    "href": "api/Tensor.Tensor-1.isClose.html",
    "title": "Method isClose | Tensor for F#",
    "keywords": "Method isClose static member isClose: Tensor<'T> * Tensor<'T> * 'T option * 'T option -> Tensor<bool> Element-wise check if two tensors have same (within machine precision) values. Declaration static member isClose: a:Tensor<'T> * b:Tensor<'T> * absTol:'T option * relTol:'T option -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. 'T option absTol The absolute tolerance. (default 1e-8) 'T option relTol The relative tolerance. (default 1e-5) Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being almost equal to the corresponding element of tensor b and returns the results as a new tensor. For integer data types the check is exact. The tensors a and b must have the same storage and type."
  },
  "api/Tensor.Tensor-1.isFinite.html": {
    "href": "api/Tensor.Tensor-1.isFinite.html",
    "title": "Method isFinite | Tensor for F#",
    "keywords": "Method isFinite static member isFinite: Tensor<'T> -> Tensor<bool> Element-wise finity check (not -Inf, Inf or NaN). Declaration static member isFinite: a:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor to apply this operation to. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Checks each element of the specified tensor for finity (not -Inf, Inf or NaN) and returns the results as a new tensor of type bool . Examples let a = HostTensor.ofList [-infinity; -3.0; nan; 3.0; infinity] let b = isFinite a // b = [false; true; false; true; false] See Also member FillIsFinite: Tensor<'R> -> unit"
  },
  "api/Tensor.Tensor-1.ofBlocks.html": {
    "href": "api/Tensor.Tensor-1.ofBlocks.html",
    "title": "Method ofBlocks | Tensor for F#",
    "keywords": "Method ofBlocks static member ofBlocks: BlockTensor<'T> -> Tensor<'T> Builds a tensor out of tensor blocks. Declaration static member ofBlocks: bs:BlockTensor<'T> -> Tensor<'T> Parameters Type Name Description BlockTensor <'T> bs The block tensor specification. Returns Type Description Tensor <'T> The resulting tensor. Remarks The contents of a sub-block are jointed along the dimension determined by its nesting level, i.e. a sub-block nested n levels within other sub-blocks will be concatenated along dimension n . The contents of a sub-block must have equal sizes in all dimensions except for the concatenation dimensions. Examples // Consider a block matrix of the follow structure. // +-----------------------------+---------------+ // | | | // | | | // | b1 | b2 | // | (5 x 28) | (5 x 15) | // | | | // +---------------------+-------+-------+-------+ // | | | | // | b3 | b4 | b5 | // | (3 x 22) | (3 x 14) |(3 x 7)| // +---------------------+---------------+-------+ // // It can be specified as follows. let b1 = HostTensor.zeros [5L; 28L] let b2 = HostTensor.zeros [5L; 15L] let b3 = HostTensor.zeros [3L; 22L] let b4 = HostTensor.zeros [3L; 14L] let b5 = HostTensor.zeros [3L; 7L] let r1 = SubBlocks [Block b1; Block b2] let r2 = SubBlocks [Block b3; Block b4; Block b5] let a = Tensor.ofBlocks (SubBlocks [r1; r2]) // a.Shape = [8L; 43L] See Also static member concat: int -> seq<Tensor<'T>> -> Tensor<'T> static member ofBlocks: Tensor<'T> list -> Tensor<'T> Builds a vector out of vectors blocks. Declaration static member ofBlocks: bs:Tensor<'T> list -> Tensor<'T> Parameters Type Name Description Tensor <'T> list bs The block vector specification. Returns Type Description Tensor <'T> The resulting vector. Remarks The contents of a the vectors are concatenated. Examples // Consider a block vector of the follow structure. // +-----------------------------+---------------+ // | b1 (28) | b2 (15) | // +-----------------------------+---------------+ // // It can be specified as follows. let b1 = HostTensor.zeros [28L] let b2 = HostTensor.zeros [15L] let a = Tensor.ofBlocks [b1; b2] // a.Shape = [43L] static member ofBlocks: Tensor<'T> list list -> Tensor<'T> Builds a matrix out of matrix blocks. Declaration static member ofBlocks: bs:Tensor<'T> list list -> Tensor<'T> Parameters Type Name Description Tensor <'T> list list bs The matrix blocks. Returns Type Description Tensor <'T> The resulting matrix. Remarks The contents of each list are jointed along the dimension determined by its nesting level, i.e. the elements of the outer lists are concatenated along dimension zero (rows) and the elements of the inner lists are concatenated along dimension one (columns). The contents of a list must have equal sizes in all dimensions except for the concatenation dimensions. Examples // Consider a block matrix of the follow structure. // +-----------------------------+---------------+ // | | | // | | | // | b1 | b2 | // | (5 x 28) | (5 x 15) | // | | | // +---------------------+-------+-------+-------+ // | | | | // | b3 | b4 | b5 | // | (3 x 22) | (3 x 14) |(3 x 7)| // +---------------------+---------------+-------+ // // It can be specified as follows. let b1 = HostTensor.zeros [5L; 28L] let b2 = HostTensor.zeros [5L; 15L] let b3 = HostTensor.zeros [3L; 22L] let b4 = HostTensor.zeros [3L; 14L] let b5 = HostTensor.zeros [3L; 7L] let bs = [[b1; b2 ] [b3; b4; b5]] let a = Tensor.ofBlocks bs // a.Shape = [8L; 43L] static member ofBlocks: Tensor<'T> list list list -> Tensor<'T> Builds a three dimensional tensor out of tensor blocks. Declaration static member ofBlocks: bs:Tensor<'T> list list list -> Tensor<'T> Parameters Type Name Description Tensor <'T> list list list bs The tensor blocks. Returns Type Description Tensor <'T> The resulting tensor. Remarks The contents of each list are jointed along the dimension determined by its nesting level, i.e. the elements of the outer-most lists are concatenated along dimension zero and the elements of the middle lists are concatenated along dimension one and the elements of the inner-most lists are concatenated along dimension two. The contents of a list must have equal sizes in all dimensions except for the concatenation dimensions."
  },
  "api/Tensor.Tensor-1.ones.html": {
    "href": "api/Tensor.Tensor-1.ones.html",
    "title": "Method ones | Tensor for F#",
    "keywords": "Method ones static member ones: ITensorDevice -> int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). Declaration static member ones: dev:ITensorDevice -> shape:int64 list -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor of the specified shape is created on the specified device. The tensor is filled with ones. Examples let a = Tensor<float>.ones HostTensor.Dev [2L; 3L] // a = [[1.0; 1.0; 1.0] // [1.0; 1.0; 1.0]] See Also static member onesLike: Tensor<'T> -> Tensor<'T> static member zeros: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.onesLike.html": {
    "href": "api/Tensor.Tensor-1.onesLike.html",
    "title": "Method onesLike | Tensor for F#",
    "keywords": "Method onesLike static member onesLike: Tensor<'T> -> Tensor<'T> Creates a new tensor filled with ones using the specified tensor as template. Declaration static member onesLike: tmpl:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> tmpl The template tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor is created with the same shape and on the same device as tmpl . The tensor is filled with ones. See Also static member ones: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_Addition.html": {
    "href": "api/Tensor.Tensor-1.op_Addition.html",
    "title": "Operator ( + ) | Tensor for F#",
    "keywords": "Operator ( + ) static member ( + ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise addition. Declaration static member ( + ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Adds each element of tensor a to the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a + b // c = [7.0; 9.0; 11.0] See Also member FillAdd: Tensor<'T> -> Tensor<'T> -> unit static member ( + ): Tensor<'T> * 'T -> Tensor<'T> Element-wise addition with scalar. Declaration static member ( + ): a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( + ): Tensor<'T> * Tensor<'T> -> Tensor<'T> static member ( + ): 'T * Tensor<'T> -> Tensor<'T> Element-wise addition with scalar. Declaration static member ( + ): a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( + ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_AmpAmpAmpAmp.html": {
    "href": "api/Tensor.Tensor-1.op_AmpAmpAmpAmp.html",
    "title": "Operator ( &&&& ) | Tensor for F#",
    "keywords": "Operator ( &&&& ) static member ( &&&& ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal and. Declaration static member ( &&&& ): a:Tensor<bool> * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Computes the logical and of each element of tensor a with the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [true; true; false; false] let b = HostTensor.ofList [true; false; true; false] let c = a &&&& b // c = [true; false; false; false] See Also member FillAnd: Tensor<bool> -> Tensor<bool> -> unit static member ( &&&& ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal and with scalar. Declaration static member ( &&&& ): a:Tensor<bool> * b:bool -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. bool b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( &&&& ): Tensor<bool> * Tensor<bool> -> Tensor<bool> static member ( &&&& ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal and with scalar. Declaration static member ( &&&& ): a:bool * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description bool a The scalar on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( &&&& ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_BarBarBarBar.html": {
    "href": "api/Tensor.Tensor-1.op_BarBarBarBar.html",
    "title": "Operator ( |||| ) | Tensor for F#",
    "keywords": "Operator ( |||| ) static member ( |||| ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal or. Declaration static member ( |||| ): a:Tensor<bool> * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Computes the logical or of each element of tensor a with the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [true; true; false; false] let b = HostTensor.ofList [true; false; true; false] let c = a |||| b // c = [true; true; true; false] See Also member FillOr: Tensor<bool> -> Tensor<bool> -> unit static member ( |||| ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal or with scalar. Declaration static member ( |||| ): a:Tensor<bool> * b:bool -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. bool b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( |||| ): Tensor<bool> * Tensor<bool> -> Tensor<bool> static member ( |||| ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal or with scalar. Declaration static member ( |||| ): a:bool * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description bool a The scalar on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( |||| ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_Division.html": {
    "href": "api/Tensor.Tensor-1.op_Division.html",
    "title": "Operator ( / ) | Tensor for F#",
    "keywords": "Operator ( / ) static member ( / ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise division. Declaration static member ( / ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Divides each element of tensor a by the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a / b // c = [2.5; 2.0; 1.75] See Also member FillDivide: Tensor<'T> -> Tensor<'T> -> unit static member ( / ): Tensor<'T> * 'T -> Tensor<'T> Element-wise division with scalar. Declaration static member ( / ): a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( / ): Tensor<'T> * Tensor<'T> -> Tensor<'T> static member ( / ): 'T * Tensor<'T> -> Tensor<'T> Element-wise division with scalar. Declaration static member ( / ): a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( / ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_DotMultiply.html": {
    "href": "api/Tensor.Tensor-1.op_DotMultiply.html",
    "title": "Operator ( .* ) | Tensor for F#",
    "keywords": "Operator ( .* ) static member ( .* ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Computes the (batched) matrix product, (batched) matrix-vector product or scalar product. Declaration static member ( .* ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks If a and b are vectors of the same length, then the scalar product is computed. The result is a scalar. If a is a matrix and b is a vector of compatible shape, then the matrix-vector product is computed. The result is a vector. If both a and b are matrices of compatibles shapes, then the matrix product is computed. The result is a matrix. If a is a tensor of shape [b_1; ...; b_n; i; j] and b is a tensor of shape [b_1; ...; b_n; j] , then the batched matrix-vector product is computed resulting in a tensor of shape [b_1; ...; b_n; i] . Broadcasting rules apply for the batch dimensions. If a is a tensor of shape [b_1; ...; b_n; i; j] and b is a tensor of shape [b_1; ...; b_n; j; k] , then the batched matrix product is computed resulting in a tensor of shape [b_1; ...; b_n; i; k] . Broadcasting rules apply for the batch dimensions. Examples // Scalar product let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a .* b // c = [56.0] // Matrix-vector product let a = HostTensor.ofList2D [[5.0; 6.0; 7.0] [8.0; 9.0; 0.0]] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a .* b // c = [56.0; 43.0] // Matrix product let a = HostTensor.ofList2D [[5.0; 6.0; 7.0] [8.0; 9.0; 0.0]] let b = HostTensor.ofList2D [[2.0; 1.0] [3.0; 1.0] [4.0; 1.0]] let c = a .* b // c = [[56.0; 18.0] // [43.0; 17.0]] See Also member FillDot: Tensor<'T> -> Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.op_EqualsEqualsEqualsEquals.html": {
    "href": "api/Tensor.Tensor-1.op_EqualsEqualsEqualsEquals.html",
    "title": "Operator ( ==== ) | Tensor for F#",
    "keywords": "Operator ( ==== ) static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise equality test. Declaration static member ( ==== ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being equal to the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a ==== b // c = [false; true; false] See Also member FillEqual: Tensor<'R> -> Tensor<'R> -> unit static member ( ==== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise equality test with scalar. Declaration static member ( ==== ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( ==== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise equality test with scalar. Declaration static member ( ==== ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( ==== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_GreaterGreaterEqualsEquals.html": {
    "href": "api/Tensor.Tensor-1.op_GreaterGreaterEqualsEquals.html",
    "title": "Operator ( >>== ) | Tensor for F#",
    "keywords": "Operator ( >>== ) static member ( >>== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise greater-than-or-equal test. Declaration static member ( >>== ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being greater than or equal to the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a >>== b // c = [true; true; false] See Also member FillGreaterOrEqual: Tensor<'R> -> Tensor<'R> -> unit static member ( >>== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise greater-than-or-equal test with scalar. Declaration static member ( >>== ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( >>== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( >>== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise greater-than-or-equal test with scalar. Declaration static member ( >>== ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( >>== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_GreaterGreaterGreaterGreater.html": {
    "href": "api/Tensor.Tensor-1.op_GreaterGreaterGreaterGreater.html",
    "title": "Operator ( >>>> ) | Tensor for F#",
    "keywords": "Operator ( >>>> ) static member ( >>>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise greater-than test. Declaration static member ( >>>> ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being greater than the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a >>>> b // c = [true; false; false] See Also member FillGreater: Tensor<'R> -> Tensor<'R> -> unit static member ( >>>> ): Tensor<'T> * 'T -> Tensor<bool> Element-wise greater-than test with scalar. Declaration static member ( >>>> ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( >>>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( >>>> ): 'T * Tensor<'T> -> Tensor<bool> Element-wise greater-than test with scalar. Declaration static member ( >>>> ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( >>>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_HatHatHatHat.html": {
    "href": "api/Tensor.Tensor-1.op_HatHatHatHat.html",
    "title": "Operator ( ^^^^ ) | Tensor for F#",
    "keywords": "Operator ( ^^^^ ) static member ( ^^^^ ): Tensor<bool> * Tensor<bool> -> Tensor<bool> Element-wise loigcal xor. Declaration static member ( ^^^^ ): a:Tensor<bool> * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Computes the logical xor of each element of tensor a with the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [true; true; false; false] let b = HostTensor.ofList [true; false; true; false] let c = a ^^^^ b // c = [false; true; true; false] See Also member FillXor: Tensor<bool> -> Tensor<bool> -> unit static member ( ^^^^ ): Tensor<bool> * bool -> Tensor<bool> Element-wise loigcal xor with scalar. Declaration static member ( ^^^^ ): a:Tensor<bool> * b:bool -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor on the left side of this binary operation. bool b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( ^^^^ ): Tensor<bool> * Tensor<bool> -> Tensor<bool> static member ( ^^^^ ): bool * Tensor<bool> -> Tensor<bool> Element-wise loigcal xor with scalar. Declaration static member ( ^^^^ ): a:bool * b:Tensor<bool> -> Tensor<bool> Parameters Type Name Description bool a The scalar on the left side of this binary operation. Tensor < bool > b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( ^^^^ ): Tensor<bool> * Tensor<bool> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_LessLessEqualsEquals.html": {
    "href": "api/Tensor.Tensor-1.op_LessLessEqualsEquals.html",
    "title": "Operator ( <<== ) | Tensor for F#",
    "keywords": "Operator ( <<== ) static member ( <<== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise less-than-or-equal test. Declaration static member ( <<== ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being less than or equal to the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a <<== b // c = [false; true; true] See Also member FillLessOrEqual: Tensor<'R> -> Tensor<'R> -> unit static member ( <<== ): Tensor<'T> * 'T -> Tensor<bool> Element-wise less-than-or-equal test with scalar. Declaration static member ( <<== ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( <<== ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( <<== ): 'T * Tensor<'T> -> Tensor<bool> Element-wise less-than-or-equal test with scalar. Declaration static member ( <<== ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( <<== ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_LessLessGreaterGreater.html": {
    "href": "api/Tensor.Tensor-1.op_LessLessGreaterGreater.html",
    "title": "Operator ( <<>> ) | Tensor for F#",
    "keywords": "Operator ( <<>> ) static member ( <<>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise not-equality test. Declaration static member ( <<>> ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being not equal to the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a <<>> b // c = [true; false; true] See Also member FillNotEqual: Tensor<'R> -> Tensor<'R> -> unit static member ( <<>> ): Tensor<'T> * 'T -> Tensor<bool> Element-wise not-equality test with scalar. Declaration static member ( <<>> ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( <<>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( <<>> ): 'T * Tensor<'T> -> Tensor<bool> Element-wise not-equality test with scalar. Declaration static member ( <<>> ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( <<>> ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_LessLessLessLess.html": {
    "href": "api/Tensor.Tensor-1.op_LessLessLessLess.html",
    "title": "Operator ( <<<< ) | Tensor for F#",
    "keywords": "Operator ( <<<< ) static member ( <<<< ): Tensor<'T> * Tensor<'T> -> Tensor<bool> Element-wise less-than test. Declaration static member ( <<<< ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Test each element of tensor a for being less than the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same storage and type. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [2.0; 4.0; 6.0] let b = HostTensor.ofList [1.0; 4.0; 7.0] let c = a <<<< b // c = [false; false; true] See Also member FillLess: Tensor<'R> -> Tensor<'R> -> unit static member ( <<<< ): Tensor<'T> * 'T -> Tensor<bool> Element-wise less-than test with scalar. Declaration static member ( <<<< ): a:Tensor<'T> * b:'T -> Tensor<bool> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. See Also static member ( <<<< ): Tensor<'T> * Tensor<'T> -> Tensor<bool> static member ( <<<< ): 'T * Tensor<'T> -> Tensor<bool> Element-wise less-than test with scalar. Declaration static member ( <<<< ): a:'T * b:Tensor<'T> -> Tensor<bool> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor < bool > See Also static member ( <<<< ): Tensor<'T> * Tensor<'T> -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.op_Modulus.html": {
    "href": "api/Tensor.Tensor-1.op_Modulus.html",
    "title": "Operator ( % ) | Tensor for F#",
    "keywords": "Operator ( % ) static member ( % ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise remainder of division. Declaration static member ( % ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Computes the remainder of dividing each element of tensor a by the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a % b // c = [1.0; 0.0; 3.0] See Also member FillModulo: Tensor<'T> -> Tensor<'T> -> unit static member ( % ): Tensor<'T> * 'T -> Tensor<'T> Element-wise remainder of division with scalar. Declaration static member ( % ): a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( % ): Tensor<'T> * Tensor<'T> -> Tensor<'T> static member ( % ): 'T * Tensor<'T> -> Tensor<'T> Element-wise division with scalar. Declaration static member ( % ): a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( % ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.reshape.html": {
    "href": "api/Tensor.Tensor-1.reshape.html",
    "title": "Method reshape | Tensor for F#",
    "keywords": "Method reshape static member reshape: int64 list -> Tensor<'T> -> Tensor<'T> Changes the shape of a tensor. Declaration static member reshape: shp:int64 list -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int64 list shp The target shape. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A tensor of the specified shape. Remarks Changes the shape of the tensor to the specified shape. The total number of elements must not change. One dimension of the shp can be specified as val Remainder , in which case the size of that dimension is inferred automatically. If a reshape is possible without copying the data of the tensor, a view of the original tensor is returned and the storage is shared. In this case, modifications done to the returned tensor will affect the original tensor. If a reshape is not possible without copying the data of the tensor, a new tensor of the specified shape and a new storage is allocated and the data is copied into the new tensor. Examples let a = HostTensor.zeros [2L; 3L; 4L] let b = Tensor.reshape [6L; 4L] a // b.Shape = [6L; 4L] let c = Tensor.reshape [2L; Remainder; 1L] a // c.Shape = [2L; 12L; 1L] See Also static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option static member reshapeView: int64 list -> Tensor<'T> -> Tensor<'T> static member flatten: Tensor<'T> -> Tensor<'T> member Shape: unit -> int64 list"
  },
  "api/Tensor.Tensor-1.reshapeView.html": {
    "href": "api/Tensor.Tensor-1.reshapeView.html",
    "title": "Method reshapeView | Tensor for F#",
    "keywords": "Method reshapeView static member reshapeView: int64 list -> Tensor<'T> -> Tensor<'T> Creates a reshaped view of the tensor (without copying). Declaration static member reshapeView: shp:int64 list -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int64 list shp The target shape. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A reshaped view of the original tensor. Remarks Changes the shape of the tensor to the specified shape. The total number of elements must not change. One dimension of the shp can be specified as val Remainder , in which case the size of that dimension is inferred automatically. If a reshape is not possible without copying the data of the tensor, an exception is raised. To avoid this, use static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option instead. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. See Also static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option static member reshape: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.reverseAxis.html": {
    "href": "api/Tensor.Tensor-1.reverseAxis.html",
    "title": "Method reverseAxis | Tensor for F#",
    "keywords": "Method reverseAxis static member reverseAxis: int -> Tensor<'T> -> Tensor<'T> Reverses the elements in the specified dimension. Declaration static member reverseAxis: ax:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to reverse. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The tensor with the dimensions permuted. Remarks The elements along the specified axis are reversed. A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.ofList [0; 1; 2; 3] let b = Tensor.reverseAxis 0 a // b = [3; 2; 1; 0]"
  },
  "api/Tensor.Tensor-1.scalar.html": {
    "href": "api/Tensor.Tensor-1.scalar.html",
    "title": "Method scalar | Tensor for F#",
    "keywords": "Method scalar static member scalar: ITensorDevice -> 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. Declaration static member scalar: dev:ITensorDevice -> value:'T -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. 'T value The value of the new, scalar tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor of zero-dimensional shape is created on the specified device. The values of the tensor is set to the specified value. Examples let a = Tensor.scalar HostTensor.Dev 2.5f // a = 2.5f See Also static member scalarLike: ITensor -> 'T -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.scalarLike.html": {
    "href": "api/Tensor.Tensor-1.scalarLike.html",
    "title": "Method scalarLike | Tensor for F#",
    "keywords": "Method scalarLike static member scalarLike: ITensor -> 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor using the specified tensor as template and with the specified value. Declaration static member scalarLike: tmpl:ITensor -> value:'T -> Tensor<'T> Parameters Type Name Description ITensor tmpl The template tensor. 'T value The value of the new, scalar tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor of zero-dimensional shape is created on the same device as tmpl . The values of the tensor is set to the specified value. See Also static member scalar: ITensorDevice -> 'T -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.scatter.html": {
    "href": "api/Tensor.Tensor-1.scatter.html",
    "title": "Method scatter | Tensor for F#",
    "keywords": "Method scatter static member scatter: Tensor<int64> option list -> int64 list -> Tensor<'T> -> Tensor<'T> Disperses elements from a source tensor to a new tensor according to the specified indices. Declaration static member scatter: indices:Tensor<int64> option list -> trgtShp:int64 list -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor < int64 > option list indices A list of tensors, one per dimension of this tensor, containing the target indicies for each element of src . int64 list trgtShp The shape of the resulting tensor. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> Result with the shape specified in trgtShp . Remarks The source element with indices [i_0; i_1; i_2; ...] is written to the target element with indices [j_0; j_1; j_2; ...] , where each index j_k is given by j_k = indices.[k].[i_0; i_1; i_2; ...] . If indices.[k] is None , then j_k = i_k is assumed instead. If a target index occurs multiple times, the corresponding source values are summed. If a target element is not referenced by any index, it is set to zero. The tensors indices and src must have the same storage. Examples // Sum first row of src into last element and swap rows 1 and 2. let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3] [1.0; 1.1; 1.2; 1.3] [2.0; 2.1; 2.2; 2.3]] let i0 = HostTensor.ofList2D [[0L; 0L; 0L; 0L] [2L; 2L; 2L; 2L] [1L; 1L; 1L; 1L]] let i1 = HostTensor.ofList2D [[3L; 3L; 3L; 3L] [0L; 1L; 2L; 3L] [0L; 1L; 2L; 3L]] let s = Tensor.scatter [Some i0; Some i1] [4L; 4L] src // s = // [[ 0.0000 0.0000 0.0000 0.6000] // [ 2.0000 2.1000 2.2000 2.3000] // [ 1.0000 1.1000 1.2000 1.3000] // [ 0.0000 0.0000 0.0000 0.0000]] See Also member FillScatter: Tensor<int64> option list -> Tensor<'T> -> unit static member gather: Tensor<int64> option list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.set.html": {
    "href": "api/Tensor.Tensor-1.set.html",
    "title": "Method set | Tensor for F#",
    "keywords": "Method set static member set: Tensor<'T> -> int64 list -> 'T -> unit Sets the value of a single element of the tensor. Declaration static member set: a:Tensor<'T> -> pos:int64 list -> value:'T -> unit Parameters Type Name Description Tensor <'T> a The tensor to write to. int64 list pos A list consisting of the indicies of the element to access. The list must have one entry per dimension of this tensor. 'T value The new value of the element. See Also member Item: int64 list -> 'T"
  },
  "api/Tensor.Tensor-1.shape.html": {
    "href": "api/Tensor.Tensor-1.shape.html",
    "title": "Method shape | Tensor for F#",
    "keywords": "Method shape static member shape: Tensor<'T> -> int64 list Shape of the tensor. Declaration static member shape: a:Tensor<'T> -> int64 list Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description int64 list Shape. See Also member Shape: unit -> int64 list"
  },
  "api/Tensor.Tensor-1.std.html": {
    "href": "api/Tensor.Tensor-1.std.html",
    "title": "Method std | Tensor for F#",
    "keywords": "Method std static member std: Tensor<'T> * int64 option -> 'T Calculates the standard deviation of the tensor. Declaration static member std: a:Tensor<'T> * ddof:int64 option -> 'T Parameters Type Name Description Tensor <'T> a The tensor containing the source values. int64 option ddof The delta degrees of freedom. (default: 0L) Returns Type Description 'T The standard deviation estimate. Remarks The standard deviation is calculated over all elements of the tensor. The parameter ddof specifies the difference between the number of elements and the degrees of freedom for the computation of the variance. Use ddof=1 to obtain an unbiased estimate and ddof=0 for a maximum-likelihood estimate. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.std a See Also static member stdAxis: int * Tensor<'T> * int64 option -> Tensor<'T> static member mean: Tensor<'T> -> 'T static member var: Tensor<'T> * int64 option -> 'T"
  },
  "api/Tensor.Tensor-1.stdAxis.html": {
    "href": "api/Tensor.Tensor-1.stdAxis.html",
    "title": "Method stdAxis | Tensor for F#",
    "keywords": "Method stdAxis static member stdAxis: int * Tensor<'T> * int64 option -> Tensor<'T> Calculates the standard deviation of the elements along the specified axis. Declaration static member stdAxis: ax:int * a:Tensor<'T> * ddof:int64 option -> Tensor<'T> Parameters Type Name Description int ax The axis to operate along. Tensor <'T> a The tensor containing the source values. int64 option ddof The delta degrees of freedom. (default: 0L) Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The standard deviation is calculated along the specified axis. The parameter ddof specifies the difference between the number of elements and the degrees of freedom for the computation of the variance. Use ddof=1 to obtain an unbiased estimate and ddof=0 for a maximum-likelihood estimate. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.stdAxis (1, a, ddof=1L) See Also static member std: Tensor<'T> * int64 option -> 'T static member meanAxis: int -> Tensor<'T> -> Tensor<'T> static member varAxis: int * Tensor<'T> * int64 option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.sum.html": {
    "href": "api/Tensor.Tensor-1.sum.html",
    "title": "Method sum | Tensor for F#",
    "keywords": "Method sum static member sum: Tensor<'T> -> 'T Sums all elements. Declaration static member sum: src:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description 'T A scalar containing the result of this operation. Remarks All elements are summed. An empty sum equals zero. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.sum a // b = 36.0 See Also static member sumAxis: int -> Tensor<'T> -> Tensor<'T> static member sumTensor: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.sumAxis.html": {
    "href": "api/Tensor.Tensor-1.sumAxis.html",
    "title": "Method sumAxis | Tensor for F#",
    "keywords": "Method sumAxis static member sumAxis: int -> Tensor<'T> -> Tensor<'T> Sums the elements along the specified axis. Declaration static member sumAxis: ax:int -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to sum along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Elements are summed along the specified axis. An empty sum equals zero. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.sumAxis 1 a // b = [10.0; 26.0] See Also member FillSumAxis: int -> Tensor<'T> -> unit static member sum: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.sumTensor.html": {
    "href": "api/Tensor.Tensor-1.sumTensor.html",
    "title": "Method sumTensor | Tensor for F#",
    "keywords": "Method sumTensor static member sumTensor: Tensor<'T> -> Tensor<'T> Sums all elements returning a Tensor. Declaration static member sumTensor: src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new scalar tensor containing the result of this operation. See Also static member sum: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.swapDim.html": {
    "href": "api/Tensor.Tensor-1.swapDim.html",
    "title": "Method swapDim | Tensor for F#",
    "keywords": "Method swapDim static member swapDim: int -> int -> Tensor<'T> -> Tensor<'T> Swaps the specified dimensions of the tensor. Declaration static member swapDim: ax1:int -> ax2:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax1 The dimension to swap. int ax2 The dimension to swap with. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The tensor with the dimensions swapped. Remarks A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [2L; 3L; 4L] let b = Tensor.swapDim 0 2 a // b.Shape = [4L; 3L; 2L] See Also static member permuteAxes: int list -> Tensor<'T> -> Tensor<'T> member T: unit -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.symmetricEigenDecomposition.html": {
    "href": "api/Tensor.Tensor-1.symmetricEigenDecomposition.html",
    "title": "Method symmetricEigenDecomposition | Tensor for F#",
    "keywords": "Method symmetricEigenDecomposition static member symmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> * Tensor<'T> Computes the (real) eigendecomposition of a symmetric matrix. Declaration static member symmetricEigenDecomposition: part:MatrixPart -> a:Tensor<'T> -> Tensor<'T> * Tensor<'T> Parameters Type Name Description MatrixPart part Specifies which part of the matrix should be used. Tensor <'T> a The input matrix to this operation. Returns Type Description Tensor <'T> * Tensor <'T> A tuple consisting of (vals, vecs) where each column of vecs is the eigenvector for the corresponding eigenvalue in vals . Remarks The eigendecomposition of a symmetric matrix is real. Only the part of the matrix specified by part is used. The other part is ignored and can contain arbitrary values. See Also static member FillSymmetricEigenDecomposition: MatrixPart -> Tensor<'T> -> Tensor<'T> -> Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.tensorProduct.html": {
    "href": "api/Tensor.Tensor-1.tensorProduct.html",
    "title": "Method tensorProduct | Tensor for F#",
    "keywords": "Method tensorProduct static member tensorProduct: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Computes the tensor product between two tensors. Declaration static member tensorProduct: a:Tensor<'T> -> b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation."
  },
  "api/Tensor.Tensor-1.transpose.html": {
    "href": "api/Tensor.Tensor-1.transpose.html",
    "title": "Method transpose | Tensor for F#",
    "keywords": "Method transpose static member transpose: Tensor<'T> -> Tensor<'T> (Batched) transpose of a matrix. Declaration static member transpose: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The result of this operation. See Also member T: unit -> Tensor<'T>"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-LessOrEqual.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-LessOrEqual.html",
    "title": "Method LessOrEqual | Tensor for F#",
    "keywords": "Method LessOrEqual interface ITensorBackend<'T> with member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member LessOrEqual: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Log.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Log.html",
    "title": "Method Log | Tensor for F#",
    "keywords": "Method Log interface ITensorBackend<'T> with member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Log: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Log10.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Log10.html",
    "title": "Method Log10 | Tensor for F#",
    "keywords": "Method Log10 interface ITensorBackend<'T> with member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Log10: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Map.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Map.html",
    "title": "Method Map | Tensor for F#",
    "keywords": "Method Map member Map: 'b -> 'c * ITensorFrontend<'c> * ITensorFrontend<'b> * bool -> unit Declaration member Map: fn:'b -> 'c * trgt:ITensorFrontend<'c> * a:ITensorFrontend<'b> * useThreads:bool -> unit Parameters Type Name Description 'b -> 'c fn ITensorFrontend <'c> trgt ITensorFrontend <'b> a bool useThreads Type Parameters Name Description 'b 'c"
  },
  "api/Tensor.Host.TensorHostBackend-1.Map2.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Map2.html",
    "title": "Method Map2 | Tensor for F#",
    "keywords": "Method Map2 member Map2: 'b -> 'c -> 'd * ITensorFrontend<'d> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit Declaration member Map2: fn:'b -> 'c -> 'd * trgt:ITensorFrontend<'d> * a:ITensorFrontend<'b> * b:ITensorFrontend<'c> * useThreads:bool -> unit Parameters Type Name Description 'b -> 'c -> 'd fn ITensorFrontend <'d> trgt ITensorFrontend <'b> a ITensorFrontend <'c> b bool useThreads Type Parameters Name Description 'b 'c 'd"
  },
  "api/Tensor.Host.TensorHostBackend-1.MapIndexed.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.MapIndexed.html",
    "title": "Method MapIndexed | Tensor for F#",
    "keywords": "Method MapIndexed member MapIndexed: int64 [] -> 'b -> 'c * ITensorFrontend<'c> * ITensorFrontend<'b> * bool -> unit Declaration member MapIndexed: fn:int64 [] -> 'b -> 'c * trgt:ITensorFrontend<'c> * a:ITensorFrontend<'b> * useThreads:bool -> unit Parameters Type Name Description int64 [] -> 'b -> 'c fn ITensorFrontend <'c> trgt ITensorFrontend <'b> a bool useThreads Type Parameters Name Description 'b 'c"
  },
  "api/Tensor.Host.TensorHostBackend-1.MapIndexed2.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.MapIndexed2.html",
    "title": "Method MapIndexed2 | Tensor for F#",
    "keywords": "Method MapIndexed2 member MapIndexed2: int64 [] -> 'b -> 'c -> 'd * ITensorFrontend<'d> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit Declaration member MapIndexed2: fn:int64 [] -> 'b -> 'c -> 'd * trgt:ITensorFrontend<'d> * a:ITensorFrontend<'b> * b:ITensorFrontend<'c> * useThreads:bool -> unit Parameters Type Name Description int64 [] -> 'b -> 'c -> 'd fn ITensorFrontend <'d> trgt ITensorFrontend <'b> a ITensorFrontend <'c> b bool useThreads Type Parameters Name Description 'b 'c 'd"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaskedGet.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaskedGet.html",
    "title": "Method MaskedGet | Tensor for F#",
    "keywords": "Method MaskedGet interface ITensorBackend<'T> with member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit Declaration interface ITensorBackend<'T> with member MaskedGet: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> * masks:ITensorFrontend<bool> option [] -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src ITensorFrontend < bool > option [] masks Overrides abstract member ITensorBackend.MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaskedSet.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaskedSet.html",
    "title": "Method MaskedSet | Tensor for F#",
    "keywords": "Method MaskedSet interface ITensorBackend<'T> with member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaskedSet: trgt:ITensorFrontend<'T> * masks:ITensorFrontend<bool> option [] * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > option [] masks ITensorFrontend <'T> src Overrides abstract member ITensorBackend.MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MatMatDot.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MatMatDot.html",
    "title": "Method MatMatDot | Tensor for F#",
    "keywords": "Method MatMatDot interface ITensorBackend<'T> with member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MatMatDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MatVecDot.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MatVecDot.html",
    "title": "Method MatVecDot | Tensor for F#",
    "keywords": "Method MatVecDot interface ITensorBackend<'T> with member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MatVecDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaxElemwise.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaxElemwise.html",
    "title": "Method MaxElemwise | Tensor for F#",
    "keywords": "Method MaxElemwise interface ITensorBackend<'T> with member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaxElemwise: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaxLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MaxLastAxis.html",
    "title": "Method MaxLastAxis | Tensor for F#",
    "keywords": "Method MaxLastAxis interface ITensorBackend<'T> with member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaxLastAxis: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MinElemwise.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MinElemwise.html",
    "title": "Method MinElemwise | Tensor for F#",
    "keywords": "Method MinElemwise interface ITensorBackend<'T> with member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MinElemwise: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MinLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-MinLastAxis.html",
    "title": "Method MinLastAxis | Tensor for F#",
    "keywords": "Method MinLastAxis interface ITensorBackend<'T> with member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MinLastAxis: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Modulo.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Modulo.html",
    "title": "Method Modulo | Tensor for F#",
    "keywords": "Method Modulo interface ITensorBackend<'T> with member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Modulo: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Log10.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Log10.html",
    "title": "Method Log10 | Tensor for F#",
    "keywords": "Method Log10 interface ITensorBackend<'T> with member Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Log10: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Log10: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaskedGet.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaskedGet.html",
    "title": "Method MaskedGet | Tensor for F#",
    "keywords": "Method MaskedGet interface ITensorBackend<'T> with member MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit Declaration interface ITensorBackend<'T> with member MaskedGet: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> * mask:ITensorFrontend<bool> option [] -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src ITensorFrontend < bool > option [] mask Overrides abstract member ITensorBackend.MaskedGet: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<bool> option [] -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaskedSet.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaskedSet.html",
    "title": "Method MaskedSet | Tensor for F#",
    "keywords": "Method MaskedSet interface ITensorBackend<'T> with member MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaskedSet: trgt:ITensorFrontend<'T> * mask:ITensorFrontend<bool> option [] * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > option [] mask ITensorFrontend <'T> src Overrides abstract member ITensorBackend.MaskedSet: ITensorFrontend<'T> * ITensorFrontend<bool> option [] * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MatMatDot.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MatMatDot.html",
    "title": "Method MatMatDot | Tensor for F#",
    "keywords": "Method MatMatDot interface ITensorBackend<'T> with member MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MatMatDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MatVecDot.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MatVecDot.html",
    "title": "Method MatVecDot | Tensor for F#",
    "keywords": "Method MatVecDot interface ITensorBackend<'T> with member MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MatVecDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.MatVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaxElemwise.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaxElemwise.html",
    "title": "Method MaxElemwise | Tensor for F#",
    "keywords": "Method MaxElemwise interface ITensorBackend<'T> with member MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaxElemwise: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.MaxElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaxLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MaxLastAxis.html",
    "title": "Method MaxLastAxis | Tensor for F#",
    "keywords": "Method MaxLastAxis interface ITensorBackend<'T> with member MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MaxLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.MaxLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MinElemwise.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MinElemwise.html",
    "title": "Method MinElemwise | Tensor for F#",
    "keywords": "Method MinElemwise interface ITensorBackend<'T> with member MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MinElemwise: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.MinElemwise: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MinLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-MinLastAxis.html",
    "title": "Method MinLastAxis | Tensor for F#",
    "keywords": "Method MinLastAxis interface ITensorBackend<'T> with member MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member MinLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.MinLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Modulo.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Modulo.html",
    "title": "Method Modulo | Tensor for F#",
    "keywords": "Method Modulo interface ITensorBackend<'T> with member Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Modulo: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Modulo: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Multiply.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Multiply.html",
    "title": "Method Multiply | Tensor for F#",
    "keywords": "Method Multiply interface ITensorBackend<'T> with member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Multiply: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Negate.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Negate.html",
    "title": "Method Negate | Tensor for F#",
    "keywords": "Method Negate interface ITensorBackend<'T> with member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Negate: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 Overrides abstract member ITensorBackend.Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-NotEqual.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-NotEqual.html",
    "title": "Method NotEqual | Tensor for F#",
    "keywords": "Method NotEqual interface ITensorBackend<'T> with member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member NotEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Or.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Or.html",
    "title": "Method Or | Tensor for F#",
    "keywords": "Method Or interface ITensorBackend<'T> with member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Or: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2 Overrides abstract member ITensorBackend.Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Power.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Power.html",
    "title": "Method Power | Tensor for F#",
    "keywords": "Method Power interface ITensorBackend<'T> with member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Power: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ProductLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ProductLastAxis.html",
    "title": "Method ProductLastAxis | Tensor for F#",
    "keywords": "Method ProductLastAxis interface ITensorBackend<'T> with member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ProductLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Algorithm.Rat.GetHashCode.html": {
    "href": "api/Tensor.Algorithm.Rat.GetHashCode.html",
    "title": "Method GetHashCode | Tensor for F#",
    "keywords": "Method GetHashCode override member GetHashCode: unit -> int Declaration override member GetHashCode: unit -> int Returns Type Description int"
  },
  "api/Tensor.Algorithm.Rat.ToString.html": {
    "href": "api/Tensor.Algorithm.Rat.ToString.html",
    "title": "Method ToString | Tensor for F#",
    "keywords": "Method ToString override member ToString: unit -> string Declaration override member ToString: unit -> string Returns Type Description string"
  },
  "api/Tensor.Algorithm.Rat.Truncate.html": {
    "href": "api/Tensor.Algorithm.Rat.Truncate.html",
    "title": "Method Truncate | Tensor for F#",
    "keywords": "Method Truncate static member Truncate: Rat -> Rat Declaration static member Truncate: a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.dnm.html": {
    "href": "api/Tensor.Algorithm.Rat.dnm.html",
    "title": "Method dnm | Tensor for F#",
    "keywords": "Method dnm static member dnm: Rat -> bigint denominator Declaration static member dnm: a:Rat -> bigint Parameters Type Name Description Rat a Returns Type Description bigint"
  },
  "api/Tensor.Algorithm.Rat.get_Sign.html": {
    "href": "api/Tensor.Algorithm.Rat.get_Sign.html",
    "title": "Method get_Sign | Tensor for F#",
    "keywords": "Method get_Sign static member get_Sign: Rat -> int Declaration static member get_Sign: a:Rat -> int Parameters Type Name Description Rat a Returns Type Description int"
  },
  "api/Tensor.Algorithm.Rat.isFinite.html": {
    "href": "api/Tensor.Algorithm.Rat.isFinite.html",
    "title": "Method isFinite | Tensor for F#",
    "keywords": "Method isFinite static member isFinite: Rat -> bool True if a is a finite number. Declaration static member isFinite: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.isInf.html": {
    "href": "api/Tensor.Algorithm.Rat.isInf.html",
    "title": "Method isInf | Tensor for F#",
    "keywords": "Method isInf static member isInf: Rat -> bool True if a is infinity. Declaration static member isInf: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.isInteger.html": {
    "href": "api/Tensor.Algorithm.Rat.isInteger.html",
    "title": "Method isInteger | Tensor for F#",
    "keywords": "Method isInteger static member isInteger: Rat -> bool True if a is an integer, i.e. its denominator is one. Declaration static member isInteger: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.isNaN.html": {
    "href": "api/Tensor.Algorithm.Rat.isNaN.html",
    "title": "Method isNaN | Tensor for F#",
    "keywords": "Method isNaN static member isNaN: Rat -> bool True if a is not-a-number. Declaration static member isNaN: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.isNegInf.html": {
    "href": "api/Tensor.Algorithm.Rat.isNegInf.html",
    "title": "Method isNegInf | Tensor for F#",
    "keywords": "Method isNegInf static member isNegInf: Rat -> bool True if a is negative infinity. Declaration static member isNegInf: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.isPosInf.html": {
    "href": "api/Tensor.Algorithm.Rat.isPosInf.html",
    "title": "Method isPosInf | Tensor for F#",
    "keywords": "Method isPosInf static member isPosInf: Rat -> bool True if a is positive infinity. Declaration static member isPosInf: a:Rat -> bool Parameters Type Name Description Rat a Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.num.html": {
    "href": "api/Tensor.Algorithm.Rat.num.html",
    "title": "Method num | Tensor for F#",
    "keywords": "Method num static member num: Rat -> bigint numerator Declaration static member num: a:Rat -> bigint Parameters Type Name Description Rat a Returns Type Description bigint"
  },
  "api/Tensor.Algorithm.Rat.op_Addition.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Addition.html",
    "title": "Operator ( + ) | Tensor for F#",
    "keywords": "Operator ( + ) static member ( + ): Rat * Rat -> Rat Declaration static member ( + ): a:Rat * b:Rat -> Rat Parameters Type Name Description Rat a Rat b Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_Division.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Division.html",
    "title": "Operator ( / ) | Tensor for F#",
    "keywords": "Operator ( / ) static member ( / ): Rat * Rat -> Rat Declaration static member ( / ): a:Rat * b:Rat -> Rat Parameters Type Name Description Rat a Rat b Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_bigint.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_bigint.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> bigint Declaration static member op_Explicit: a:Rat -> bigint Parameters Type Name Description Rat a Returns Type Description bigint"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_int32.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_int32.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> int32 Declaration static member op_Explicit: a:Rat -> int32 Parameters Type Name Description Rat a Returns Type Description int32"
  },
  "api/Tensor.Tensor-1.trueIdx.html": {
    "href": "api/Tensor.Tensor-1.trueIdx.html",
    "title": "Method trueIdx | Tensor for F#",
    "keywords": "Method trueIdx static member trueIdx: Tensor<bool> -> Tensor<int64> Finds the indices of all element that are true. Declaration static member trueIdx: src:Tensor<bool> -> Tensor<int64> Parameters Type Name Description Tensor < bool > src The tensor containing the source values. Returns Type Description Tensor < int64 > A matrix that has one row per true entry in src . The columns correspond to the dimensions of src . Remarks The function searches for elements that are true and for each one it creates a row in the result matrix consisting of the indices of the element. Examples let a = HostTensor.ofList2D [[true; false; true; false] [false; true; true; false]] let b = Tensor.trueIdx a // b = [[0L; 0L] // [0L; 2L] // [1L; 1L] // [1L; 2L]]"
  },
  "api/Tensor.Tensor-1.trues.html": {
    "href": "api/Tensor.Tensor-1.trues.html",
    "title": "Method trues | Tensor for F#",
    "keywords": "Method trues static member trues: ITensorDevice -> int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. Declaration static member trues: dev:ITensorDevice -> shape:int64 list -> Tensor<bool> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. Remarks A new tensor of the specified shape is created on the specified device. The tensor is filled with trues. Examples let a = Tensor.trues HostTensor.Dev [2L; 3L] // a = [[true; true; true] // [true; true; true]] See Also static member falses: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.Tensor-1.tryFind.html": {
    "href": "api/Tensor.Tensor-1.tryFind.html",
    "title": "Method tryFind | Tensor for F#",
    "keywords": "Method tryFind static member tryFind: 'T -> Tensor<'T> -> int64 list option Finds the first occurence of the specfied value and returns its indices. Declaration static member tryFind: value:'T -> a:Tensor<'T> -> int64 list option Parameters Type Name Description 'T value The value to find. Tensor <'T> a The tensor containing the source values. Returns Type Description int64 list option The indices if the value was found, otherwise None . Remarks The values is searched for an the index of the first occurence is returned. If the value is not found None is returned instead. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 3.0]] let b = Tensor.tryFind 3.0 a // b = Some [0L; 2L] See Also static member find: 'T -> Tensor<'T> -> int64 list static member findAxis: 'T -> int -> Tensor<'T> -> Tensor<int64>"
  },
  "api/Tensor.Tensor-1.tryReshapeView.html": {
    "href": "api/Tensor.Tensor-1.tryReshapeView.html",
    "title": "Method tryReshapeView | Tensor for F#",
    "keywords": "Method tryReshapeView static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option Tries to create a reshaped view of the tensor (without copying). Declaration static member tryReshapeView: shp:int64 list -> a:Tensor<'T> -> Tensor<'T> option Parameters Type Name Description int64 list shp The target shape. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> option The reshaped tensor, if reshaping without copying is possible. Otherwise None . Remarks Changes the shape of the tensor to the specified shape. The total number of elements must not change. One dimension of the shp can be specified as val Remainder , in which case the size of that dimension is inferred automatically. If a reshape is not possible without copying the data of the tensor, None is returned. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. See Also static member reshapeView: int64 list -> Tensor<'T> -> Tensor<'T> static member reshape: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.value.html": {
    "href": "api/Tensor.Tensor-1.value.html",
    "title": "Method value | Tensor for F#",
    "keywords": "Method value static member value: Tensor<'T> -> 'T Gets the value of a zero-dimensional (scalar) tensor. Declaration static member value: a:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> a The zero-dimensional tensor to read from. Returns Type Description 'T The scalar value of the tensor. See Also member Value: unit -> 'T"
  },
  "api/Tensor.Tensor-1.var.html": {
    "href": "api/Tensor.Tensor-1.var.html",
    "title": "Method var | Tensor for F#",
    "keywords": "Method var static member var: Tensor<'T> * int64 option -> 'T Calculates the variance of the tensor. Declaration static member var: a:Tensor<'T> * ddof:int64 option -> 'T Parameters Type Name Description Tensor <'T> a The tensor containing the source values. int64 option ddof Returns Type Description 'T The variance estimate. Remarks The variance is calculated over all elements of the tensor. The parameter ddof specifies the difference between the number of elements and the degrees of freedom for the computation of the variance. Use ddof=1 to obtain an unbiased estimate and ddof=0 for a maximum-likelihood estimate. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.var a See Also static member varAxis: int * Tensor<'T> * int64 option -> Tensor<'T> static member mean: Tensor<'T> -> 'T static member std: Tensor<'T> * int64 option -> 'T"
  },
  "api/Tensor.Host.PinnedMemory.Ptr.html": {
    "href": "api/Tensor.Host.PinnedMemory.Ptr.html",
    "title": "Property Ptr | Tensor for F#",
    "keywords": "Property Ptr property Ptr: nativeint pointer to storage array Declaration property Ptr: nativeint with get Property Value Type Description nativeint"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemv.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemv.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * alpha:single * a:nativeint * lda:blas_int * x:nativeint * incx:blas_int * beta:single * y:nativeint * incy:blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE transA blas_int m blas_int n single alpha nativeint a blas_int lda nativeint x blas_int incx single beta nativeint y blas_int incy"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemm_batch.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemm_batch.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE [] * CBLAS_TRANSPOSE [] * blas_int [] * blas_int [] * blas_int [] * single [] * nativeint [] * blas_int [] * nativeint [] * blas_int [] * single [] * nativeint [] * blas_int [] * blas_int * blas_int [] -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE [] * transB:CBLAS_TRANSPOSE [] * m:blas_int [] * n:blas_int [] * k:blas_int [] * alpha:single [] * a:nativeint [] * lda:blas_int [] * b:nativeint [] * ldb:blas_int [] * beta:single [] * c:nativeint [] * ldc:blas_int [] * group_count:blas_int * group_size:blas_int [] -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE [] transA CBLAS_TRANSPOSE [] transB blas_int [] m blas_int [] n blas_int [] k single [] alpha nativeint [] a blas_int [] lda nativeint [] b blas_int [] ldb single [] beta nativeint [] c blas_int [] ldc blas_int group_count blas_int [] group_size"
  },
  "api/Tensor.Host.BLASModule.__cblas_sgemm.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sgemm.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: CBLAS_LAYOUT * CBLAS_TRANSPOSE * CBLAS_TRANSPOSE * blas_int * blas_int * blas_int * single * nativeint * blas_int * nativeint * blas_int * single * nativeint * blas_int -> unit Declaration abstract member Invoke: layout:CBLAS_LAYOUT * transA:CBLAS_TRANSPOSE * transB:CBLAS_TRANSPOSE * m:blas_int * n:blas_int * k:blas_int * alpha:single * a:nativeint * lda:blas_int * b:nativeint * ldb:blas_int * beta:single * c:nativeint * ldc:blas_int -> unit Parameters Type Name Description CBLAS_LAYOUT layout CBLAS_TRANSPOSE transA CBLAS_TRANSPOSE transB blas_int m blas_int n blas_int k single alpha nativeint a blas_int lda nativeint b blas_int ldb single beta nativeint c blas_int ldc"
  },
  "api/Tensor.Host.BLASModule.__cblas_ddot.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_ddot.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: blas_int * nativeint * blas_int * nativeint * blas_int -> double Declaration abstract member Invoke: n:blas_int * x:nativeint * incx:blas_int * y:nativeint * incy:blas_int -> double Parameters Type Name Description blas_int n nativeint x blas_int incx nativeint y blas_int incy Returns Type Description double"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_syevd.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_syevd.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: int * char * char * lapack_int * nativeint * lapack_int * nativeint -> lapack_int Declaration abstract member Invoke: matrix_layout:int * jobz:char * uplo:char * n:lapack_int * a:nativeint * lda:lapack_int * w:nativeint -> lapack_int Parameters Type Name Description int matrix_layout char jobz char uplo lapack_int n nativeint a lapack_int lda nativeint w Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_gesdd.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_gesdd.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: int * char * lapack_int * lapack_int * nativeint * lapack_int * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration abstract member Invoke: matrix_layout:int * jobz:char * m:lapack_int * n:lapack_int * a:nativeint * lda:lapack_int * s:nativeint * u:nativeint * ldu:lapack_int * vt:nativeint * ldvt:lapack_int -> lapack_int Parameters Type Name Description int matrix_layout char jobz lapack_int m lapack_int n nativeint a lapack_int lda nativeint s nativeint u lapack_int ldu nativeint vt lapack_int ldvt Returns Type Description lapack_int"
  },
  "api/Tensor.Host.BLASModule.__LAPACKE_geev.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__LAPACKE_geev.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: int * char * char * lapack_int * nativeint * lapack_int * nativeint * nativeint * nativeint * lapack_int * nativeint * lapack_int -> lapack_int Declaration abstract member Invoke: matrix_layout:int * jobvl:char * jobvr:char * n:lapack_int * a:nativeint * lda:lapack_int * wr:nativeint * wi:nativeint * vl:nativeint * ldvl:lapack_int * vr:nativeint * ldvr:lapack_int -> lapack_int Parameters Type Name Description int matrix_layout char jobvl char jobvr lapack_int n nativeint a lapack_int lda nativeint wr nativeint wi nativeint vl lapack_int ldvl nativeint vr lapack_int ldvr Returns Type Description lapack_int"
  },
  "api/Tensor.Cuda.OutOfCudaMemoryException.Message.html": {
    "href": "api/Tensor.Cuda.OutOfCudaMemoryException.Message.html",
    "title": "Property Message | Tensor for F#",
    "keywords": "Property Message override property Message: string Declaration override property Message: string with get Property Value Type Description string Overrides abstract property System.Exception.Message: string"
  },
  "api/Tensor.Cuda.OutOfCudaMemoryException.msg.html": {
    "href": "api/Tensor.Cuda.OutOfCudaMemoryException.msg.html",
    "title": "Field val msg: string | Tensor for F#",
    "keywords": "Field val msg: string Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val msg: string Returns Type Description string"
  },
  "api/Tensor.Cuda.NativeTensor.DataType.html": {
    "href": "api/Tensor.Cuda.NativeTensor.DataType.html",
    "title": "Field val DataType: Type | Tensor for F#",
    "keywords": "Field val DataType: Type Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val DataType: Type Returns Type Description System.Type"
  },
  "api/Tensor.Cuda.NativeTensor.BasePtr.html": {
    "href": "api/Tensor.Cuda.NativeTensor.BasePtr.html",
    "title": "Field val BasePtr: nativeint | Tensor for F#",
    "keywords": "Field val BasePtr: nativeint Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val BasePtr: nativeint Returns Type Description nativeint"
  },
  "api/Tensor.Cuda.NativeTensor.Offset.html": {
    "href": "api/Tensor.Cuda.NativeTensor.Offset.html",
    "title": "Field val Offset: int64 | Tensor for F#",
    "keywords": "Field val Offset: int64 Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val Offset: int64 Returns Type Description int64"
  },
  "api/Tensor.Cuda.NativeTensor.Shape.html": {
    "href": "api/Tensor.Cuda.NativeTensor.Shape.html",
    "title": "Field val Shape: int64 list | Tensor for F#",
    "keywords": "Field val Shape: int64 list Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val Shape: int64 list Returns Type Description int64 list"
  },
  "api/Tensor.Cuda.NativeTensor.Stride.html": {
    "href": "api/Tensor.Cuda.NativeTensor.Stride.html",
    "title": "Field val Stride: int64 list | Tensor for F#",
    "keywords": "Field val Stride: int64 list Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val Stride: int64 list Returns Type Description int64 list"
  },
  "api/Tensor.Cuda.NativeTensor.Storage.html": {
    "href": "api/Tensor.Cuda.NativeTensor.Storage.html",
    "title": "Field val Storage: obj | Tensor for F#",
    "keywords": "Field val Storage: obj Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val Storage: obj Returns Type Description obj"
  },
  "api/Tensor.ITensor.NElems.html": {
    "href": "api/Tensor.ITensor.NElems.html",
    "title": "Property NElems | Tensor for F#",
    "keywords": "Property NElems abstract property NElems: int64 number of elements Declaration abstract property NElems: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.ITensor.NDims.html": {
    "href": "api/Tensor.ITensor.NDims.html",
    "title": "Property NDims | Tensor for F#",
    "keywords": "Property NDims abstract property NDims: int number of dimensions Declaration abstract property NDims: int with get Property Value Type Description int"
  },
  "api/Tensor.ITensor.Layout.html": {
    "href": "api/Tensor.ITensor.Layout.html",
    "title": "Property Layout | Tensor for F#",
    "keywords": "Property Layout abstract property Layout: TensorLayout layout of this tensor (shape, offset and strides) Declaration abstract property Layout: TensorLayout with get Property Value Type Description TensorLayout"
  },
  "api/Tensor.ITensor.Full.html": {
    "href": "api/Tensor.ITensor.Full.html",
    "title": "Property Full | Tensor for F#",
    "keywords": "Property Full abstract property Full: string full contents string Declaration abstract property Full: string with get Property Value Type Description string"
  },
  "api/Tensor.ITensor.Dev.html": {
    "href": "api/Tensor.ITensor.Dev.html",
    "title": "Property Dev | Tensor for F#",
    "keywords": "Property Dev abstract property Dev: ITensorDevice storage factory Declaration abstract property Dev: ITensorDevice with get Property Value Type Description ITensorDevice"
  },
  "api/Tensor.ITensor.DataType.html": {
    "href": "api/Tensor.ITensor.DataType.html",
    "title": "Property DataType | Tensor for F#",
    "keywords": "Property DataType abstract property DataType: Type type of data stored in this tensor Declaration abstract property DataType: Type with get Property Value Type Description System.Type"
  },
  "api/Tensor.HostTensor.Dev().html": {
    "href": "api/Tensor.HostTensor.Dev().html",
    "title": "Field val Dev | Tensor for F#",
    "keywords": "Field val Dev Tensor device using a .NET array in host memory as data storage. Namespace : Tensor Assembly : Tensor.dll Syntax val Dev: ITensorDevice Returns Type Description ITensorDevice"
  },
  "api/Tensor.HostTensor.FillIndexed.html": {
    "href": "api/Tensor.HostTensor.FillIndexed.html",
    "title": "Method FillIndexed | Tensor for F#",
    "keywords": "Method FillIndexed val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit Fills the tensor with values returned by the specifed function. Declaration val FillIndexed: trgt:Tensor<'T> -> fn:int64 [] -> 'T -> unit Parameters Type Name Description Tensor <'T> trgt The target tensor to fill. int64 [] -> 'T fn A function that takes the index of the element to fill and returns the corresponding value. Type Parameters Name Description 'T See Also val init: int64 list -> int64 [] -> 'T -> Tensor<'T> HostTensor.Parallel.FillIndexed``1"
  },
  "api/Tensor.HostTensor.init.html": {
    "href": "api/Tensor.HostTensor.init.html",
    "title": "Method init | Tensor for F#",
    "keywords": "Method init val init: int64 list -> int64 [] -> 'T -> Tensor<'T> Creates a new tensor with values returned by the specified function. Declaration val init: shape:int64 list -> fn:int64 [] -> 'T -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. int64 [] -> 'T fn A function that takes the index of the element to fill and returns the corresponding value. Returns Type Description Tensor <'T> Type Parameters Name Description 'T See Also val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit HostTensor.Parallel.init``1"
  },
  "api/Tensor.HostTensor.transfer.html": {
    "href": "api/Tensor.HostTensor.transfer.html",
    "title": "Method transfer | Tensor for F#",
    "keywords": "Method transfer val transfer: Tensor<'T> -> Tensor<'T> Transfers a tensor to the host device. Declaration val transfer: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to transfer. Returns Type Description Tensor <'T> A tensor on the host device. Type Parameters Name Description 'T The data type of the tensor. See Also static member transfer: ITensorDevice -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.empty.html": {
    "href": "api/Tensor.HostTensor.empty.html",
    "title": "Method empty | Tensor for F#",
    "keywords": "Method empty val empty: int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. Declaration val empty: nDims:int -> Tensor<'T> Parameters Type Name Description int nDims The number of dimensions of the new, empty tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member empty: ITensorDevice -> int -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.zeros.html": {
    "href": "api/Tensor.HostTensor.zeros.html",
    "title": "Method zeros | Tensor for F#",
    "keywords": "Method zeros val zeros: int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). Declaration val zeros: shape:int64 list -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member zeros: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ones.html": {
    "href": "api/Tensor.HostTensor.ones.html",
    "title": "Method ones | Tensor for F#",
    "keywords": "Method ones val ones: int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). Declaration val ones: shape:int64 list -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member ones: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.falses.html": {
    "href": "api/Tensor.HostTensor.falses.html",
    "title": "Method falses | Tensor for F#",
    "keywords": "Method falses val falses: int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. Declaration val falses: shape:int64 list -> Tensor<bool> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. See Also static member falses: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.HostTensor.trues.html": {
    "href": "api/Tensor.HostTensor.trues.html",
    "title": "Method trues | Tensor for F#",
    "keywords": "Method trues val trues: int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. Declaration val trues: shape:int64 list -> Tensor<bool> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. See Also static member trues: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.HostTensor.scalar.html": {
    "href": "api/Tensor.HostTensor.scalar.html",
    "title": "Method scalar | Tensor for F#",
    "keywords": "Method scalar val scalar: 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. Declaration val scalar: value:'T -> Tensor<'T> Parameters Type Name Description 'T value The value of the new, scalar tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T See Also static member scalar: ITensorDevice -> 'T -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.isBroadcasted.html": {
    "href": "api/Tensor.ITensorModule.isBroadcasted.html",
    "title": "Method isBroadcasted | Tensor for F#",
    "keywords": "Method isBroadcasted val isBroadcasted: ITensor -> bool Checks if the specified tensor is broadcasted in at least one dimension. Declaration val isBroadcasted: a:ITensor -> bool Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description bool true if at least one dimension is broadcasted, otherwise false. See Also static member isBroadcasted: Tensor<'T> -> bool"
  },
  "api/Tensor.ITensorModule.tryReshapeView.html": {
    "href": "api/Tensor.ITensorModule.tryReshapeView.html",
    "title": "Method tryReshapeView | Tensor for F#",
    "keywords": "Method tryReshapeView val tryReshapeView: int64 list -> ITensor -> ITensor option Tries to create a reshaped view of the tensor (without copying). Declaration val tryReshapeView: shp:int64 list -> a:ITensor -> ITensor option Parameters Type Name Description int64 list shp The target shape. ITensor a The tensor to operate on. Returns Type Description ITensor option The reshaped tensor, if reshaping without copying is possible. Otherwise None . See Also static member tryReshapeView: int64 list -> Tensor<'T> -> Tensor<'T> option"
  },
  "api/Tensor.ITensorModule.reshapeView.html": {
    "href": "api/Tensor.ITensorModule.reshapeView.html",
    "title": "Method reshapeView | Tensor for F#",
    "keywords": "Method reshapeView val reshapeView: int64 list -> ITensor -> ITensor Creates a reshaped view of the tensor (without copying). Declaration val reshapeView: shp:int64 list -> a:ITensor -> ITensor Parameters Type Name Description int64 list shp The target shape. ITensor a The tensor to operate on. Returns Type Description ITensor A reshaped view of the original tensor. See Also static member reshapeView: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.reshape.html": {
    "href": "api/Tensor.ITensorModule.reshape.html",
    "title": "Method reshape | Tensor for F#",
    "keywords": "Method reshape val reshape: int64 list -> ITensor -> ITensor Changes the shape of a tensor. Declaration val reshape: shp:int64 list -> a:ITensor -> ITensor Parameters Type Name Description int64 list shp The target shape. ITensor a The tensor to operate on. Returns Type Description ITensor A tensor of the specified shape. See Also static member reshape: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.flatten.html": {
    "href": "api/Tensor.ITensorModule.flatten.html",
    "title": "Method flatten | Tensor for F#",
    "keywords": "Method flatten val flatten: ITensor -> ITensor Flattens the tensor into a (one-dimensional) vector. Declaration val flatten: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor A vector. See Also static member flatten: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.swapDim.html": {
    "href": "api/Tensor.ITensorModule.swapDim.html",
    "title": "Method swapDim | Tensor for F#",
    "keywords": "Method swapDim val swapDim: int -> int -> ITensor -> ITensor Swaps the specified dimensions of the tensor. Declaration val swapDim: ax1:int -> ax2:int -> a:ITensor -> ITensor Parameters Type Name Description int ax1 The dimension to swap. int ax2 The dimension to swap with. ITensor a The tensor to operate on. Returns Type Description ITensor The tensor with the dimensions swapped. See Also static member swapDim: int -> int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.transpose.html": {
    "href": "api/Tensor.ITensorModule.transpose.html",
    "title": "Method transpose | Tensor for F#",
    "keywords": "Method transpose val transpose: ITensor -> ITensor Transpose of a matrix. Declaration val transpose: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor The result of this operation. See Also static member transpose: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.permuteAxes.html": {
    "href": "api/Tensor.ITensorModule.permuteAxes.html",
    "title": "Method permuteAxes | Tensor for F#",
    "keywords": "Method permuteAxes val permuteAxes: int list -> ITensor -> ITensor Permutes the axes as specified. Declaration val permuteAxes: permut:int list -> a:ITensor -> ITensor Parameters Type Name Description int list permut The permutation to apply to the dimensions of tensor. ITensor a The tensor to operate on. Returns Type Description ITensor The tensor with the dimensions permuted. See Also static member permuteAxes: int list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.reverseAxis.html": {
    "href": "api/Tensor.ITensorModule.reverseAxis.html",
    "title": "Method reverseAxis | Tensor for F#",
    "keywords": "Method reverseAxis val reverseAxis: int -> ITensor -> ITensor Reverses the elements in the specified dimension. Declaration val reverseAxis: ax:int -> a:ITensor -> ITensor Parameters Type Name Description int ax The axis to reverse. ITensor a The tensor to operate on. Returns Type Description ITensor The tensor with the dimensions permuted. See Also static member reverseAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.atLeastND.html": {
    "href": "api/Tensor.ITensorModule.atLeastND.html",
    "title": "Method atLeastND | Tensor for F#",
    "keywords": "Method atLeastND val atLeastND: int -> ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least the specified number of dimensions. Declaration val atLeastND: minDims:int -> a:ITensor -> ITensor Parameters Type Name Description int minDims The minimum number of dimensions. ITensor a The tensor to operate on. Returns Type Description ITensor A tensor with at least minDims dimensions. See Also static member atLeastND: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.atLeast1D.html": {
    "href": "api/Tensor.ITensorModule.atLeast1D.html",
    "title": "Method atLeast1D | Tensor for F#",
    "keywords": "Method atLeast1D val atLeast1D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least one dimension. Declaration val atLeast1D: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor A tensor with at least one dimensions. See Also static member atLeast1D: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.atLeast2D.html": {
    "href": "api/Tensor.ITensorModule.atLeast2D.html",
    "title": "Method atLeast2D | Tensor for F#",
    "keywords": "Method atLeast2D val atLeast2D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least two dimensions. Declaration val atLeast2D: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor A tensor with at least two dimensions. See Also static member atLeast2D: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.atLeast3D.html": {
    "href": "api/Tensor.ITensorModule.atLeast3D.html",
    "title": "Method atLeast3D | Tensor for F#",
    "keywords": "Method atLeast3D val atLeast3D: ITensor -> ITensor Pads the tensor from the left with size-one dimensions until it has at least three dimensions. Declaration val atLeast3D: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor A tensor with at least three dimensions. See Also static member atLeast3D: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.copy.html": {
    "href": "api/Tensor.ITensorModule.copy.html",
    "title": "Method copy | Tensor for F#",
    "keywords": "Method copy val copy: ITensor -> ITensor Returns a copy of the tensor. Declaration val copy: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to copy. Returns Type Description ITensor A copy of the tensor. See Also static member copy: Tensor<'T> * TensorOrder option -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.transfer.html": {
    "href": "api/Tensor.ITensorModule.transfer.html",
    "title": "Method transfer | Tensor for F#",
    "keywords": "Method transfer val transfer: ITensorDevice -> ITensor -> ITensor Transfers a tensor to the specifed device. Declaration val transfer: dev:ITensorDevice -> src:ITensor -> ITensor Parameters Type Name Description ITensorDevice dev The target device. ITensor src Returns Type Description ITensor A tensor on the target device. See Also static member transfer: ITensorDevice -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Host.TensorHostStorage-1.-ctor.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: 'T [] -> TensorHostStorage<'T> Implicit constructor. Declaration new: data:'T [] -> TensorHostStorage<'T> Parameters Type Name Description 'T [] data Returns Type Description TensorHostStorage <'T> new: int64 -> TensorHostStorage<'T> allocates a new data array with the given number of elements Declaration new: nElems:int64 -> TensorHostStorage<'T> Parameters Type Name Description int64 nElems Returns Type Description TensorHostStorage <'T>"
  },
  "api/Tensor.Algorithm.LinAlg.generalInverse.html": {
    "href": "api/Tensor.Algorithm.LinAlg.generalInverse.html",
    "title": "Method generalInverse | Tensor for F#",
    "keywords": "Method generalInverse val generalInverse: Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Computes the generalized inverse I, solvability constraints S and null-space N of the specified matrix L. L can be of any shape and rank. The return values is a tuple (I, S, N). The following properties are fulfilled. Inverse: M .* I .* M = M. Solvability: S .* M = 0. Null-space: M .* N = 0. This has the following consequences for a linear equation system of the form y = M .* x: If y comes from the solvable space (i.e. S .* y = 0), then the value x = I .* y gives one solution of y = M .* x. Adding any linear combination of the columns of N to this x yields another solution, i.e. y = M .* x = M .* (x + N .* z) for any z. If x contains no component from the null-space (i.e. N^T .* x = 0), then we can recover x from y = M .* x by x = I .* y. (TODO: check last sentence, because it was violated in test1) Declaration val generalInverse: L:Tensor<'T> -> Tensor<'T> * Tensor<'T> * Tensor<'T> Parameters Type Name Description Tensor <'T> L Returns Type Description Tensor <'T> * Tensor <'T> * Tensor <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Algorithm.LinAlg.smithNormalForm.html": {
    "href": "api/Tensor.Algorithm.LinAlg.smithNormalForm.html",
    "title": "Method smithNormalForm | Tensor for F#",
    "keywords": "Method smithNormalForm val smithNormalForm: Tensor<bigint> -> Tensor<bigint> * Tensor<bigint> * Tensor<bigint> Computes the Smith Normal Form S of integer matrix A and returns a tuple (U, S, V) so that S = U .* A .* V, where U and V are invertible matrices and S is a positive, diagonal matrix with the property that each element of the diagonal divides all of its successors. Declaration val smithNormalForm: A:Tensor<bigint> -> Tensor<bigint> * Tensor<bigint> * Tensor<bigint> Parameters Type Name Description Tensor < bigint > A Returns Type Description Tensor < bigint > * Tensor < bigint > * Tensor < bigint > Remarks The Smith Normal Form exists for a matrix of any shape or rank."
  },
  "api/Tensor.Algorithm.LinAlg.integerInverse.html": {
    "href": "api/Tensor.Algorithm.LinAlg.integerInverse.html",
    "title": "Method integerInverse | Tensor for F#",
    "keywords": "Method integerInverse val integerInverse: Tensor<bigint> -> Tensor<Rat> * Tensor<bigint> * Tensor<bigint> Computes the inverse I, solvability constraints S and null-space N of the specified integer matrix M, which can be of any shape and rank. The inversion is carried out over the domain of integers. The return values is a tuple (I, S, N), which fulfilles the following properties: Inverse: M .* I .* M = M. Solvability: S .* M = 0. Null-space: M .* N = 0. The equation system M .* x = y is solvable when S .* y = 0 and I .* y is an integer vector. In this case, the set of solutions is given by x = I .* y + N .* z where z is any integer vector. Declaration val integerInverse: M:Tensor<bigint> -> Tensor<Rat> * Tensor<bigint> * Tensor<bigint> Parameters Type Name Description Tensor < bigint > M Returns Type Description Tensor < Rat > * Tensor < bigint > * Tensor < bigint >"
  },
  "api/Tensor.Algorithm.BigIntegerExtensions.___System.Numerics.BigInteger.BigInteger.Bezout.Static.html": {
    "href": "api/Tensor.Algorithm.BigIntegerExtensions.___System.Numerics.BigInteger.BigInteger.Bezout.Static.html",
    "title": "Method Bezout | Tensor for F#",
    "keywords": "Method Bezout extension System.Numerics.BigInteger.Bezout: bigint * bigint -> bigint * bigint * bigint Computes the GCD of a and b and the coefficients of Bezout's identity using the extended Euclidean algorithm. Returns a tuple of (gcd, x, y) so that: a x + b y = gcd(a,b). The returned GCD is always non-negative and gcd(0, 0)=0. Declaration extension System.Numerics.BigInteger.Bezout: a:bigint * b:bigint -> bigint * bigint * bigint Parameters Type Name Description bigint a bigint b Returns Type Description bigint * bigint * bigint"
  },
  "api/Tensor.Tensor-1.layout.html": {
    "href": "api/Tensor.Tensor-1.layout.html",
    "title": "Method layout | Tensor for F#",
    "keywords": "Method layout static member layout: Tensor<'T> -> TensorLayout Memory layout of the tensor. Declaration static member layout: a:Tensor<'T> -> TensorLayout Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description TensorLayout Memory layout. See Also member Layout: unit -> TensorLayout"
  },
  "api/Tensor.Tensor-1.linspace.html": {
    "href": "api/Tensor.Tensor-1.linspace.html",
    "title": "Method linspace | Tensor for F#",
    "keywords": "Method linspace static member linspace: ITensorDevice -> 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. Declaration static member linspace: dev:ITensorDevice -> start:'T -> stop:'T -> nElems:int64 -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. 'T start The starting value. 'T stop The end value, which is not included. int64 nElems The size of the vector. Returns Type Description Tensor <'T> The new tensor. Remarks A new vector with nElems elements is created on the specified device. The vector is filled with [start; start+1 incr; start+2 incr; ...; stop] where incr = (stop - start) / (nElems - 1) . Examples let a = Tensor.linspace HostTensor.Dev 1.0 2.0 5L // a = [1.0; 1.2; 1.4; 1.6; 1.8] See Also val arange: 'T -> 'T -> 'T -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.max.html": {
    "href": "api/Tensor.Tensor-1.max.html",
    "title": "Method max | Tensor for F#",
    "keywords": "Method max static member max: Tensor<'T> -> 'T Calculates the maximum of all elements. Declaration static member max: src:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description 'T A scalar containing the result of this operation. Remarks The maximum of all elements is calculated. An empty maximum gives the smallest possible value of the used data type. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.min a // b = 8.0 See Also static member maxAxis: int -> Tensor<'T> -> Tensor<'T> static member maxTensor: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.maxAxis.html": {
    "href": "api/Tensor.Tensor-1.maxAxis.html",
    "title": "Method maxAxis | Tensor for F#",
    "keywords": "Method maxAxis static member maxAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the maximum value of the elements along the specified axis. Declaration static member maxAxis: ax:int -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to calculate the maximum along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The maximum is calculated along the specified axis. An empty maximum gives the smallest possible value of the used data type. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.maxAxis 1 a // b = [4.0; 8.0] See Also member FillMaxAxis: int -> Tensor<'T> -> unit static member max: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.maxElemwise.html": {
    "href": "api/Tensor.Tensor-1.maxElemwise.html",
    "title": "Method maxElemwise | Tensor for F#",
    "keywords": "Method maxElemwise static member maxElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise maximum. Declaration static member maxElemwise: a:Tensor<'T> -> b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Finds the maximum of each element of tensor a and the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = Tensor.maxElemwise a b // c = [5.0; 6.0; 7.0] See Also member FillMaxElemwise: Tensor<'T> -> Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.maxTensor.html": {
    "href": "api/Tensor.Tensor-1.maxTensor.html",
    "title": "Method maxTensor | Tensor for F#",
    "keywords": "Method maxTensor static member maxTensor: Tensor<'T> -> Tensor<'T> Calculates the maximum all elements returning a Tensor. Declaration static member maxTensor: src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new scalar tensor containing the result of this operation. See Also static member max: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.mean.html": {
    "href": "api/Tensor.Tensor-1.mean.html",
    "title": "Method mean | Tensor for F#",
    "keywords": "Method mean static member mean: Tensor<'T> -> 'T Calculates the mean of the tensor. Declaration static member mean: a:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> a The tensor containing the source values. Returns Type Description 'T The mean estimate. Remarks The mean is calculated over all elements of the tensor. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.mean a // b = 4.5 See Also static member meanAxis: int -> Tensor<'T> -> Tensor<'T> static member var: Tensor<'T> * int64 option -> 'T static member std: Tensor<'T> * int64 option -> 'T"
  },
  "api/Tensor.Tensor-1.meanAxis.html": {
    "href": "api/Tensor.Tensor-1.meanAxis.html",
    "title": "Method meanAxis | Tensor for F#",
    "keywords": "Method meanAxis static member meanAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the mean of the elements along the specified axis. Declaration static member meanAxis: axis:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int axis Tensor <'T> a The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The mean is calculated along the specified axis. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.meanAxis 1 a // b = [2.5; 6.5] See Also static member mean: Tensor<'T> -> 'T static member varAxis: int * Tensor<'T> * int64 option -> Tensor<'T> static member stdAxis: int * Tensor<'T> * int64 option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.min.html": {
    "href": "api/Tensor.Tensor-1.min.html",
    "title": "Method min | Tensor for F#",
    "keywords": "Method min static member min: Tensor<'T> -> 'T Calculates the minimum of all elements. Declaration static member min: src:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description 'T A scalar containing the result of this operation. Remarks The minimum of all elements is calculated. An empty minimum gives the largest possible value of the used data type. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.min a // b = 1.0 See Also static member minAxis: int -> Tensor<'T> -> Tensor<'T> static member minTensor: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.minAxis.html": {
    "href": "api/Tensor.Tensor-1.minAxis.html",
    "title": "Method minAxis | Tensor for F#",
    "keywords": "Method minAxis static member minAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the minimum value of the elements along the specified axis. Declaration static member minAxis: ax:int -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to calculate the minimum along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The minimum is calculated along the specified axis. An empty minimum gives the largest possible value of the used data type. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.minAxis 1 a // b = [1.0; 5.0] See Also member FillMinAxis: int -> Tensor<'T> -> unit static member min: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.minElemwise.html": {
    "href": "api/Tensor.Tensor-1.minElemwise.html",
    "title": "Method minElemwise | Tensor for F#",
    "keywords": "Method minElemwise static member minElemwise: Tensor<'T> -> Tensor<'T> -> Tensor<'T> Element-wise minimum. Declaration static member minElemwise: a:Tensor<'T> -> b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Finds the minimum of each element of tensor a and the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = Tensor.minElemwise a b // c = [2.0; 3.0; 4.0] See Also member FillMinElemwise: Tensor<'T> -> Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.minTensor.html": {
    "href": "api/Tensor.Tensor-1.minTensor.html",
    "title": "Method minTensor | Tensor for F#",
    "keywords": "Method minTensor static member minTensor: Tensor<'T> -> Tensor<'T> Calculates the minimum all elements returning a Tensor. Declaration static member minTensor: src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new scalar tensor containing the result of this operation. See Also static member min: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.nDims.html": {
    "href": "api/Tensor.Tensor-1.nDims.html",
    "title": "Method nDims | Tensor for F#",
    "keywords": "Method nDims static member nDims: Tensor<'T> -> int Dimensionality of the tensor. Declaration static member nDims: a:Tensor<'T> -> int Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description int Number of dimensions. See Also member NDims: unit -> int"
  },
  "api/Tensor.Tensor-1.nElems.html": {
    "href": "api/Tensor.Tensor-1.nElems.html",
    "title": "Method nElems | Tensor for F#",
    "keywords": "Method nElems static member nElems: Tensor<'T> -> int64 Total number of elements within the tensor. Declaration static member nElems: a:Tensor<'T> -> int64 Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description int64 Number of elements. See Also member NElems: unit -> int64"
  },
  "api/Tensor.Tensor-1.norm.html": {
    "href": "api/Tensor.Tensor-1.norm.html",
    "title": "Method norm | Tensor for F#",
    "keywords": "Method norm static member norm: Tensor<'T> * 'T option -> 'T Calculates the norm of the (flattened) tensor. Declaration static member norm: a:Tensor<'T> * ord:'T option -> 'T Parameters Type Name Description Tensor <'T> a The tensor containing the source values. 'T option ord The order (power) of the norm. (default: 2) Returns Type Description 'T A new tensor containing the result of this operation. Remarks The norm is calculated over all elements of the tensor. It is defined by sqrt (sum_i (x_i**ord)) . Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.norm a // 14.283 See Also static member normAxis: int * Tensor<'T> * 'T option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.normAxis.html": {
    "href": "api/Tensor.Tensor-1.normAxis.html",
    "title": "Method normAxis | Tensor for F#",
    "keywords": "Method normAxis static member normAxis: int * Tensor<'T> * 'T option -> Tensor<'T> Calculates the norm along the specified axis. Declaration static member normAxis: axis:int * a:Tensor<'T> * ord:'T option -> Tensor<'T> Parameters Type Name Description int axis The axis to operate along. Tensor <'T> a The tensor containing the source values. 'T option ord The order (power) of the norm. (default: 2) Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The norm is calculated along the specified axis. It is defined by sqrt (sum_i (x_i**ord)) . Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.normAxis (1, a) // [5.477; 13.191] See Also static member norm: Tensor<'T> * 'T option -> 'T"
  },
  "api/Tensor.Tensor-1.varAxis.html": {
    "href": "api/Tensor.Tensor-1.varAxis.html",
    "title": "Method varAxis | Tensor for F#",
    "keywords": "Method varAxis static member varAxis: int * Tensor<'T> * int64 option -> Tensor<'T> Calculates the variance of the elements along the specified axis. Declaration static member varAxis: axis:int * a:Tensor<'T> * ddof:int64 option -> Tensor<'T> Parameters Type Name Description int axis Tensor <'T> a The tensor containing the source values. int64 option ddof The delta degrees of freedom. (default: 0L) Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The variance is calculated along the specified axis. The parameter ddof specifies the difference between the number of elements and the degrees of freedom for the computation of the variance. Use ddof=1 to obtain an unbiased estimate and ddof=0 for a maximum-likelihood estimate. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.varAxis (1, a, ddof=1L) See Also static member var: Tensor<'T> * int64 option -> 'T static member meanAxis: int -> Tensor<'T> -> Tensor<'T> static member stdAxis: int * Tensor<'T> * int64 option -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.zeros.html": {
    "href": "api/Tensor.Tensor-1.zeros.html",
    "title": "Method zeros | Tensor for F#",
    "keywords": "Method zeros static member zeros: ITensorDevice -> int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). Declaration static member zeros: dev:ITensorDevice -> shape:int64 list -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The device to create the tensor on. int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor of the specified shape is created on the specified device. The tensor is filled with zeros. Examples let a = Tensor<float>.zeros HostTensor.Dev [2L; 3L] // a = [[0.0; 0.0; 0.0] // [0.0; 0.0; 0.0]] See Also static member zerosLike: Tensor<'T> -> Tensor<'T> static member ones: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.zerosLike.html": {
    "href": "api/Tensor.Tensor-1.zerosLike.html",
    "title": "Method zerosLike | Tensor for F#",
    "keywords": "Method zerosLike static member zerosLike: Tensor<'T> -> Tensor<'T> Creates a new tensor filled with zeros using the specified tensor as template. Declaration static member zerosLike: tmpl:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> tmpl The template tensor. Returns Type Description Tensor <'T> The new tensor. Remarks A new tensor is created with the same shape and on the same device as tmpl . The tensor is filled with zeros. See Also static member zeros: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Value.html": {
    "href": "api/Tensor.Tensor-1.Value.html",
    "title": "Property Value | Tensor for F#",
    "keywords": "Property Value property Value: 'T Accesses the value of a zero-dimensional (scalar) tensor. Declaration property Value: 'T with get, set Property Value Type Description 'T The scalar value of the tensor. Remarks Gets or sets the value of a scalar tensor. The tensor must have zero dimensions. Examples let a = HostTensor.sclar 2.0 let b = a.Value // 2.0 a.Value <- 3.0 // a = 3.0 Exceptions Type Condition System.IndexOutOfRangeException Raised when the tensor is not zero-dimensional. See Also member Item: int64 list -> 'T"
  },
  "api/Tensor.Tensor-1.M.html": {
    "href": "api/Tensor.Tensor-1.M.html",
    "title": "Property M | Tensor for F#",
    "keywords": "Property M property M: Tensor<bool> list -> Tensor<'T> Picks elements from a tensor using one or more boolean mask tensors. Declaration property M: Tensor<bool> list -> Tensor<'T> with get, set Parameters Type Name Description Tensor < bool > list masks A list of boolean mask tensors or val NoMask . Property Value Type Description Tensor <'T> All elements from the tensor for which the mask is true. Remarks Masking picks elements from the tensor for which the corresponding element in the mask tensor is true. The mask can, for example, be generated by one or more element-wise comparison operation. The get operation returns a copy of the selected elements of the tensor. The set operation replaces the selected elements with a copy of the specified tensor. If a dimension should not be masked, specify val NoMask instead of a mask tensor. This mask specification variant is intended for programmatically generated ranges. For most use cases the variant property M: Tensor<bool> -> Tensor<'T> is more succinct and thus the recommended method. Exceptions Type Condition System.InvalidArgumentException Raised when the mask is incompatible with the tensor. See Also property M: Tensor<bool> -> Tensor<'T> property M: Tensor<bool> -> Tensor<'T> Picks elements from a tensor using one or more boolean mask tensors. Declaration property M: Tensor<bool> -> Tensor<'T> with get, set Parameters Type Name Description Tensor < bool > m0 A boolean mask tensor or val NoMask . Property Value Type Description Tensor <'T> All elements from the tensor for which the mask is true. Remarks Masking picks elements from the tensor for which the corresponding element in the mask tensor is true. The mask can, for example, be generated by one or more element-wise comparison operation. The get operation returns a copy of the selected elements of the tensor. The set operation replaces the selected elements with a copy of the specified tensor. If a dimension should not be masked, specify val NoMask instead of a mask tensor. For clarity the documentation does not list all overloads of M . However, this masking method can be used for up to 5 dimensions, as shown in the example. For programmatically generated ranges or for more than 5 dimensions, the mask specification variant property M: Tensor<bool> list -> Tensor<'T> is available. Currently this operation is only supported for tensors stored on the host. Support for CUDA tensors is planned in the future. Examples let a = HostTensor.ofList [[1.0; 2.0; 3.0] [4.0; 5.0; 6.0]] // masked get with one mask for the whole tensor let m = HostTensor.ofList [[true; true; false] [false; false; true ]] let b = a.M(m) // b = [1.0; 2.0; 6.0] // an element-wise comparison operator can be used to create the mask let c = a.M(a >>>> 3.5) // c = [4.0; 5.0; 6.0] // masked get with one mask per dimension let m0 = HostTensor.ofList [true; false] let m1 = HostTensor.ofList [false; false; true] let d = a.M(m0, m1) // d = [3.0] // masked get using only one dimension let m0 = HostTensor.ofList [true; false] let e = a.M(m0, NoMask) // e = [[1.0; 2.0; 3.0]] // masked set with one mask for the whole tensor let m = HostTensor.ofList [[true; true; false] [false; false; true ]] a.M(m) <- [8.0; 9.0; 0.0] // a = [[8.0; 9.0; 3.0] // [4.0; 5.0; 0.0]] Exceptions Type Condition System.InvalidArgumentException Raised when the mask is incompatible with the tensor. See Also property M: Tensor<bool> list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Item.html": {
    "href": "api/Tensor.Tensor-1.Item.html",
    "title": "Property Item | Tensor for F#",
    "keywords": "Property Item property Item: int64 -> Tensor<'T> Accesses a slice (part) of the tensor. Declaration property Item: int64 -> Tensor<'T> with get, set Parameters Type Name Description int64 i0 The range of the tensor to select. Property Value Type Description Tensor <'T> A view of the selected part of the tensor. Remarks Indexing is zero-based. This indexing options allows to select a part (called slice) of the tensor. The get operation returns a view of the specified part of the tensor. Modifications done to that view will affect the original tensor. Also, modifying the orignal tensor will affect the view. The slicing specifications follows standard F# practice. Specifying an integer for the index of a dimension, selects that index for the dimension. Specifying * for a dimension, selects all indices of the dimension. Specifying f..l for a dimension, select all indices from f to (including) l for the dimension. For clarity the documentation does not list all overloads of the Item property and GetSlice, SetSlice methods. However, this slicing method can be used for up to 5 dimensions, as shown in the example. For programmatically generated ranges or for more than 5 dimensions, the range specification variant property Item: Rng list -> Tensor<'T> is available. Examples let a = HostTensor.ofList [[1.0; 2.0; 3.0] [4.0; 5.0; 6.0]] // get view let b = a.[0L, 1L] // b = 2.0 let c = a.[0L, *] // b = [1.0; 2.0; 3.0] let d = a.[1L, 0L..1L] // b = [4.0; 5.0] let e = a.[1L..1L, 0L..1L] // b = [[4.0; 5.0]] // set view a.[0L, *] <- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0] // [4.0; 5.0; 6.0]] // modifiying view affects original tensor d.[[1L]] <- 0.0 // a = [[7.0; 8.0; 9.0] // [4.0; 0.0; 6.0]] Exceptions Type Condition System.IndexOutOfRangeException Raised when the specified range is out of range. See Also property Item: Rng list -> Tensor<'T> property Item: Rng list -> Tensor<'T> Accesses a slice (part) of the tensor. Declaration property Item: Rng list -> Tensor<'T> with get, set Parameters Type Name Description Rng list rng The range of the tensor to select. Property Value Type Description Tensor <'T> A view of the selected part of the tensor. Remarks This range specification variant is intended for programmatically generated ranges. For most use cases the variant property Item: int64 -> Tensor<'T> allows vastly simpler range specifications and is the recommended method. Indexing is zero-based. This indexing options allows to select a part (called slice) of the tensor. The get operation returns a view of the specified part of the tensor. Modifications done to that view will affect the original tensor. Also, modifying the orignal tensor will affect the view. See Rng (union) for available range specifications. Examples let a = HostTensor.ofList [[1.0; 2.0; 3.0] [4.0; 5.0; 6.0]] // get view let b = a.[[Rng.Elem 0L; Rng.Elem 1L]] // b = 2.0 let c = a.[[Rng.Elem 0L; Rng.All]] // b = [1.0; 2.0; 3.0] let d = a.[[Rng.Elem 1L; Rng.Rng (Some 0L, Some 1L)]] // b = [4.0; 5.0] let e = a.[[Rng.Rng (Some 1L, Some 1L); Rng (Some 0L, Some 1L)]] // b = [[4.0; 5.0]] // set view a.[[Rng.Elem 0L; Rng.All]] <- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0] // [4.0; 5.0; 6.0]] // modifiying view affects original tensor d.[[1L]] <- 0.0 // a = [[7.0; 8.0; 9.0] // [4.0; 0.0; 6.0]] Exceptions Type Condition System.IndexOutOfRangeException Raised when the specified range is out of range. See Also property Item: int64 -> Tensor<'T> property Item: int64 list -> 'T Accesses a single element within the tensor. Declaration property Item: int64 list -> 'T with get, set Parameters Type Name Description int64 list idx A list consisting of the indicies of the element to access. The list must have one entry per dimension of this tensor. Property Value Type Description 'T The value of the selected element. Remarks Indexing is zero-based. Use property Item: int64 [] -> 'T for faster element access. Examples let a = HostTensor.ofList [[1.0; 2.0] [3.0; 4.0]] let b = a.[[1L; 1L]] // b = 4.0 a.[[1L; 0L]] <- 6.0 // a = [[1.0; 2.0] // [6.0; 4.0]] Exceptions Type Condition System.IndexOutOfRangeException Raised when the specified indicies are out of range. See Also property Item: int64 [] -> 'T member Value: unit -> 'T property Item: int64 [] -> 'T Accesses a single element within the tensor. Declaration property Item: int64 [] -> 'T with get, set Parameters Type Name Description int64 [] idx An array consisting of the indicies of the element to access. The arry must have one entry per dimension of this tensor. Property Value Type Description 'T The value of the selected element. Remarks Indexing is zero-based. Examples let a = HostTensor.ofList [[1.0; 2.0] [3.0; 4.0]] let b = a.[[|1L; 1L|]] // b = 4.0 a.[[|1L; 0L|]] <- 6.0 // a = [[1.0; 2.0] // [6.0; 4.0]] Exceptions Type Condition System.IndexOutOfRangeException Raised when the specified indicies are out of range. See Also property Item: int64 list -> 'T"
  },
  "api/Tensor.Tensor-1.T.html": {
    "href": "api/Tensor.Tensor-1.T.html",
    "title": "Property T | Tensor for F#",
    "keywords": "Property T property T: Tensor<'T> Transpose of a matrix. Declaration property T: Tensor<'T> with get Property Value Type Description Tensor <'T> The transposed matrx. Remarks If the given tensor has more then two dimensions, the last two axes are swapped. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 5L] let b = a.T // b.Shape = [5L; 3L] See Also static member permuteAxes: int list -> Tensor<'T> -> Tensor<'T> static member swapDim: int -> int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.Storage.html": {
    "href": "api/Tensor.Tensor-1.Storage.html",
    "title": "Property Storage | Tensor for F#",
    "keywords": "Property Storage property Storage: ITensorStorage<'T> The storage object that holds the data of this tensor. Declaration property Storage: ITensorStorage<'T> with get Property Value Type Description ITensorStorage <'T> Storage object. Remarks The storage object holds the actual data of the tensor. A storage object can be associated with one or more tensors, i.e. it can be shared between multiple tensors. Sharing occurs, for example, when a view into an existing tensor is created or the tensor is reshapred. The actual type of the storage object depends on the device the data of the tensor is stored on. For tensors stored in host memory the storage object type is TensorHostStorage<'T> . For tensors stored on a CUDA GPU the storage object type is TensorCudaStorage<'T> . See Also member Dev: unit -> ITensorDevice member Layout: unit -> TensorLayout"
  },
  "api/Tensor.Tensor-1.Shape.html": {
    "href": "api/Tensor.Tensor-1.Shape.html",
    "title": "Property Shape | Tensor for F#",
    "keywords": "Property Shape property Shape: int64 list Shape of this tensor. Declaration property Shape: int64 list with get Property Value Type Description int64 list Shape. Remarks Provides the shape of this tensor. A tensor is empty of any dimension has size zero. A zero-dimensional tensor has an empty shape and contains one element. Examples let a = HostTensor.ofList [[1.0; 2.0; 5.0] [3.0; 4.0; 6.0]] let c = a.Shape // [2L; 3L] See Also static member reshape: int64 list -> Tensor<'T> -> Tensor<'T> member NDims: unit -> int member NElems: unit -> int64"
  },
  "api/Tensor.Tensor-1.Pretty.html": {
    "href": "api/Tensor.Tensor-1.Pretty.html",
    "title": "Property Pretty | Tensor for F#",
    "keywords": "Property Pretty property Pretty: string String representation of the tensor limited to 10 elements per dimension. Declaration property Pretty: string with get Property Value Type Description string A (shortened) string representation of this tensor See Also member ToString: int64 -> string member Full: unit -> string"
  },
  "api/Tensor.Tensor-1.NElems.html": {
    "href": "api/Tensor.Tensor-1.NElems.html",
    "title": "Property NElems | Tensor for F#",
    "keywords": "Property NElems property NElems: int64 Total number of elements within this tensor. Declaration property NElems: int64 with get Property Value Type Description int64 Number of elements. Remarks Counts the total number of elements of this tensor. A zero-dimensional tensor contains one element, i.e. it is a scalar. Examples let a = HostTensor.ofList [[1.0; 2.0; 5.0] [3.0; 4.0; 6.0]] let c = a.NElems // 6L See Also member Shape: unit -> int64 list"
  },
  "api/Tensor.Tensor-1.NDims.html": {
    "href": "api/Tensor.Tensor-1.NDims.html",
    "title": "Property NDims | Tensor for F#",
    "keywords": "Property NDims property NDims: int Dimensionality of this tensor. Declaration property NDims: int with get Property Value Type Description int Number of dimensions. Remarks Provides the number of dimensions of this tensor. A zero-dimensional tensor contains one element, i.e. it is a scalar. Examples let a = HostTensor.ofList [[1.0; 2.0; 5.0] [3.0; 4.0; 6.0]] let c = a.NDims // 2 See Also member Shape: unit -> int64 list"
  },
  "api/Tensor.Tensor-1.Layout.html": {
    "href": "api/Tensor.Tensor-1.Layout.html",
    "title": "Property Layout | Tensor for F#",
    "keywords": "Property Layout property Layout: TensorLayout Memory layout of this tensor. Declaration property Layout: TensorLayout with get Property Value Type Description TensorLayout Memory layout. Remarks Provides information of how the data is stored within this tensor. See Also member Storage: unit -> ITensorStorage<'T> member Shape: unit -> int64 list"
  },
  "api/Tensor.Tensor-1.Full.html": {
    "href": "api/Tensor.Tensor-1.Full.html",
    "title": "Property Full | Tensor for F#",
    "keywords": "Property Full property Full: string Unabreviated string representation of the tensor. Declaration property Full: string with get Property Value Type Description string An unabreviated string representation of this tensor See Also member ToString: int64 -> string member Pretty: unit -> string"
  },
  "api/Tensor.Tensor-1.Dev.html": {
    "href": "api/Tensor.Tensor-1.Dev.html",
    "title": "Property Dev | Tensor for F#",
    "keywords": "Property Dev property Dev: ITensorDevice Device the data of tensor is stored on. Declaration property Dev: ITensorDevice with get Property Value Type Description ITensorDevice Data storage device. Remarks For tensors stored in host memory the value of this property is HostTensor.Dev . For tensors stored on a CUDA GPU the value of this property is CudaTensor.Dev . See Also member Storage: unit -> ITensorStorage<'T>"
  },
  "api/Tensor.Tensor-1.DataType.html": {
    "href": "api/Tensor.Tensor-1.DataType.html",
    "title": "Property DataType | Tensor for F#",
    "keywords": "Property DataType property DataType: Type Type of data stored within this tensor. Declaration property DataType: Type with get Property Value Type Description System.Type Data type. Remarks The data type is typeof<'T> . See Also static member convert: Tensor<'C> -> Tensor<'T>"
  },
  "api/Tensor.Host.BLASModule.__cblas_sdot.Invoke.html": {
    "href": "api/Tensor.Host.BLASModule.__cblas_sdot.Invoke.html",
    "title": "Method Invoke | Tensor for F#",
    "keywords": "Method Invoke abstract member Invoke: blas_int * nativeint * blas_int * nativeint * blas_int -> single Declaration abstract member Invoke: n:blas_int * x:nativeint * incx:blas_int * y:nativeint * incy:blas_int -> single Parameters Type Name Description blas_int n nativeint x blas_int incx nativeint y blas_int incy Returns Type Description single"
  },
  "api/Tensor.Host.TensorHostBackend-1.-ctor.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: TensorLayout * TensorHostStorage<'T> -> TensorHostBackend<'T> Implicit constructor. Declaration new: layout:TensorLayout * storage:TensorHostStorage<'T> -> TensorHostBackend<'T> Parameters Type Name Description TensorLayout layout TensorHostStorage <'T> storage Returns Type Description TensorHostBackend <'T>"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Abs.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Abs.html",
    "title": "Method Abs | Tensor for F#",
    "keywords": "Method Abs interface ITensorBackend<'T> with member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Abs: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Acos.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Acos.html",
    "title": "Method Acos | Tensor for F#",
    "keywords": "Method Acos interface ITensorBackend<'T> with member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Acos: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Add.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Add.html",
    "title": "Method Add | Tensor for F#",
    "keywords": "Method Add interface ITensorBackend<'T> with member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Add: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-AllLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-AllLastAxis.html",
    "title": "Method AllLastAxis | Tensor for F#",
    "keywords": "Method AllLastAxis interface ITensorBackend<'T> with member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member AllLastAxis: trgt:ITensorFrontend<bool> * src:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src Overrides abstract member ITensorBackend.AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-And.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-And.html",
    "title": "Method And | Tensor for F#",
    "keywords": "Method And interface ITensorBackend<'T> with member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member And: trgt:ITensorFrontend<bool> * a:ITensorFrontend<bool> * b:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > a ITensorFrontend < bool > b Overrides abstract member ITensorBackend.And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-AnyLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-AnyLastAxis.html",
    "title": "Method AnyLastAxis | Tensor for F#",
    "keywords": "Method AnyLastAxis interface ITensorBackend<'T> with member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member AnyLastAxis: trgt:ITensorFrontend<bool> * src:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src Overrides abstract member ITensorBackend.AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ArgMaxLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ArgMaxLastAxis.html",
    "title": "Method ArgMaxLastAxis | Tensor for F#",
    "keywords": "Method ArgMaxLastAxis interface ITensorBackend<'T> with member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ArgMaxLastAxis: trgt:ITensorFrontend<int64> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ArgMinLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ArgMinLastAxis.html",
    "title": "Method ArgMinLastAxis | Tensor for F#",
    "keywords": "Method ArgMinLastAxis interface ITensorBackend<'T> with member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ArgMinLastAxis: trgt:ITensorFrontend<int64> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Asin.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Asin.html",
    "title": "Method Asin | Tensor for F#",
    "keywords": "Method Asin interface ITensorBackend<'T> with member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Asin: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Atan.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Atan.html",
    "title": "Method Atan | Tensor for F#",
    "keywords": "Method Atan interface ITensorBackend<'T> with member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Atan: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedInvert.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedInvert.html",
    "title": "Method BatchedInvert | Tensor for F#",
    "keywords": "Method BatchedInvert interface ITensorBackend<'T> with member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedInvert: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedMatMatDot.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedMatMatDot.html",
    "title": "Method BatchedMatMatDot | Tensor for F#",
    "keywords": "Method BatchedMatMatDot interface ITensorBackend<'T> with member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedMatMatDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedSVD.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-BatchedSVD.html",
    "title": "Method BatchedSVD | Tensor for F#",
    "keywords": "Method BatchedSVD interface ITensorBackend<'T> with member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedSVD: trgtS:ITensorFrontend<'T> * trgtUV:ITensorFrontend<'T> * ITensorFrontend<'T> option * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgtS ITensorFrontend <'T> * ITensorFrontend <'T> option trgtUV ITensorFrontend <'T> src Overrides abstract member ITensorBackend.BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Ceiling.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Ceiling.html",
    "title": "Method Ceiling | Tensor for F#",
    "keywords": "Method Ceiling interface ITensorBackend<'T> with member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Ceiling: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Convert.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Convert.html",
    "title": "Method Convert | Tensor for F#",
    "keywords": "Method Convert interface ITensorBackend<'T> with member Convert: ITensorFrontend<'T> * ITensorFrontend<'?123664> -> unit Declaration interface ITensorBackend<'T> with member Convert: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'?123664> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'?123664> a Type Parameters Name Description '? Overrides abstract member ITensorBackend.Convert: ITensorFrontend<'T> * ITensorFrontend<'T1> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Copy.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Copy.html",
    "title": "Method Copy | Tensor for F#",
    "keywords": "Method Copy interface ITensorBackend<'T> with member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Copy: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Cos.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Cos.html",
    "title": "Method Cos | Tensor for F#",
    "keywords": "Method Cos interface ITensorBackend<'T> with member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Cos: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Cosh.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Cosh.html",
    "title": "Method Cosh | Tensor for F#",
    "keywords": "Method Cosh interface ITensorBackend<'T> with member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Cosh: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-CountTrueLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-CountTrueLastAxis.html",
    "title": "Method CountTrueLastAxis | Tensor for F#",
    "keywords": "Method CountTrueLastAxis interface ITensorBackend<'T> with member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member CountTrueLastAxis: trgt:ITensorFrontend<int64> * src:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src Overrides abstract member ITensorBackend.CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Divide.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Divide.html",
    "title": "Method Divide | Tensor for F#",
    "keywords": "Method Divide interface ITensorBackend<'T> with member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Divide: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Equal.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Equal.html",
    "title": "Method Equal | Tensor for F#",
    "keywords": "Method Equal interface ITensorBackend<'T> with member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Equal: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Exp.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Exp.html",
    "title": "Method Exp | Tensor for F#",
    "keywords": "Method Exp interface ITensorBackend<'T> with member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Exp: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Fill.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Fill.html",
    "title": "Method Fill | Tensor for F#",
    "keywords": "Method Fill member Fill: unit -> 'b * ITensorFrontend<'b> * bool -> unit Declaration member Fill: fn:unit -> 'b * trgt:ITensorFrontend<'b> * useThreads:bool -> unit Parameters Type Name Description unit -> 'b fn ITensorFrontend <'b> trgt bool useThreads Type Parameters Name Description 'b"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FillConst.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FillConst.html",
    "title": "Method FillConst | Tensor for F#",
    "keywords": "Method FillConst interface ITensorBackend<'T> with member FillConst: 'T * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FillConst: value:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend <'T> trgt Overrides abstract member ITensorBackend.FillConst: 'T * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FillIncrementing.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FillIncrementing.html",
    "title": "Method FillIncrementing | Tensor for F#",
    "keywords": "Method FillIncrementing interface ITensorBackend<'T> with member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FillIncrementing: start:'T * incr:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T start 'T incr ITensorFrontend <'T> trgt Overrides abstract member ITensorBackend.FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.FillIndexed.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.FillIndexed.html",
    "title": "Method FillIndexed | Tensor for F#",
    "keywords": "Method FillIndexed member FillIndexed: int64 [] -> 'b * ITensorFrontend<'b> * bool -> unit Declaration member FillIndexed: fn:int64 [] -> 'b * trgt:ITensorFrontend<'b> * useThreads:bool -> unit Parameters Type Name Description int64 [] -> 'b fn ITensorFrontend <'b> trgt bool useThreads Type Parameters Name Description 'b"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FindLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-FindLastAxis.html",
    "title": "Method FindLastAxis | Tensor for F#",
    "keywords": "Method FindLastAxis interface ITensorBackend<'T> with member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FindLastAxis: value:'T * trgt:ITensorFrontend<int64> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend < int64 > trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Floor.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Floor.html",
    "title": "Method Floor | Tensor for F#",
    "keywords": "Method Floor interface ITensorBackend<'T> with member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Floor: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.FoldLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.FoldLastAxis.html",
    "title": "Method FoldLastAxis | Tensor for F#",
    "keywords": "Method FoldLastAxis member FoldLastAxis: 'b -> 'c -> 'b * ITensorFrontend<'b> * ITensorFrontend<'b> * ITensorFrontend<'c> * bool -> unit Declaration member FoldLastAxis: fn:'b -> 'c -> 'b * initial:ITensorFrontend<'b> * trgt:ITensorFrontend<'b> * a:ITensorFrontend<'c> * useThreads:bool -> unit Parameters Type Name Description 'b -> 'c -> 'b fn ITensorFrontend <'b> initial ITensorFrontend <'b> trgt ITensorFrontend <'c> a bool useThreads Type Parameters Name Description 'b 'c"
  },
  "api/Tensor.Host.TensorHostBackend-1.FoldLastAxisIndexed.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.FoldLastAxisIndexed.html",
    "title": "Method FoldLastAxisIndexed | Tensor for F#",
    "keywords": "Method FoldLastAxisIndexed member FoldLastAxisIndexed: int64 [] -> '?123649 -> '?123650 -> '?123649 * ITensorFrontend<'?123649> * ITensorFrontend<'?123649> * ITensorFrontend<'?123650> * bool -> unit Declaration member FoldLastAxisIndexed: fn:int64 [] -> '?123649 -> '?123650 -> '?123649 * initial:ITensorFrontend<'?123649> * trgt:ITensorFrontend<'?123649> * a:ITensorFrontend<'?123650> * useThreads:bool -> unit Parameters Type Name Description int64 [] -> '?123649 -> '?123650 -> '?123649 fn ITensorFrontend <'?123649> initial ITensorFrontend <'?123649> trgt ITensorFrontend <'?123650> a bool useThreads Type Parameters Name Description '? '?"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Gather.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Gather.html",
    "title": "Method Gather | Tensor for F#",
    "keywords": "Method Gather interface ITensorBackend<'T> with member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Gather: trgt:ITensorFrontend<'T> * srcIndices:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list srcIndices ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.System-Collections-Generic-IEnumerable-1-GetEnumerator.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.System-Collections-Generic-IEnumerable-1-GetEnumerator.html",
    "title": "Method GetEnumerator | Tensor for F#",
    "keywords": "Method GetEnumerator interface IEnumerable<'T> with member GetEnumerator: unit -> IEnumerator<'T> Declaration interface IEnumerable<'T> with member GetEnumerator: unit -> IEnumerator<'T> Returns Type Description System.Collections.Generic.IEnumerator <'T> Overrides abstract member System.Collections.Generic.IEnumerable.GetEnumerator: unit -> System.Collections.Generic.IEnumerator<'T>"
  },
  "api/Tensor.Host.TensorHostBackend-1.System-Collections-IEnumerable-GetEnumerator.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.System-Collections-IEnumerable-GetEnumerator.html",
    "title": "Method GetEnumerator | Tensor for F#",
    "keywords": "Method GetEnumerator interface IEnumerable with member GetEnumerator: unit -> IEnumerator Declaration interface IEnumerable with member GetEnumerator: unit -> IEnumerator Returns Type Description System.Collections.IEnumerator Overrides abstract member System.Collections.IEnumerable.GetEnumerator: unit -> System.Collections.IEnumerator"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Greater.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Greater.html",
    "title": "Method Greater | Tensor for F#",
    "keywords": "Method Greater interface ITensorBackend<'T> with member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Greater: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-GreaterOrEqual.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-GreaterOrEqual.html",
    "title": "Method GreaterOrEqual | Tensor for F#",
    "keywords": "Method GreaterOrEqual interface ITensorBackend<'T> with member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member GreaterOrEqual: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-IfThenElse.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-IfThenElse.html",
    "title": "Method IfThenElse | Tensor for F#",
    "keywords": "Method IfThenElse interface ITensorBackend<'T> with member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member IfThenElse: trgt:ITensorFrontend<'T> * cond:ITensorFrontend<bool> * ifTrue:ITensorFrontend<'T> * ifFalse:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > cond ITensorFrontend <'T> ifTrue ITensorFrontend <'T> ifFalse Overrides abstract member ITensorBackend.IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-IsFinite.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-IsFinite.html",
    "title": "Method IsFinite | Tensor for F#",
    "keywords": "Method IsFinite interface ITensorBackend<'T> with member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member IsFinite: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Less.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Less.html",
    "title": "Method Less | Tensor for F#",
    "keywords": "Method Less interface ITensorBackend<'T> with member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Less: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Tanh.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Tanh.html",
    "title": "Method Tanh | Tensor for F#",
    "keywords": "Method Tanh interface ITensorBackend<'T> with member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Tanh: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Transfer.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Transfer.html",
    "title": "Method Transfer | Tensor for F#",
    "keywords": "Method Transfer interface ITensorBackend<'T> with member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool Declaration interface ITensorBackend<'T> with member Transfer: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> bool Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Returns Type Description bool Overrides abstract member ITensorBackend.Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-TrueIndices.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-TrueIndices.html",
    "title": "Method TrueIndices | Tensor for F#",
    "keywords": "Method TrueIndices interface ITensorBackend<'T> with member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member TrueIndices: trgt:ITensorFrontend<int64> * src:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src Overrides abstract member ITensorBackend.TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Truncate.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Truncate.html",
    "title": "Method Truncate | Tensor for F#",
    "keywords": "Method Truncate interface ITensorBackend<'T> with member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Truncate: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-UnaryMinus.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-UnaryMinus.html",
    "title": "Method UnaryMinus | Tensor for F#",
    "keywords": "Method UnaryMinus interface ITensorBackend<'T> with member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member UnaryMinus: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-UnaryPlus.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-UnaryPlus.html",
    "title": "Method UnaryPlus | Tensor for F#",
    "keywords": "Method UnaryPlus interface ITensorBackend<'T> with member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member UnaryPlus: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-VecVecDot.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-VecVecDot.html",
    "title": "Method VecVecDot | Tensor for F#",
    "keywords": "Method VecVecDot interface ITensorBackend<'T> with member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member VecVecDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Xor.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Xor.html",
    "title": "Method Xor | Tensor for F#",
    "keywords": "Method Xor interface ITensorBackend<'T> with member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Xor: trgt:ITensorFrontend<bool> * a:ITensorFrontend<bool> * b:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > a ITensorFrontend < bool > b Overrides abstract member ITensorBackend.Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-get_Item.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-get_Item.html",
    "title": "Method Item | Tensor for F#",
    "keywords": "Method Item interface ITensorBackend<'T> with member Item: int64 [] -> 'T Declaration interface ITensorBackend<'T> with member Item: idx:int64 [] -> 'T Parameters Type Name Description int64 [] idx Returns Type Description 'T"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-set_Item.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-set_Item.html",
    "title": "Method Item | Tensor for F#",
    "keywords": "Method Item interface ITensorBackend<'T> with member Item: int64 [] * 'T -> unit Declaration interface ITensorBackend<'T> with member Item: idx:int64 [] * value:'T -> unit Parameters Type Name Description int64 [] idx 'T value"
  },
  "api/Tensor.Host.TensorHostBackend-1.Storage.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Storage.html",
    "title": "Property Storage | Tensor for F#",
    "keywords": "Property Storage property Storage: TensorHostStorage<'T> underlying TensorHostStorate<'T> Declaration property Storage: TensorHostStorage<'T> with get Property Value Type Description TensorHostStorage <'T>"
  },
  "api/Tensor.Host.TensorHostBackend-1.Data.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Data.html",
    "title": "Property Data | Tensor for F#",
    "keywords": "Property Data property Data: 'T [] underlying data array Declaration property Data: 'T [] with get Property Value Type Description 'T []"
  },
  "api/Tensor.Host.PinnedMemory.-ctor.html": {
    "href": "api/Tensor.Host.PinnedMemory.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: GCHandle * int64 -> PinnedMemory Implicit constructor. Declaration new: gcHnd:GCHandle * size:int64 -> PinnedMemory Parameters Type Name Description System.Runtime.InteropServices.GCHandle gcHnd int64 size Returns Type Description PinnedMemory"
  },
  "api/Tensor.Host.PinnedMemory.System-IDisposable-Dispose.html": {
    "href": "api/Tensor.Host.PinnedMemory.System-IDisposable-Dispose.html",
    "title": "Method Dispose | Tensor for F#",
    "keywords": "Method Dispose interface IDisposable with member Dispose: unit -> unit Declaration interface IDisposable with member Dispose: unit -> unit Overrides abstract member System.IDisposable.Dispose: unit -> unit"
  },
  "api/Tensor.Host.PinnedMemory.Finalize.html": {
    "href": "api/Tensor.Host.PinnedMemory.Finalize.html",
    "title": "Method Finalize | Tensor for F#",
    "keywords": "Method Finalize override member Finalize: unit -> unit Declaration override member Finalize: unit -> unit"
  },
  "api/Tensor.Host.PinnedMemory.Size.html": {
    "href": "api/Tensor.Host.PinnedMemory.Size.html",
    "title": "Property Size | Tensor for F#",
    "keywords": "Property Size property Size: int64 size of storage array in bytes Declaration property Size: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.System-IDisposable-Dispose.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.System-IDisposable-Dispose.html",
    "title": "Method Dispose | Tensor for F#",
    "keywords": "Method Dispose interface IDisposable with member Dispose: unit -> unit Declaration interface IDisposable with member Dispose: unit -> unit Overrides abstract member System.IDisposable.Dispose: unit -> unit"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.Finalize.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.Finalize.html",
    "title": "Method Finalize | Tensor for F#",
    "keywords": "Method Finalize override member Finalize: unit -> unit Declaration override member Finalize: unit -> unit"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.Ptr.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.Ptr.html",
    "title": "Property Ptr | Tensor for F#",
    "keywords": "Property Ptr property Ptr: nativeint pointer to data Declaration property Ptr: nativeint with get Property Value Type Description nativeint"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.PinHnd.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.PinHnd.html",
    "title": "Property PinHnd | Tensor for F#",
    "keywords": "Property PinHnd property PinHnd: PinnedMemory GC memory pin handle Declaration property PinHnd: PinnedMemory with get Property Value Type Description PinnedMemory"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.HostArray.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.HostArray.html",
    "title": "Property HostArray | Tensor for F#",
    "keywords": "Property HostArray property HostArray: ITensorHostStorage the data array Declaration property HostArray: ITensorHostStorage with get Property Value Type Description ITensorHostStorage"
  },
  "api/Tensor.Cuda.CudaRegMemHnd.CudaRegisteredMemory.html": {
    "href": "api/Tensor.Cuda.CudaRegMemHnd.CudaRegisteredMemory.html",
    "title": "Property CudaRegisteredMemory | Tensor for F#",
    "keywords": "Property CudaRegisteredMemory property CudaRegisteredMemory: CudaRegisteredHostMemory<byte> the CudaRegisteredHostMemory Declaration property CudaRegisteredMemory: CudaRegisteredHostMemory<byte> with get Property Value Type Description ManagedCuda.CudaRegisteredHostMemory < byte >"
  },
  "api/Tensor.Cuda.CudaRegMem.get.html": {
    "href": "api/Tensor.Cuda.CudaRegMem.get.html",
    "title": "Method get | Tensor for F#",
    "keywords": "Method get val get: ITensorHostStorage -> CudaRegMemHnd get CudaRegMemHnd for already locked TensorHostStorage Declaration val get: data:ITensorHostStorage -> CudaRegMemHnd Parameters Type Name Description ITensorHostStorage data Returns Type Description CudaRegMemHnd"
  },
  "api/Tensor.Cuda.CudaRegMem.getCudaRegisteredMemory.html": {
    "href": "api/Tensor.Cuda.CudaRegMem.getCudaRegisteredMemory.html",
    "title": "Method getCudaRegisteredMemory | Tensor for F#",
    "keywords": "Method getCudaRegisteredMemory val getCudaRegisteredMemory: ITensorHostStorage -> CudaRegisteredHostMemory<byte> gets the CudaRegisteredMemory for already locked TensorHostStorage without incrementing the reference count Declaration val getCudaRegisteredMemory: data:ITensorHostStorage -> CudaRegisteredHostMemory<byte> Parameters Type Name Description ITensorHostStorage data Returns Type Description ManagedCuda.CudaRegisteredHostMemory < byte >"
  },
  "api/Tensor.Cuda.CudaRegMem.register.html": {
    "href": "api/Tensor.Cuda.CudaRegMem.register.html",
    "title": "Method register | Tensor for F#",
    "keywords": "Method register val register: ITensorHostStorage -> CudaRegMemHnd registers a TensorHostStorage (multiple registrations are okay) and returns the corresponding CudaRegMemHnd Declaration val register: data:ITensorHostStorage -> CudaRegMemHnd Parameters Type Name Description ITensorHostStorage data Returns Type Description CudaRegMemHnd"
  },
  "api/Tensor.BlockTensor-1.SubBlocks.html": {
    "href": "api/Tensor.BlockTensor-1.SubBlocks.html",
    "title": "Property SubBlocks of BlockTensor<'T> list | Tensor for F#",
    "keywords": "Property SubBlocks of BlockTensor<'T> list A block consisting of multiple sub-blocks. Namespace : Tensor Assembly : Tensor.dll Syntax | SubBlocks of BlockTensor<'T> list Parameters Type Name Description BlockTensor <'T> list"
  },
  "api/Tensor.BlockTensor-1.Block.html": {
    "href": "api/Tensor.BlockTensor-1.Block.html",
    "title": "Property Block of Tensor<'T> | Tensor for F#",
    "keywords": "Property Block of Tensor<'T> A block consisting of a single tensor. Namespace : Tensor Assembly : Tensor.dll Syntax | Block of Tensor<'T> Parameters Type Name Description Tensor <'T>"
  },
  "api/Tensor.Backend.ITensorStorage-1.Backend.html": {
    "href": "api/Tensor.Backend.ITensorStorage-1.Backend.html",
    "title": "Method Backend | Tensor for F#",
    "keywords": "Method Backend abstract member Backend: TensorLayout -> ITensorBackend<'T> Declaration abstract member Backend: TensorLayout -> ITensorBackend<'T> Parameters Type Name Description TensorLayout Returns Type Description ITensorBackend <'T>"
  },
  "api/Tensor.Algorithm.NPZFile.-ctor.html": {
    "href": "api/Tensor.Algorithm.NPZFile.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: string -> NPZFile Implicit constructor. Declaration new: path:string -> NPZFile Parameters Type Name Description string path Returns Type Description NPZFile"
  },
  "api/Tensor.Algorithm.NPZFile.System-IDisposable-Dispose.html": {
    "href": "api/Tensor.Algorithm.NPZFile.System-IDisposable-Dispose.html",
    "title": "Method Dispose | Tensor for F#",
    "keywords": "Method Dispose interface IDisposable with member Dispose: unit -> unit Declaration interface IDisposable with member Dispose: unit -> unit Overrides abstract member System.IDisposable.Dispose: unit -> unit"
  },
  "api/Tensor.Algorithm.NPZFile.Get.html": {
    "href": "api/Tensor.Algorithm.NPZFile.Get.html",
    "title": "Method Get | Tensor for F#",
    "keywords": "Method Get member Get: string -> Tensor<'?19678> gets the variable with the specified name from the .npz file Declaration member Get: name:string -> Tensor<'?19678> Parameters Type Name Description string name Returns Type Description Tensor <'?19678> Type Parameters Name Description '?"
  },
  "api/Tensor.Algorithm.NPZFile.Open.html": {
    "href": "api/Tensor.Algorithm.NPZFile.Open.html",
    "title": "Method Open | Tensor for F#",
    "keywords": "Method Open static member Open: string -> NPZFile opens the specified .npz file Declaration static member Open: path:string -> NPZFile Parameters Type Name Description string path Returns Type Description NPZFile"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.-ctor.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: CudaDeviceVariable<'T> -> TensorCudaStorage<'T> Implicit constructor. Declaration new: data:CudaDeviceVariable<'T> -> TensorCudaStorage<'T> Parameters Type Name Description ManagedCuda.CudaDeviceVariable <'T> data Returns Type Description TensorCudaStorage <'T> new: int64 -> TensorCudaStorage<'T> Declaration new: nElems:int64 -> TensorCudaStorage<'T> Parameters Type Name Description int64 nElems Returns Type Description TensorCudaStorage <'T>"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.Tensor-Backend-ITensorStorage-1-Backend.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.Tensor-Backend-ITensorStorage-1-Backend.html",
    "title": "Method Backend | Tensor for F#",
    "keywords": "Method Backend interface ITensorStorage<'T> with member Backend: TensorLayout -> ITensorBackend<'T> Declaration interface ITensorStorage<'T> with member Backend: layout:TensorLayout -> ITensorBackend<'T> Parameters Type Name Description TensorLayout layout Returns Type Description ITensorBackend <'T> Overrides abstract member ITensorStorage.Backend: TensorLayout -> ITensorBackend<'T>"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.Finalize.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.Finalize.html",
    "title": "Method Finalize | Tensor for F#",
    "keywords": "Method Finalize override member Finalize: unit -> unit Declaration override member Finalize: unit -> unit"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.Tensor-Backend-ITensorStorage-1-get_Dev.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.Tensor-Backend-ITensorStorage-1-get_Dev.html",
    "title": "Method Dev | Tensor for F#",
    "keywords": "Method Dev interface ITensorStorage with member Dev: unit -> ITensorDevice Declaration interface ITensorStorage with member Dev: unit -> ITensorDevice Returns Type Description ITensorDevice"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.Item.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.Item.html",
    "title": "Property Item | Tensor for F#",
    "keywords": "Property Item property Item: int64 -> 'T data item access Declaration property Item: int64 -> 'T with get, set Parameters Type Name Description int64 addr Property Value Type Description 'T"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.DataSizeInBytes.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.DataSizeInBytes.html",
    "title": "Property DataSizeInBytes | Tensor for F#",
    "keywords": "Property DataSizeInBytes property DataSizeInBytes: int64 data size in bytes Declaration property DataSizeInBytes: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.DataSize.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.DataSize.html",
    "title": "Property DataSize | Tensor for F#",
    "keywords": "Property DataSize property DataSize: int64 data size in elements Declaration property DataSize: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.Data.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.Data.html",
    "title": "Property Data | Tensor for F#",
    "keywords": "Property Data property Data: CudaDeviceVariable<'T> data device variable Declaration property Data: CudaDeviceVariable<'T> with get Property Value Type Description ManagedCuda.CudaDeviceVariable <'T>"
  },
  "api/Tensor.Cuda.TensorCudaStorage-1.ByteData.html": {
    "href": "api/Tensor.Cuda.TensorCudaStorage-1.ByteData.html",
    "title": "Property ByteData | Tensor for F#",
    "keywords": "Property ByteData property ByteData: CudaDeviceVariable<byte> data device variable as CudaDeviceVariable Declaration property ByteData: CudaDeviceVariable<byte> with get Property Value Type Description ManagedCuda.CudaDeviceVariable < byte >"
  },
  "api/Tensor.Cuda.TensorCudaDevice.Create.html": {
    "href": "api/Tensor.Cuda.TensorCudaDevice.Create.html",
    "title": "Method Create | Tensor for F#",
    "keywords": "Method Create override member Create: int64 -> ITensorStorage<'?153615> Declaration override member Create: nElems:int64 -> ITensorStorage<'?153615> Parameters Type Name Description int64 nElems Returns Type Description ITensorStorage <'?153615> Type Parameters Name Description '? Overrides abstract member BaseTensorDevice.Create: int64 -> ITensorStorage<'T>"
  },
  "api/Tensor.Cuda.TensorCudaDevice.Zeroed.html": {
    "href": "api/Tensor.Cuda.TensorCudaDevice.Zeroed.html",
    "title": "Property Zeroed | Tensor for F#",
    "keywords": "Property Zeroed override property Zeroed: bool Declaration override property Zeroed: bool with get Property Value Type Description bool Overrides abstract property BaseTensorDevice.Zeroed: bool"
  },
  "api/Tensor.Cuda.TensorCudaDevice.Instance.html": {
    "href": "api/Tensor.Cuda.TensorCudaDevice.Instance.html",
    "title": "Property Instance | Tensor for F#",
    "keywords": "Property Instance static property Instance: TensorCudaDevice Declaration static property Instance: TensorCudaDevice with get Property Value Type Description TensorCudaDevice"
  },
  "api/Tensor.Cuda.TensorCudaDevice.Id.html": {
    "href": "api/Tensor.Cuda.TensorCudaDevice.Id.html",
    "title": "Property Id | Tensor for F#",
    "keywords": "Property Id override property Id: string Declaration override property Id: string with get Property Value Type Description string Overrides abstract property BaseTensorDevice.Id: string"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.-ctor.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: TensorLayout * TensorCudaStorage<'T> -> TensorCudaBackend<'T> Implicit constructor. Declaration new: layout:TensorLayout * storage:TensorCudaStorage<'T> -> TensorCudaBackend<'T> Parameters Type Name Description TensorLayout layout TensorCudaStorage <'T> storage Returns Type Description TensorCudaBackend <'T>"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Abs.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Abs.html",
    "title": "Method Abs | Tensor for F#",
    "keywords": "Method Abs interface ITensorBackend<'T> with member Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Abs: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Abs: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Acos.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Acos.html",
    "title": "Method Acos | Tensor for F#",
    "keywords": "Method Acos interface ITensorBackend<'T> with member Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Acos: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Acos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.HDF5.Exists.html": {
    "href": "api/Tensor.HDF5.Exists.html",
    "title": "Method Exists | Tensor for F#",
    "keywords": "Method Exists member Exists: string -> bool Checks whether an object (array or group) with the given name exists. Declaration member Exists: name:string -> bool Parameters Type Name Description string name HDF5 path to check. Returns Type Description bool true if the path exists; false otherwise."
  },
  "api/Tensor.HDF5.Finalize.html": {
    "href": "api/Tensor.HDF5.Finalize.html",
    "title": "Method Finalize | Tensor for F#",
    "keywords": "Method Finalize override member Finalize: unit -> unit Closes the HDF5 file. Declaration override member Finalize: unit -> unit"
  },
  "api/Tensor.HDF5.GetAttribute.html": {
    "href": "api/Tensor.HDF5.GetAttribute.html",
    "title": "Method GetAttribute | Tensor for F#",
    "keywords": "Method GetAttribute member GetAttribute: string * string -> 'T Get attribute value on an HDF5 object. Declaration member GetAttribute: name:string * atrName:string -> 'T Parameters Type Name Description string name HDF5 path to operate on. string atrName Name of the attribute. Returns Type Description 'T Value of the attribute. Type Parameters Name Description 'T Type of the attribute value. See Also member SetAttribute: string * string * 'T -> unit member GetRecord: string -> 'R"
  },
  "api/Tensor.HDF5.GetDataType.html": {
    "href": "api/Tensor.HDF5.GetDataType.html",
    "title": "Method GetDataType | Tensor for F#",
    "keywords": "Method GetDataType member GetDataType: string -> Type Get data type of array in HDF5 file. Declaration member GetDataType: name:string -> Type Parameters Type Name Description string name HDF5 path to read from. Returns Type Description System.Type Data type."
  },
  "api/Tensor.HDF5.GetRecord.html": {
    "href": "api/Tensor.HDF5.GetRecord.html",
    "title": "Method GetRecord | Tensor for F#",
    "keywords": "Method GetRecord member GetRecord: string -> 'R Get attribute values on an HDF5 object and returns them as a record. Declaration member GetRecord: name:string -> 'R Parameters Type Name Description string name HDF5 path to operate on. Returns Type Description 'R Record containing the attribute values. Type Parameters Name Description 'R Type of the F# record. It must contain only field of primitive data types. Remarks The record must consists only of fields of primitive data types (int, float, string, etc.). Each record field is read from an HDF5 attribute using the same name. See Also member SetRecord: string * 'R -> unit member GetAttribute: string * string -> 'T"
  },
  "api/Tensor.HDF5.OpenRead.html": {
    "href": "api/Tensor.HDF5.OpenRead.html",
    "title": "Method OpenRead | Tensor for F#",
    "keywords": "Method OpenRead static member OpenRead: string -> HDF5 Opens the specified HDF5 file for reading. Declaration static member OpenRead: path:string -> HDF5 Parameters Type Name Description string path The path to the HDF5 file. Returns Type Description HDF5 An HDF5 object representing the opened file."
  },
  "api/Tensor.HDF5.OpenWrite.html": {
    "href": "api/Tensor.HDF5.OpenWrite.html",
    "title": "Method OpenWrite | Tensor for F#",
    "keywords": "Method OpenWrite static member OpenWrite: string -> HDF5 Opens the specified HDF5 file for writing. Declaration static member OpenWrite: path:string -> HDF5 Parameters Type Name Description string path The path to the HDF5 file. Returns Type Description HDF5 An HDF5 object representing the opened file. Remarks If the file already exists, it will be overwritten."
  },
  "api/Tensor.HDF5.Read.html": {
    "href": "api/Tensor.HDF5.Read.html",
    "title": "Method Read | Tensor for F#",
    "keywords": "Method Read member Read: string -> array<'T> * int64 list Read data array from HDF5 file. Declaration member Read: name:string -> array<'T> * int64 list Parameters Type Name Description string name HDF5 path to read from. Returns Type Description array <'T> * int64 list A tuple of (data, shape) where data is the read data array and shape is the corresponding shape. Type Parameters Name Description 'T Type of the data. Remarks The type 'T must match the data type stored in the HDF5 file, otherwise an exception is raised. See Also member Write: string * array<'T> * int64 list -> unit member GetDataType: string -> Type HostTensor.read``1"
  },
  "api/Tensor.HDF5.SetAttribute.html": {
    "href": "api/Tensor.HDF5.SetAttribute.html",
    "title": "Method SetAttribute | Tensor for F#",
    "keywords": "Method SetAttribute member SetAttribute: string * string * 'T -> unit Set attribute value on an HDF5 object. Declaration member SetAttribute: name:string * atrName:string * value:'T -> unit Parameters Type Name Description string name HDF5 path to operate on. string atrName Name of the attribute. 'T value Value to set attribute to. Type Parameters Name Description 'T Type of the attribute value. See Also member GetAttribute: string * string -> 'T member SetRecord: string * 'R -> unit"
  },
  "api/Tensor.HDF5.SetRecord.html": {
    "href": "api/Tensor.HDF5.SetRecord.html",
    "title": "Method SetRecord | Tensor for F#",
    "keywords": "Method SetRecord member SetRecord: string * 'R -> unit Set attribute values on an HDF5 object using the provided record. Declaration member SetRecord: name:string * record:'R -> unit Parameters Type Name Description string name HDF5 path to operate on. 'R record Record containing the attribute values. Type Parameters Name Description 'R Type of the F# record. It must contain only field of primitive data types. Remarks The record must consists only of fields of primitive data types (int, float, string, etc.). Each record field is stored as an HDF5 attribute using the same name. See Also member GetRecord: string -> 'R member SetAttribute: string * string * 'T -> unit"
  },
  "api/Tensor.HDF5.Write.html": {
    "href": "api/Tensor.HDF5.Write.html",
    "title": "Method Write | Tensor for F#",
    "keywords": "Method Write member Write: string * array<'T> * int64 list -> unit Write data array to HDF5 file. Declaration member Write: name:string * data:array<'T> * shape:int64 list -> unit Parameters Type Name Description string name HDF5 path to write to. array <'T> data Data array to write. int64 list shape Array shape to use. Type Parameters Name Description 'T Type of the data. Remarks All HDF5 groups are automatically created as necessary. See Also member Read: string -> array<'T> * int64 list HostTensor.write"
  },
  "api/Tensor.CudaTensor.Dev().html": {
    "href": "api/Tensor.CudaTensor.Dev().html",
    "title": "Field val Dev | Tensor for F#",
    "keywords": "Field val Dev Tensor device using CUDA GPU memory as data storage. Namespace : Tensor Assembly : Tensor.dll Syntax val Dev: ITensorDevice Returns Type Description ITensorDevice"
  },
  "api/Tensor.CudaTensor.transfer.html": {
    "href": "api/Tensor.CudaTensor.transfer.html",
    "title": "Method transfer | Tensor for F#",
    "keywords": "Method transfer val transfer: Tensor<'T> -> Tensor<'T> Transfers a tensor to the CUDA device. Declaration val transfer: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to transfer. Returns Type Description Tensor <'T> A tensor on the CUDA device. Type Parameters Name Description 'T The data type of the tensor. See Also static member transfer: ITensorDevice -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.empty.html": {
    "href": "api/Tensor.CudaTensor.empty.html",
    "title": "Method empty | Tensor for F#",
    "keywords": "Method empty val empty: int -> Tensor<'T> Creates a new, empty tensor with the given number of dimensions. Declaration val empty: nDims:int -> Tensor<'T> Parameters Type Name Description int nDims The number of dimensions of the new, empty tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member empty: ITensorDevice -> int -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.zeros.html": {
    "href": "api/Tensor.CudaTensor.zeros.html",
    "title": "Method zeros | Tensor for F#",
    "keywords": "Method zeros val zeros: int64 list -> Tensor<'T> Creates a new tensor filled with zeros (0). Declaration val zeros: shape:int64 list -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member zeros: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.ones.html": {
    "href": "api/Tensor.CudaTensor.ones.html",
    "title": "Method ones | Tensor for F#",
    "keywords": "Method ones val ones: int64 list -> Tensor<'T> Creates a new tensor filled with ones (1). Declaration val ones: shape:int64 list -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member ones: ITensorDevice -> int64 list -> Tensor<'T>"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Multiply.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Multiply.html",
    "title": "Method Multiply | Tensor for F#",
    "keywords": "Method Multiply interface ITensorBackend<'T> with member Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Multiply: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Multiply: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Negate.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Negate.html",
    "title": "Method Negate | Tensor for F#",
    "keywords": "Method Negate interface ITensorBackend<'T> with member Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Negate: trgt:ITensorFrontend<bool> * a:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > a Overrides abstract member ITensorBackend.Negate: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-NotEqual.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-NotEqual.html",
    "title": "Method NotEqual | Tensor for F#",
    "keywords": "Method NotEqual interface ITensorBackend<'T> with member NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member NotEqual: trgt:ITensorFrontend<bool> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.NotEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Or.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Or.html",
    "title": "Method Or | Tensor for F#",
    "keywords": "Method Or interface ITensorBackend<'T> with member Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Or: trgt:ITensorFrontend<bool> * a:ITensorFrontend<bool> * b:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > a ITensorFrontend < bool > b Overrides abstract member ITensorBackend.Or: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Power.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Power.html",
    "title": "Method Power | Tensor for F#",
    "keywords": "Method Power interface ITensorBackend<'T> with member Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Power: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Power: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ProductLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-ProductLastAxis.html",
    "title": "Method ProductLastAxis | Tensor for F#",
    "keywords": "Method ProductLastAxis interface ITensorBackend<'T> with member ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ProductLastAxis: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.ProductLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Round.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Round.html",
    "title": "Method Round | Tensor for F#",
    "keywords": "Method Round interface ITensorBackend<'T> with member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Round: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Scatter.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Scatter.html",
    "title": "Method Scatter | Tensor for F#",
    "keywords": "Method Scatter interface ITensorBackend<'T> with member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Scatter: trgt:ITensorFrontend<'T> * trgtIndices:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list trgtIndices ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sgn.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sgn.html",
    "title": "Method Sgn | Tensor for F#",
    "keywords": "Method Sgn interface ITensorBackend<'T> with member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sgn: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sin.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sin.html",
    "title": "Method Sin | Tensor for F#",
    "keywords": "Method Sin interface ITensorBackend<'T> with member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sin: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sinh.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sinh.html",
    "title": "Method Sinh | Tensor for F#",
    "keywords": "Method Sinh interface ITensorBackend<'T> with member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sinh: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sqrt.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Sqrt.html",
    "title": "Method Sqrt | Tensor for F#",
    "keywords": "Method Sqrt interface ITensorBackend<'T> with member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sqrt: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Subtract.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Subtract.html",
    "title": "Method Subtract | Tensor for F#",
    "keywords": "Method Subtract interface ITensorBackend<'T> with member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Subtract: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-SumLastAxis.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-SumLastAxis.html",
    "title": "Method SumLastAxis | Tensor for F#",
    "keywords": "Method SumLastAxis interface ITensorBackend<'T> with member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member SumLastAxis: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-SymmetricEigenDecomposition.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-SymmetricEigenDecomposition.html",
    "title": "Method SymmetricEigenDecomposition | Tensor for F#",
    "keywords": "Method SymmetricEigenDecomposition interface ITensorBackend<'T> with member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member SymmetricEigenDecomposition: part:MatrixPart * eigVals:ITensorFrontend<'T> * eigVecs:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description MatrixPart part ITensorFrontend <'T> eigVals ITensorFrontend <'T> eigVecs ITensorFrontend <'T> src Overrides abstract member ITensorBackend.SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Tan.html": {
    "href": "api/Tensor.Host.TensorHostBackend-1.Tensor-Backend-ITensorBackend-1-Tan.html",
    "title": "Method Tan | Tensor for F#",
    "keywords": "Method Tan interface ITensorBackend<'T> with member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Tan: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a Overrides abstract member ITensorBackend.Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Algorithm.NPZFile.Path.html": {
    "href": "api/Tensor.Algorithm.NPZFile.Path.html",
    "title": "Property Path | Tensor for F#",
    "keywords": "Property Path property Path: string path to this .npz file Declaration property Path: string with get Property Value Type Description string"
  },
  "api/Tensor.Algorithm.NPZFile.Names.html": {
    "href": "api/Tensor.Algorithm.NPZFile.Names.html",
    "title": "Property Names | Tensor for F#",
    "keywords": "Property Names property Names: string list returns all variable names in the .npz file Declaration property Names: string list with get Property Value Type Description string list"
  },
  "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Means.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Means.html",
    "title": "Field val Means: Tensor<'T> | Tensor for F#",
    "keywords": "Field val Means: Tensor<'T> the means of the features (for centering the data) Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax val Means: Tensor<'T> Returns Type Description Tensor <'T>"
  },
  "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Variances.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Variances.html",
    "title": "Field val Variances: Tensor<'T> | Tensor for F#",
    "keywords": "Field val Variances: Tensor<'T> the variances of the principal components in descending order Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax val Variances: Tensor<'T> Returns Type Description Tensor <'T>"
  },
  "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Axes.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCAInfo-1.Axes.html",
    "title": "Field val Axes: Tensor<'T> | Tensor for F#",
    "keywords": "Field val Axes: Tensor<'T> the axes corresponding to the principal components Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax val Axes: Tensor<'T> Returns Type Description Tensor <'T>"
  },
  "api/Tensor.SingularMatrixException.Message.html": {
    "href": "api/Tensor.SingularMatrixException.Message.html",
    "title": "Property Message | Tensor for F#",
    "keywords": "Property Message override property Message: string Detailed error message. Declaration override property Message: string with get Property Value Type Description string Overrides abstract property System.Exception.Message: string"
  },
  "api/Tensor.SingularMatrixException.msg.html": {
    "href": "api/Tensor.SingularMatrixException.msg.html",
    "title": "Field val msg: string | Tensor for F#",
    "keywords": "Field val msg: string Namespace : Tensor Assembly : Tensor.dll Syntax val msg: string Returns Type Description string"
  },
  "api/Tensor.ITensor.Copy.html": {
    "href": "api/Tensor.ITensor.Copy.html",
    "title": "Method Copy | Tensor for F#",
    "keywords": "Method Copy abstract member Copy: TensorOrder option -> ITensor returns a copy of the tensor Declaration abstract member Copy: order:TensorOrder option -> ITensor Parameters Type Name Description TensorOrder option order Returns Type Description ITensor"
  },
  "api/Tensor.ITensor.FillZero.html": {
    "href": "api/Tensor.ITensor.FillZero.html",
    "title": "Method FillZero | Tensor for F#",
    "keywords": "Method FillZero abstract member FillZero: unit -> unit fills the tensors with zeros Declaration abstract member FillZero: unit -> unit"
  },
  "api/Tensor.ITensor.Relayout.html": {
    "href": "api/Tensor.ITensor.Relayout.html",
    "title": "Method Relayout | Tensor for F#",
    "keywords": "Method Relayout abstract member Relayout: TensorLayout -> ITensor a tensor with the same storage but new layout Declaration abstract member Relayout: TensorLayout -> ITensor Parameters Type Name Description TensorLayout Returns Type Description ITensor"
  },
  "api/Tensor.ITensor.Transfer.html": {
    "href": "api/Tensor.ITensor.Transfer.html",
    "title": "Method Transfer | Tensor for F#",
    "keywords": "Method Transfer abstract member Transfer: ITensorDevice -> ITensor Transfers this tensor to the specifed device. Declaration abstract member Transfer: dev:ITensorDevice -> ITensor Parameters Type Name Description ITensorDevice dev Returns Type Description ITensor"
  },
  "api/Tensor.ITensor.M.html": {
    "href": "api/Tensor.ITensor.M.html",
    "title": "Property M | Tensor for F#",
    "keywords": "Property M abstract property M: ITensor list -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor list -> ITensor with get, set Parameters Type Name Description ITensor list masks Property Value Type Description ITensor abstract property M: ITensor * ITensor * ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor * ITensor * ITensor * ITensor * ITensor -> ITensor with get, set Parameters Type Name Description ITensor m0 ITensor m1 ITensor m2 ITensor m3 ITensor m4 Property Value Type Description ITensor abstract property M: ITensor * ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor * ITensor * ITensor * ITensor -> ITensor with get, set Parameters Type Name Description ITensor m0 ITensor m1 ITensor m2 ITensor m3 Property Value Type Description ITensor abstract property M: ITensor * ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor * ITensor * ITensor -> ITensor with get, set Parameters Type Name Description ITensor m0 ITensor m1 ITensor m2 Property Value Type Description ITensor abstract property M: ITensor * ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor * ITensor -> ITensor with get, set Parameters Type Name Description ITensor m0 ITensor m1 Property Value Type Description ITensor abstract property M: ITensor -> ITensor Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired. Declaration abstract property M: ITensor -> ITensor with get, set Parameters Type Name Description ITensor m0 Property Value Type Description ITensor"
  },
  "api/Tensor.ITensor.Item.html": {
    "href": "api/Tensor.ITensor.Item.html",
    "title": "Property Item | Tensor for F#",
    "keywords": "Property Item abstract property Item: int64 -> ITensor Declaration abstract property Item: int64 -> ITensor with get, set Parameters Type Name Description int64 i0 Property Value Type Description ITensor abstract property Item: Rng list -> ITensor n-dimensional slicing using a list of Rngs Declaration abstract property Item: Rng list -> ITensor with get, set Parameters Type Name Description Rng list rng Property Value Type Description ITensor"
  },
  "api/Tensor.ITensor.Storage.html": {
    "href": "api/Tensor.ITensor.Storage.html",
    "title": "Property Storage | Tensor for F#",
    "keywords": "Property Storage abstract property Storage: ITensorStorage storage of this tensor Declaration abstract property Storage: ITensorStorage with get Property Value Type Description ITensorStorage"
  },
  "api/Tensor.ITensor.Shape.html": {
    "href": "api/Tensor.ITensor.Shape.html",
    "title": "Property Shape | Tensor for F#",
    "keywords": "Property Shape abstract property Shape: int64 list shape Declaration abstract property Shape: int64 list with get Property Value Type Description int64 list"
  },
  "api/Tensor.ITensor.Pretty.html": {
    "href": "api/Tensor.ITensor.Pretty.html",
    "title": "Property Pretty | Tensor for F#",
    "keywords": "Property Pretty abstract property Pretty: string pretty contents string Declaration abstract property Pretty: string with get Property Value Type Description string"
  },
  "api/Tensor.HostTensor.mapi.html": {
    "href": "api/Tensor.HostTensor.mapi.html",
    "title": "Method mapi | Tensor for F#",
    "keywords": "Method mapi val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified indexed function to all elements of the tensor. Declaration val mapi: fn:int64 [] -> 'T -> 'R -> a:Tensor<'T> -> Tensor<'R> Parameters Type Name Description int64 [] -> 'T -> 'R fn A function that takes an index and the corresponding value from the input tensor and returns the corresponding output value. Tensor <'T> a The source tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'T The type of the data. 'R See Also val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> HostTensor.Parallel.map``2"
  },
  "api/Tensor.HostTensor.FillMap2.html": {
    "href": "api/Tensor.HostTensor.FillMap2.html",
    "title": "Method FillMap2 | Tensor for F#",
    "keywords": "Method FillMap2 val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified function to all elements of the two tensors using the specified tensor as target. Declaration val FillMap2: trgt:Tensor<'T> -> fn:'TA -> 'TB -> 'T -> a:Tensor<'TA> -> b:Tensor<'TB> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. 'TA -> 'TB -> 'T fn A function that takes a value from the first input tensor and a value from the second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Type Parameters Name Description 'T The type of the data. 'TA 'TB See Also val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> HostTensor.Parallel.FillMap2``3"
  },
  "api/Tensor.HostTensor.map2.html": {
    "href": "api/Tensor.HostTensor.map2.html",
    "title": "Method map2 | Tensor for F#",
    "keywords": "Method map2 val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified function to all elements of the two tensors. Declaration val map2: fn:'TA -> 'TB -> 'R -> a:Tensor<'TA> -> b:Tensor<'TB> -> Tensor<'R> Parameters Type Name Description 'TA -> 'TB -> 'R fn A function that takes a value from the first input tensor and a value from the second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'TA 'TB 'R See Also val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> HostTensor.Parallel.map2``3"
  },
  "api/Tensor.HostTensor.FillMapIndexed2.html": {
    "href": "api/Tensor.HostTensor.FillMapIndexed2.html",
    "title": "Method FillMapIndexed2 | Tensor for F#",
    "keywords": "Method FillMapIndexed2 val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified indexed function to all elements of the two tensors using the specified tensor as target. Declaration val FillMapIndexed2: trgt:Tensor<'T> -> fn:int64 [] -> 'TA -> 'TB -> 'T -> a:Tensor<'TA> -> b:Tensor<'TB> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. int64 [] -> 'TA -> 'TB -> 'T fn A function that takes an index, the corresponding value from the first input and second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Type Parameters Name Description 'T The type of the data. 'TA 'TB See Also val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> HostTensor.Parallel.FillMapIndexed2``3"
  },
  "api/Tensor.HostTensor.mapi2.html": {
    "href": "api/Tensor.HostTensor.mapi2.html",
    "title": "Method mapi2 | Tensor for F#",
    "keywords": "Method mapi2 val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified indexed function to all elements of the two tensors. Declaration val mapi2: fn:int64 [] -> 'TA -> 'TB -> 'R -> a:Tensor<'TA> -> b:Tensor<'TB> -> Tensor<'R> Parameters Type Name Description int64 [] -> 'TA -> 'TB -> 'R fn A function that takes an index, the corresponding value from the first input and second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'TA 'TB 'R See Also val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> HostTensor.Parallel.mapi2``3"
  },
  "api/Tensor.HostTensor.FillFoldAxis.html": {
    "href": "api/Tensor.HostTensor.FillFoldAxis.html",
    "title": "Method FillFoldAxis | Tensor for F#",
    "keywords": "Method FillFoldAxis val FillFoldAxis: Tensor<'T> -> 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor, threading an accumulator through the computation. Declaration val FillFoldAxis: trgt:Tensor<'T> -> fn:'T -> 'TA -> 'T -> initial:Tensor<'T> -> axis:int -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor that will contain the final state values. 'T -> 'TA -> 'T fn A function that takes a state value and a value from the input tensor and returns a new state value. Tensor <'T> initial The initial state value. int axis The axis to fold over. Tensor <'TA> a The source tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also val foldAxis: 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> Tensor<'T> HostTensor.Parallel.FillFoldAxis``3"
  },
  "api/Tensor.HostTensor.foldAxis.html": {
    "href": "api/Tensor.HostTensor.foldAxis.html",
    "title": "Method foldAxis | Tensor for F#",
    "keywords": "Method foldAxis val foldAxis: 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> Tensor<'T> Applies to specified function to all elements of the tensor, threading an accumulator through the computation. Declaration val foldAxis: fn:'T -> 'TA -> 'T -> initial:Tensor<'T> -> axis:int -> a:Tensor<'TA> -> Tensor<'T> Parameters Type Name Description 'T -> 'TA -> 'T fn A function that takes a state value and a value from the input tensor and returns a new state value. Tensor <'T> initial The initial state value. int axis The axis to fold over. Tensor <'TA> a The source tensor. Returns Type Description Tensor <'T> The output tensor containg the final states. Type Parameters Name Description 'T The type of the data. 'TA See Also val FillFoldAxis: Tensor<'T> -> 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> unit HostTensor.Parallel.foldAxis``2"
  },
  "api/Tensor.HostTensor.Parallel.FillIndexed.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillIndexed.html",
    "title": "Method FillIndexed | Tensor for F#",
    "keywords": "Method FillIndexed val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit Fills the tensor with values returned by the specifed function using multiple threads. Declaration val FillIndexed: trgt:Tensor<'T> -> fn:int64 [] -> 'T -> unit Parameters Type Name Description Tensor <'T> trgt The target tensor to fill. int64 [] -> 'T fn A function that takes the index of the element to fill and returns the corresponding value. Type Parameters Name Description 'T See Also val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit"
  },
  "api/Tensor.HostTensor.Parallel.Fill.html": {
    "href": "api/Tensor.HostTensor.Parallel.Fill.html",
    "title": "Method Fill | Tensor for F#",
    "keywords": "Method Fill val Fill: Tensor<'T> -> unit -> 'T -> unit Fills the tensor with the values returned by the function using multiple threads. Declaration val Fill: trgt:Tensor<'T> -> fn:unit -> 'T -> unit Parameters Type Name Description Tensor <'T> trgt The target tensor to fill. unit -> 'T fn A function that returns the values to fill the tensor with. Type Parameters Name Description 'T See Also val Fill: Tensor<'T> -> unit -> 'T -> unit"
  },
  "api/Tensor.HostTensor.Parallel.FillMap.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillMap.html",
    "title": "Method FillMap | Tensor for F#",
    "keywords": "Method FillMap val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor using the specified tensor as target using multiple threads. Declaration val FillMap: trgt:Tensor<'T> -> fn:'TA -> 'T -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. 'TA -> 'T fn A function that takes a value from the input tensor and returns the corresponding output value. Tensor <'TA> a The input tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit"
  },
  "api/Tensor.HostTensor.Parallel.FillMapIndexed.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillMapIndexed.html",
    "title": "Method FillMapIndexed | Tensor for F#",
    "keywords": "Method FillMapIndexed val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified indexed function to all elements of the tensor using the specified tensor as target using multiple threads. Declaration val FillMapIndexed: trgt:Tensor<'T> -> fn:int64 [] -> 'TA -> 'T -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. int64 [] -> 'TA -> 'T fn A function that takes an index and the corresponding value from the input tensor and returns the corresponding output value. Tensor <'TA> a The input tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit"
  },
  "api/Tensor.HostTensor.Parallel.FillMap2.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillMap2.html",
    "title": "Method FillMap2 | Tensor for F#",
    "keywords": "Method FillMap2 val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified function to all elements of the two tensors using the specified tensor as target using multiple threads. Declaration val FillMap2: trgt:Tensor<'T> -> fn:'TA -> 'TB -> 'T -> a:Tensor<'TA> -> b:Tensor<'TB> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. 'TA -> 'TB -> 'T fn A function that takes a value from the first input tensor and a value from the second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Type Parameters Name Description 'T The type of the data. 'TA 'TB See Also val FillMap2: Tensor<'T> -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit"
  },
  "api/Tensor.HostTensor.Parallel.FillMapIndexed2.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillMapIndexed2.html",
    "title": "Method FillMapIndexed2 | Tensor for F#",
    "keywords": "Method FillMapIndexed2 val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit Applies to specified indexed function to all elements of the two tensors using the specified tensor as target using multiple threads. Declaration val FillMapIndexed2: trgt:Tensor<'T> -> fn:int64 [] -> 'TA -> 'TB -> 'T -> a:Tensor<'TA> -> b:Tensor<'TB> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. int64 [] -> 'TA -> 'TB -> 'T fn A function that takes an index, the corresponding value from the first input and second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Type Parameters Name Description 'T The type of the data. 'TA 'TB See Also val FillMapIndexed2: Tensor<'T> -> int64 [] -> 'TA -> 'TB -> 'T -> Tensor<'TA> -> Tensor<'TB> -> unit"
  },
  "api/Tensor.HostTensor.Parallel.FillFoldAxis.html": {
    "href": "api/Tensor.HostTensor.Parallel.FillFoldAxis.html",
    "title": "Method FillFoldAxis | Tensor for F#",
    "keywords": "Method FillFoldAxis val FillFoldAxis: Tensor<'T> -> 'T -> 'TA -> 'T -> Tensor<'T> -> int -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor, threading an accumulator through the computation using multiple threads. Declaration val FillFoldAxis: trgt:Tensor<'T> -> fn:'T -> 'TA -> 'T -> initial:Tensor<'T> -> axis:int -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor that will contain the final state values. 'T -> 'TA -> 'T fn A function that takes a state value and a value from the input tensor and returns a new state value. Tensor <'T> initial The initial state value. int axis The axis to fold over. Tensor <'TA> a The source tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also HostTensor.FillFoldAxis``3"
  },
  "api/Tensor.HostTensor.Parallel.init.html": {
    "href": "api/Tensor.HostTensor.Parallel.init.html",
    "title": "Method init | Tensor for F#",
    "keywords": "Method init val init: int64 list -> int64 [] -> 'T -> Tensor<'T> Creates a new tensor with values returned by the specified function using multiple threads. Declaration val init: shape:int64 list -> fn:int64 [] -> 'T -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. int64 [] -> 'T fn A function that takes the index of the element to fill and returns the corresponding value. Returns Type Description Tensor <'T> Type Parameters Name Description 'T See Also val FillIndexed: Tensor<'T> -> int64 [] -> 'T -> unit"
  },
  "api/Tensor.HostTensor.Parallel.map.html": {
    "href": "api/Tensor.HostTensor.Parallel.map.html",
    "title": "Method map | Tensor for F#",
    "keywords": "Method map val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified function to all elements of the tensor using multiple threads. Declaration val map: fn:'T -> 'R -> a:Tensor<'T> -> Tensor<'R> Parameters Type Name Description 'T -> 'R fn A function that takes a value from the input tensor and returns the corresponding output value. Tensor <'T> a The source tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'T The type of the data. 'R See Also val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R>"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-CountTrueLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-CountTrueLastAxis.html",
    "title": "Method CountTrueLastAxis | Tensor for F#",
    "keywords": "Method CountTrueLastAxis interface ITensorBackend<'T> with member CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member CountTrueLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src1 Overrides abstract member ITensorBackend.CountTrueLastAxis: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Divide.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Divide.html",
    "title": "Method Divide | Tensor for F#",
    "keywords": "Method Divide interface ITensorBackend<'T> with member Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Divide: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Divide: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Equal.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Equal.html",
    "title": "Method Equal | Tensor for F#",
    "keywords": "Method Equal interface ITensorBackend<'T> with member Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Equal: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Equal: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Exp.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Exp.html",
    "title": "Method Exp | Tensor for F#",
    "keywords": "Method Exp interface ITensorBackend<'T> with member Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Exp: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Exp: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FillConst.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FillConst.html",
    "title": "Method FillConst | Tensor for F#",
    "keywords": "Method FillConst interface ITensorBackend<'T> with member FillConst: 'T * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FillConst: value:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend <'T> trgt Overrides abstract member ITensorBackend.FillConst: 'T * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FillIncrementing.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FillIncrementing.html",
    "title": "Method FillIncrementing | Tensor for F#",
    "keywords": "Method FillIncrementing interface ITensorBackend<'T> with member FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FillIncrementing: start:'T * incr:'T * trgt:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T start 'T incr ITensorFrontend <'T> trgt Overrides abstract member ITensorBackend.FillIncrementing: 'T * 'T * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FindLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-FindLastAxis.html",
    "title": "Method FindLastAxis | Tensor for F#",
    "keywords": "Method FindLastAxis interface ITensorBackend<'T> with member FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member FindLastAxis: value:'T * trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description 'T value ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.FindLastAxis: 'T * ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Floor.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Floor.html",
    "title": "Method Floor | Tensor for F#",
    "keywords": "Method Floor interface ITensorBackend<'T> with member Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Floor: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Floor: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Gather.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Gather.html",
    "title": "Method Gather | Tensor for F#",
    "keywords": "Method Gather interface ITensorBackend<'T> with member Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Gather: trgt:ITensorFrontend<'T> * srcIdxs:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list srcIdxs ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Gather: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Greater.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Greater.html",
    "title": "Method Greater | Tensor for F#",
    "keywords": "Method Greater interface ITensorBackend<'T> with member Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Greater: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Greater: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-GreaterOrEqual.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-GreaterOrEqual.html",
    "title": "Method GreaterOrEqual | Tensor for F#",
    "keywords": "Method GreaterOrEqual interface ITensorBackend<'T> with member GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member GreaterOrEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.GreaterOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-IfThenElse.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-IfThenElse.html",
    "title": "Method IfThenElse | Tensor for F#",
    "keywords": "Method IfThenElse interface ITensorBackend<'T> with member IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member IfThenElse: trgt:ITensorFrontend<'T> * cond:ITensorFrontend<bool> * ifTrue:ITensorFrontend<'T> * ifFalse:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < bool > cond ITensorFrontend <'T> ifTrue ITensorFrontend <'T> ifFalse Overrides abstract member ITensorBackend.IfThenElse: ITensorFrontend<'T> * ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-IsFinite.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-IsFinite.html",
    "title": "Method IsFinite | Tensor for F#",
    "keywords": "Method IsFinite interface ITensorBackend<'T> with member IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member IsFinite: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.IsFinite: ITensorFrontend<bool> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Less.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Less.html",
    "title": "Method Less | Tensor for F#",
    "keywords": "Method Less interface ITensorBackend<'T> with member Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Less: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Less: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-LessOrEqual.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-LessOrEqual.html",
    "title": "Method LessOrEqual | Tensor for F#",
    "keywords": "Method LessOrEqual interface ITensorBackend<'T> with member LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member LessOrEqual: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.LessOrEqual: ITensorFrontend<bool> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Log.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Log.html",
    "title": "Method Log | Tensor for F#",
    "keywords": "Method Log interface ITensorBackend<'T> with member Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Log: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Log: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Round.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Round.html",
    "title": "Method Round | Tensor for F#",
    "keywords": "Method Round interface ITensorBackend<'T> with member Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Round: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Round: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Scatter.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Scatter.html",
    "title": "Method Scatter | Tensor for F#",
    "keywords": "Method Scatter interface ITensorBackend<'T> with member Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Scatter: trgt:ITensorFrontend<'T> * trgtIdxs:ITensorFrontend<int64> option list * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend < int64 > option list trgtIdxs ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Scatter: ITensorFrontend<'T> * ITensorFrontend<int64> option list * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sgn.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sgn.html",
    "title": "Method Sgn | Tensor for F#",
    "keywords": "Method Sgn interface ITensorBackend<'T> with member Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sgn: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Sgn: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sin.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sin.html",
    "title": "Method Sin | Tensor for F#",
    "keywords": "Method Sin interface ITensorBackend<'T> with member Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sin: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Sin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sinh.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sinh.html",
    "title": "Method Sinh | Tensor for F#",
    "keywords": "Method Sinh interface ITensorBackend<'T> with member Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sinh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Sinh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sqrt.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Sqrt.html",
    "title": "Method Sqrt | Tensor for F#",
    "keywords": "Method Sqrt interface ITensorBackend<'T> with member Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Sqrt: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Sqrt: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Subtract.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Subtract.html",
    "title": "Method Subtract | Tensor for F#",
    "keywords": "Method Subtract interface ITensorBackend<'T> with member Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Subtract: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Subtract: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-SumLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-SumLastAxis.html",
    "title": "Method SumLastAxis | Tensor for F#",
    "keywords": "Method SumLastAxis interface ITensorBackend<'T> with member SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member SumLastAxis: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.SumLastAxis: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-SymmetricEigenDecomposition.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-SymmetricEigenDecomposition.html",
    "title": "Method SymmetricEigenDecomposition | Tensor for F#",
    "keywords": "Method SymmetricEigenDecomposition interface ITensorBackend<'T> with member SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member SymmetricEigenDecomposition: part:MatrixPart * trgtEigVals:ITensorFrontend<'T> * trgtEigVec:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description MatrixPart part ITensorFrontend <'T> trgtEigVals ITensorFrontend <'T> trgtEigVec ITensorFrontend <'T> src Overrides abstract member ITensorBackend.SymmetricEigenDecomposition: MatrixPart * ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Tan.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Tan.html",
    "title": "Method Tan | Tensor for F#",
    "keywords": "Method Tan interface ITensorBackend<'T> with member Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Tan: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Tan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Tanh.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Tanh.html",
    "title": "Method Tanh | Tensor for F#",
    "keywords": "Method Tanh interface ITensorBackend<'T> with member Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Tanh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Tanh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Transfer.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Transfer.html",
    "title": "Method Transfer | Tensor for F#",
    "keywords": "Method Transfer interface ITensorBackend<'T> with member Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool Declaration interface ITensorBackend<'T> with member Transfer: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> bool Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Returns Type Description bool Overrides abstract member ITensorBackend.Transfer: ITensorFrontend<'T> * ITensorFrontend<'T> -> bool"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-TrueIndices.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-TrueIndices.html",
    "title": "Method TrueIndices | Tensor for F#",
    "keywords": "Method TrueIndices interface ITensorBackend<'T> with member TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member TrueIndices: trgt:ITensorFrontend<int64> * src:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend < bool > src Overrides abstract member ITensorBackend.TrueIndices: ITensorFrontend<int64> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Truncate.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Truncate.html",
    "title": "Method Truncate | Tensor for F#",
    "keywords": "Method Truncate interface ITensorBackend<'T> with member Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Truncate: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Truncate: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-UnaryMinus.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-UnaryMinus.html",
    "title": "Method UnaryMinus | Tensor for F#",
    "keywords": "Method UnaryMinus interface ITensorBackend<'T> with member UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member UnaryMinus: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.UnaryMinus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-UnaryPlus.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-UnaryPlus.html",
    "title": "Method UnaryPlus | Tensor for F#",
    "keywords": "Method UnaryPlus interface ITensorBackend<'T> with member UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member UnaryPlus: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.UnaryPlus: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_uint32.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_uint32.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> uint32 Declaration static member op_Explicit: a:Rat -> uint32 Parameters Type Name Description Rat a Returns Type Description uint32"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_int64.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_int64.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> int64 Declaration static member op_Explicit: a:Rat -> int64 Parameters Type Name Description Rat a Returns Type Description int64"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_uint64.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_uint64.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> uint64 Declaration static member op_Explicit: a:Rat -> uint64 Parameters Type Name Description Rat a Returns Type Description uint64"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_double.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_double.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> double Declaration static member op_Explicit: a:Rat -> double Parameters Type Name Description Rat a Returns Type Description double"
  },
  "api/Tensor.Algorithm.Rat.op_Explicit_single.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Explicit_single.html",
    "title": "Operator op_Explicit | Tensor for F#",
    "keywords": "Operator op_Explicit static member op_Explicit: Rat -> single Declaration static member op_Explicit: a:Rat -> single Parameters Type Name Description Rat a Returns Type Description single"
  },
  "api/Tensor.Algorithm.Rat.op_Implicit.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Implicit.html",
    "title": "Operator op_Implicit | Tensor for F#",
    "keywords": "Operator op_Implicit static member op_Implicit: bigint -> Rat Declaration static member op_Implicit: v:bigint -> Rat Parameters Type Name Description bigint v Returns Type Description Rat static member op_Implicit: int32 -> Rat Declaration static member op_Implicit: v:int32 -> Rat Parameters Type Name Description int32 v Returns Type Description Rat static member op_Implicit: uint32 -> Rat Declaration static member op_Implicit: v:uint32 -> Rat Parameters Type Name Description uint32 v Returns Type Description Rat static member op_Implicit: int64 -> Rat Declaration static member op_Implicit: v:int64 -> Rat Parameters Type Name Description int64 v Returns Type Description Rat static member op_Implicit: uint64 -> Rat Declaration static member op_Implicit: v:uint64 -> Rat Parameters Type Name Description uint64 v Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_Modulus.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Modulus.html",
    "title": "Operator ( % ) | Tensor for F#",
    "keywords": "Operator ( % ) static member ( % ): Rat * Rat -> Rat Declaration static member ( % ): a:Rat * b:Rat -> Rat Parameters Type Name Description Rat a Rat b Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_Multiply.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Multiply.html",
    "title": "Operator ( * ) | Tensor for F#",
    "keywords": "Operator ( * ) static member ( * ): Rat * Rat -> Rat Declaration static member ( * ): a:Rat * b:Rat -> Rat Parameters Type Name Description Rat a Rat b Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_Subtraction.html": {
    "href": "api/Tensor.Algorithm.Rat.op_Subtraction.html",
    "title": "Operator ( - ) | Tensor for F#",
    "keywords": "Operator ( - ) static member ( - ): Rat * Rat -> Rat Declaration static member ( - ): a:Rat * b:Rat -> Rat Parameters Type Name Description Rat a Rat b Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_UnaryNegation.html": {
    "href": "api/Tensor.Algorithm.Rat.op_UnaryNegation.html",
    "title": "Operator ( ~- ) | Tensor for F#",
    "keywords": "Operator ( ~- ) static member ( ~- ): Rat -> Rat Declaration static member ( ~- ): a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.op_UnaryPlus.html": {
    "href": "api/Tensor.Algorithm.Rat.op_UnaryPlus.html",
    "title": "Operator ( ~+ ) | Tensor for F#",
    "keywords": "Operator ( ~+ ) static member ( ~+ ): Rat -> Rat Declaration static member ( ~+ ): a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.Zero.html": {
    "href": "api/Tensor.Algorithm.Rat.Zero.html",
    "title": "Property Zero | Tensor for F#",
    "keywords": "Property Zero static property Zero: Rat Declaration static property Zero: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.Pretty.html": {
    "href": "api/Tensor.Algorithm.Rat.Pretty.html",
    "title": "Property Pretty | Tensor for F#",
    "keywords": "Property Pretty property Pretty: string Pretty string representation. Declaration property Pretty: string with get Property Value Type Description string"
  },
  "api/Tensor.Algorithm.Rat.PosInf.html": {
    "href": "api/Tensor.Algorithm.Rat.PosInf.html",
    "title": "Property PosInf | Tensor for F#",
    "keywords": "Property PosInf static property PosInf: Rat Declaration static property PosInf: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.One.html": {
    "href": "api/Tensor.Algorithm.Rat.One.html",
    "title": "Property One | Tensor for F#",
    "keywords": "Property One static property One: Rat Declaration static property One: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.NegInf.html": {
    "href": "api/Tensor.Algorithm.Rat.NegInf.html",
    "title": "Property NegInf | Tensor for F#",
    "keywords": "Property NegInf static property NegInf: Rat Declaration static property NegInf: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.NaN.html": {
    "href": "api/Tensor.Algorithm.Rat.NaN.html",
    "title": "Property NaN | Tensor for F#",
    "keywords": "Property NaN static property NaN: Rat Declaration static property NaN: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.MinusOne.html": {
    "href": "api/Tensor.Algorithm.Rat.MinusOne.html",
    "title": "Property MinusOne | Tensor for F#",
    "keywords": "Property MinusOne static property MinusOne: Rat Declaration static property MinusOne: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.MinValue.html": {
    "href": "api/Tensor.Algorithm.Rat.MinValue.html",
    "title": "Property MinValue | Tensor for F#",
    "keywords": "Property MinValue static property MinValue: Rat Declaration static property MinValue: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.MaxValue.html": {
    "href": "api/Tensor.Algorithm.Rat.MaxValue.html",
    "title": "Property MaxValue | Tensor for F#",
    "keywords": "Property MaxValue static property MaxValue: Rat Declaration static property MaxValue: Rat with get Property Value Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.IsPosInf.html": {
    "href": "api/Tensor.Algorithm.Rat.IsPosInf.html",
    "title": "Property IsPosInf | Tensor for F#",
    "keywords": "Property IsPosInf property IsPosInf: bool True is this is positive infinity. Declaration property IsPosInf: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.IsNegInf.html": {
    "href": "api/Tensor.Algorithm.Rat.IsNegInf.html",
    "title": "Property IsNegInf | Tensor for F#",
    "keywords": "Property IsNegInf property IsNegInf: bool True is this is negative infinity. Declaration property IsNegInf: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.IsNaN.html": {
    "href": "api/Tensor.Algorithm.Rat.IsNaN.html",
    "title": "Property IsNaN | Tensor for F#",
    "keywords": "Property IsNaN property IsNaN: bool True if this is not-a-number. Declaration property IsNaN: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.IsInt.html": {
    "href": "api/Tensor.Algorithm.Rat.IsInt.html",
    "title": "Property IsInt | Tensor for F#",
    "keywords": "Property IsInt property IsInt: bool True if this is an integer, i.e. denominator is one. Declaration property IsInt: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.IsInf.html": {
    "href": "api/Tensor.Algorithm.Rat.IsInf.html",
    "title": "Property IsInf | Tensor for F#",
    "keywords": "Property IsInf property IsInf: bool True is this is infinity. Declaration property IsInf: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.IsFinite.html": {
    "href": "api/Tensor.Algorithm.Rat.IsFinite.html",
    "title": "Property IsFinite | Tensor for F#",
    "keywords": "Property IsFinite property IsFinite: bool True if this is a finite number (not infinity and not NaN). Declaration property IsFinite: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.Dnm.html": {
    "href": "api/Tensor.Algorithm.Rat.Dnm.html",
    "title": "Property Dnm | Tensor for F#",
    "keywords": "Property Dnm property Dnm: bigint the denominator Declaration property Dnm: bigint with get Property Value Type Description bigint"
  },
  "api/Tensor.Algorithm.Rat.Num.html": {
    "href": "api/Tensor.Algorithm.Rat.Num.html",
    "title": "Field val Num: bigint | Tensor for F#",
    "keywords": "Field val Num: bigint the numerator Namespace : Tensor.Algorithm Assembly : Tensor.Algorithm.dll Syntax val Num: bigint Returns Type Description bigint"
  },
  "api/Tensor.Algorithm.NPYFile.loadFromStream.html": {
    "href": "api/Tensor.Algorithm.NPYFile.loadFromStream.html",
    "title": "Method loadFromStream | Tensor for F#",
    "keywords": "Method loadFromStream val loadFromStream: Stream -> string -> Tensor<'T> loads a .npy file from the specified stream Declaration val loadFromStream: stream:Stream -> name:string -> Tensor<'T> Parameters Type Name Description System.IO.Stream stream string name Returns Type Description Tensor <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Algorithm.NPYFile.load.html": {
    "href": "api/Tensor.Algorithm.NPYFile.load.html",
    "title": "Method load | Tensor for F#",
    "keywords": "Method load val load: string -> Tensor<'?19684> loads a .npy file from the specified path Declaration val load: path:string -> Tensor<'?19684> Parameters Type Name Description string path Returns Type Description Tensor <'?19684> Type Parameters Name Description '?"
  },
  "api/Tensor.Algorithm.Decomposition.ZCA.-ctor.html": {
    "href": "api/Tensor.Algorithm.Decomposition.ZCA.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: unit -> ZCA Implicit constructor. Declaration new: unit -> ZCA Returns Type Description ZCA"
  },
  "api/Tensor.Algorithm.Decomposition.ZCA.Perform.html": {
    "href": "api/Tensor.Algorithm.Decomposition.ZCA.Perform.html",
    "title": "Method Perform | Tensor for F#",
    "keywords": "Method Perform static member Perform: Tensor<'T> -> Tensor<'T> * PCAInfo<'T> Apply ZCA whitening. data must be of the form [sample, feature]. Returns a tensor of the form [sample, component]. Declaration static member Perform: data:Tensor<'T> -> Tensor<'T> * PCAInfo<'T> Parameters Type Name Description Tensor <'T> data Returns Type Description Tensor <'T> * PCAInfo <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.ITensorModule.nDims.html": {
    "href": "api/Tensor.ITensorModule.nDims.html",
    "title": "Method nDims | Tensor for F#",
    "keywords": "Method nDims val nDims: ITensor -> int Dimensionality of the tensor. Declaration val nDims: a:ITensor -> int Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description int Number of dimensions. See Also member NDims: unit -> int"
  },
  "api/Tensor.ITensorModule.nElems.html": {
    "href": "api/Tensor.ITensorModule.nElems.html",
    "title": "Method nElems | Tensor for F#",
    "keywords": "Method nElems val nElems: ITensor -> int64 Total number of elements within the tensor. Declaration val nElems: a:ITensor -> int64 Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description int64 Number of elements. See Also member NElems: unit -> int64"
  },
  "api/Tensor.ITensorModule.dataType.html": {
    "href": "api/Tensor.ITensorModule.dataType.html",
    "title": "Method dataType | Tensor for F#",
    "keywords": "Method dataType val dataType: ITensor -> Type Type of data stored within the tensor. Declaration val dataType: a:ITensor -> Type Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description System.Type Data type. See Also member DataType: unit -> Type"
  },
  "api/Tensor.ITensorModule.relayout.html": {
    "href": "api/Tensor.ITensorModule.relayout.html",
    "title": "Method relayout | Tensor for F#",
    "keywords": "Method relayout val relayout: TensorLayout -> ITensor -> ITensor Creates a tensor with the specified layout sharing its storage with the original tensor. Declaration val relayout: newLayout:TensorLayout -> a:ITensor -> ITensor Parameters Type Name Description TensorLayout newLayout The new tensor memory layout. ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member relayout: TensorLayout -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.range.html": {
    "href": "api/Tensor.ITensorModule.range.html",
    "title": "Method range | Tensor for F#",
    "keywords": "Method range val range: Rng list -> ITensor -> ITensor Get a slice (part) of the tensor. Declaration val range: rng:Rng list -> a:ITensor -> ITensor Parameters Type Name Description Rng list rng The range of the tensor to select. ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member range: Rng list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.allIdx.html": {
    "href": "api/Tensor.ITensorModule.allIdx.html",
    "title": "Method allIdx | Tensor for F#",
    "keywords": "Method allIdx val allIdx: ITensor -> seq<int64 list> Gets a sequence of all indices to enumerate all elements within the tensor. Declaration val allIdx: a:ITensor -> seq<int64 list> Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description seq < int64 list > Sequence of indicies. Remarks The sequence sequentially enumerates the indices of all elements of the tensor. See Also Tensor`1.allIdxOfDim"
  },
  "api/Tensor.ITensorModule.padLeft.html": {
    "href": "api/Tensor.ITensorModule.padLeft.html",
    "title": "Method padLeft | Tensor for F#",
    "keywords": "Method padLeft val padLeft: ITensor -> ITensor Insert a dimension of size one as the first dimension. Declaration val padLeft: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member padLeft: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.padRight.html": {
    "href": "api/Tensor.ITensorModule.padRight.html",
    "title": "Method padRight | Tensor for F#",
    "keywords": "Method padRight val padRight: ITensor -> ITensor Append a dimension of size one after the last dimension. Declaration val padRight: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member padRight: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.insertAxis.html": {
    "href": "api/Tensor.ITensorModule.insertAxis.html",
    "title": "Method insertAxis | Tensor for F#",
    "keywords": "Method insertAxis val insertAxis: int -> ITensor -> ITensor Insert a dimension of size one before the specifed dimension. Declaration val insertAxis: ax:int -> a:ITensor -> ITensor Parameters Type Name Description int ax The dimension to insert before. ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member insertAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.cutLeft.html": {
    "href": "api/Tensor.ITensorModule.cutLeft.html",
    "title": "Method cutLeft | Tensor for F#",
    "keywords": "Method cutLeft val cutLeft: ITensor -> ITensor Removes the first dimension. Declaration val cutLeft: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member cutLeft: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.cutRight.html": {
    "href": "api/Tensor.ITensorModule.cutRight.html",
    "title": "Method cutRight | Tensor for F#",
    "keywords": "Method cutRight val cutRight: ITensor -> ITensor Removes the last dimension. Declaration val cutRight: a:ITensor -> ITensor Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member cutRight: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.broadcastDim.html": {
    "href": "api/Tensor.ITensorModule.broadcastDim.html",
    "title": "Method broadcastDim | Tensor for F#",
    "keywords": "Method broadcastDim val broadcastDim: int -> int64 -> ITensor -> ITensor Broadcast a dimension to a specified size. Declaration val broadcastDim: dim:int -> size:int64 -> a:ITensor -> ITensor Parameters Type Name Description int dim The size-one dimension to broadcast. int64 size The size to broadcast to. ITensor a The tensor to operate on. Returns Type Description ITensor The resulting tensor. See Also static member broadcastDim: int -> int64 -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.ITensorModule.padToSame.html": {
    "href": "api/Tensor.ITensorModule.padToSame.html",
    "title": "Method padToSame | Tensor for F#",
    "keywords": "Method padToSame val padToSame: ITensor list -> ITensor list Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. Declaration val padToSame: xs:ITensor list -> ITensor list Parameters Type Name Description ITensor list xs A list of tensors to operate on. Returns Type Description ITensor list A list of the resulting tensors, all having the same dimensionality. See Also static member padToSame: Tensor<'T> list -> Tensor<'T> list"
  },
  "api/Tensor.ITensorModule.broadcastToSame.html": {
    "href": "api/Tensor.ITensorModule.broadcastToSame.html",
    "title": "Method broadcastToSame | Tensor for F#",
    "keywords": "Method broadcastToSame val broadcastToSame: ITensor list -> ITensor list Broadcasts all specified tensors to have the same shape. Declaration val broadcastToSame: xs:ITensor list -> ITensor list Parameters Type Name Description ITensor list xs A list of tensors to operate on. Returns Type Description ITensor list A list of the resulting tensors, all having the same shape. See Also static member broadcastToSame: Tensor<'T> list -> Tensor<'T> list"
  },
  "api/Tensor.ITensorModule.broadcastToSameInDims.html": {
    "href": "api/Tensor.ITensorModule.broadcastToSameInDims.html",
    "title": "Method broadcastToSameInDims | Tensor for F#",
    "keywords": "Method broadcastToSameInDims val broadcastToSameInDims: seq<int> * ITensor list -> ITensor list Broadcasts all specified tensors to have the same size in the specified dimensions. Declaration val broadcastToSameInDims: dims:seq<int> * xs:ITensor list -> ITensor list Parameters Type Name Description seq < int > dims A list of dimensions that should be broadcasted to have the same size. ITensor list xs A list of tensors to operate on. Returns Type Description ITensor list A list of the resulting tensors, all having the same size in the specified dimensions. See Also static member broadcastToSameInDims: seq<int> * Tensor<'T> list -> Tensor<'T> list"
  },
  "api/Tensor.ITensorModule.broadcastTo.html": {
    "href": "api/Tensor.ITensorModule.broadcastTo.html",
    "title": "Method broadcastTo | Tensor for F#",
    "keywords": "Method broadcastTo val broadcastTo: int64 list -> ITensor -> ITensor Broadcasts the specified tensor to the specified shape. Declaration val broadcastTo: shp:int64 list -> a:ITensor -> ITensor Parameters Type Name Description int64 list shp The target shape. ITensor a The tensor to operate on. Returns Type Description ITensor Tensor of shape shp . See Also static member broadcastTo: int64 list -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_Multiply.html": {
    "href": "api/Tensor.Tensor-1.op_Multiply.html",
    "title": "Operator ( * ) | Tensor for F#",
    "keywords": "Operator ( * ) static member ( * ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise multiplication. Declaration static member ( * ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Multiplies each element of tensor a with the corresponding element of tensor b and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a * b // c = [10.0; 18.0; 28.0] See Also member FillMultiply: Tensor<'T> -> Tensor<'T> -> unit static member ( * ): Tensor<'T> * 'T -> Tensor<'T> Element-wise multiplication with scalar. Declaration static member ( * ): a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( * ): Tensor<'T> * Tensor<'T> -> Tensor<'T> static member ( * ): 'T * Tensor<'T> -> Tensor<'T> Element-wise multiplication with scalar. Declaration static member ( * ): a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( * ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_Subtraction.html": {
    "href": "api/Tensor.Tensor-1.op_Subtraction.html",
    "title": "Operator ( - ) | Tensor for F#",
    "keywords": "Operator ( - ) static member ( - ): Tensor<'T> * Tensor<'T> -> Tensor<'T> Element-wise substraction. Declaration static member ( - ): a:Tensor<'T> * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Substracts each element of tensor b from the corresponding element of tensor a and returns the results as a new tensor. The tensors a and b must have the same type and storage. Broadcasting rules apply if a and b have different shapes. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let b = HostTensor.ofList [2.0; 3.0; 4.0] let c = a - b // c = [3.0; 3.0; 3.0] See Also member FillSubtract: Tensor<'T> -> Tensor<'T> -> unit static member ( - ): Tensor<'T> * 'T -> Tensor<'T> Element-wise substraction with scalar. Declaration static member ( - ): a:Tensor<'T> * b:'T -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor on the left side of this binary operation. 'T b The scalar on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( - ): Tensor<'T> * Tensor<'T> -> Tensor<'T> static member ( - ): 'T * Tensor<'T> -> Tensor<'T> Element-wise substraction with scalar. Declaration static member ( - ): a:'T * b:Tensor<'T> -> Tensor<'T> Parameters Type Name Description 'T a The scalar on the left side of this binary operation. Tensor <'T> b The tensor on the right side of this binary operation. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. See Also static member ( - ): Tensor<'T> * Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.op_TwiddleTwiddleTwiddleTwiddle.html": {
    "href": "api/Tensor.Tensor-1.op_TwiddleTwiddleTwiddleTwiddle.html",
    "title": "Operator ( ~~~~ ) | Tensor for F#",
    "keywords": "Operator ( ~~~~ ) static member ( ~~~~ ): Tensor<bool> -> Tensor<bool> Element-wise logical negation. Declaration static member ( ~~~~ ): a:Tensor<bool> -> Tensor<bool> Parameters Type Name Description Tensor < bool > a The tensor to apply this operation to. Returns Type Description Tensor < bool > A new tensor containing the result of this operation. Remarks Logically negates each element of the specified tensor and returns the results as a new tensor. Examples let a = HostTensor.ofList [true; false] let b = ~~~~a // b = [false; true] See Also member FillNegate: Tensor<bool> -> unit"
  },
  "api/Tensor.Tensor-1.op_UnaryNegation.html": {
    "href": "api/Tensor.Tensor-1.op_UnaryNegation.html",
    "title": "Operator ( ~- ) | Tensor for F#",
    "keywords": "Operator ( ~- ) static member ( ~- ): Tensor<'T> -> Tensor<'T> Element-wise negation. Declaration static member ( ~- ): a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Negates each element of tensor a and returns the result as a new tensor. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let c = -a // c = [-5.0; -6.0; -7.0] See Also member FillNegate: Tensor<bool> -> unit"
  },
  "api/Tensor.Tensor-1.op_UnaryPlus.html": {
    "href": "api/Tensor.Tensor-1.op_UnaryPlus.html",
    "title": "Operator ( ~+ ) | Tensor for F#",
    "keywords": "Operator ( ~+ ) static member ( ~+ ): Tensor<'T> -> Tensor<'T> Element-wise prefix plus. Declaration static member ( ~+ ): a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks Applies the unary plus operator to each element of tensor a and returns the result as a new tensor. For most data types, this operation does not change the value. Examples let a = HostTensor.ofList [5.0; 6.0; 7.0] let c = +a // c = [5.0; 6.0; 7.0] See Also member FillUnaryPlus: Tensor<'T> -> unit"
  },
  "api/Tensor.Tensor-1.padLeft.html": {
    "href": "api/Tensor.Tensor-1.padLeft.html",
    "title": "Method padLeft | Tensor for F#",
    "keywords": "Method padLeft static member padLeft: Tensor<'T> -> Tensor<'T> Insert a dimension of size one as the first dimension. Declaration static member padLeft: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 4L; 5L] let b = Tensor.padLeft a // b.Shape = [1L; 3L; 4L; 5L] See Also static member padRight: Tensor<'T> -> Tensor<'T> static member insertAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.padRight.html": {
    "href": "api/Tensor.Tensor-1.padRight.html",
    "title": "Method padRight | Tensor for F#",
    "keywords": "Method padRight static member padRight: Tensor<'T> -> Tensor<'T> Append a dimension of size one after the last dimension. Declaration static member padRight: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. Remarks The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [3L; 4L; 5L] let b = Tensor.padRight a // b.Shape = [3L; 4L; 5L; 1L] See Also static member padLeft: Tensor<'T> -> Tensor<'T> static member insertAxis: int -> Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.padToSame.html": {
    "href": "api/Tensor.Tensor-1.padToSame.html",
    "title": "Method padToSame | Tensor for F#",
    "keywords": "Method padToSame static member padToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. Declaration static member padToSame: a:Tensor<'TA> * b:Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> Parameters Type Name Description Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> A tuple of the resulting tensors, all having the same dimensionality. Type Parameters Name Description 'TA 'TB Remarks Size one dimensions are added from the left to each tensor until all of them have the same dimensionality. The operation returns a view of the original tensor and shares its storage. Modifications done to the returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view. Examples let a = HostTensor.zeros [4L; 5L] let b = HostTensor.zeros [3L; 4L; 5L] let pa, pb = Tensor.padToSame (a, b) // pa.Shape = [1L; 4L; 5L]; pb.Shape = [3L; 4L; 5L] See Also static member padLeft: Tensor<'T> -> Tensor<'T> static member broadcastToSame: Tensor<'T> list -> Tensor<'T> list static member padToSame: Tensor<'TA> * Tensor<'TB> * Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. Declaration static member padToSame: a:Tensor<'TA> * b:Tensor<'TB> * c:Tensor<'TC> -> Tensor<'TA> * Tensor<'TB> * Tensor<'TC> Parameters Type Name Description Tensor <'TA> a The tensor to operate on. Tensor <'TB> b The tensor to operate on. Tensor <'TC> c The tensor to operate on. Returns Type Description Tensor <'TA> * Tensor <'TB> * Tensor <'TC> A tuple of the resulting tensors, all having the same dimensionality. Type Parameters Name Description 'TA 'TB 'TC See Also static member padToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB> static member padToSame: Tensor<'T> list -> Tensor<'T> list Pads all specified tensors from the left with dimensions of size one until they have the same dimensionality. Declaration static member padToSame: xs:Tensor<'T> list -> Tensor<'T> list Parameters Type Name Description Tensor <'T> list xs A list of tensors to operate on. Returns Type Description Tensor <'T> list A list of the resulting tensors, all having the same dimensionality. See Also static member padToSame: Tensor<'TA> * Tensor<'TB> -> Tensor<'TA> * Tensor<'TB>"
  },
  "api/Tensor.Tensor-1.permuteAxes.html": {
    "href": "api/Tensor.Tensor-1.permuteAxes.html",
    "title": "Method permuteAxes | Tensor for F#",
    "keywords": "Method permuteAxes static member permuteAxes: int list -> Tensor<'T> -> Tensor<'T> Permutes the axes as specified. Declaration static member permuteAxes: permut:int list -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int list permut The permutation to apply to the dimensions of tensor. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The tensor with the dimensions permuted. Remarks Each entry in the specified permutation specifies the new position of the corresponding axis, i.e. to which position the axis moves. A view of the original tensor is returned and the storage is shared. Modifications done to the returned tensor will affect the original tensor. Examples let a = HostTensor.zeros [0L; 11L; 22L; 33L; 44L] let b = Tensor.permuteAxes [3; 2; 4; 1; 0] a // b.Shape = [44L; 33L; 11L; 0L; 22L] See Also static member swapDim: int -> int -> Tensor<'T> -> Tensor<'T> member T: unit -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.product.html": {
    "href": "api/Tensor.Tensor-1.product.html",
    "title": "Method product | Tensor for F#",
    "keywords": "Method product static member product: Tensor<'T> -> 'T Calculates the product of all elements. Declaration static member product: src:Tensor<'T> -> 'T Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description 'T A scalar containing the result of this operation. Remarks The product of all elements is calculated. An empty product equals one. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.product a // b = 40320.0 See Also static member productAxis: int -> Tensor<'T> -> Tensor<'T> static member productTensor: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.productAxis.html": {
    "href": "api/Tensor.Tensor-1.productAxis.html",
    "title": "Method productAxis | Tensor for F#",
    "keywords": "Method productAxis static member productAxis: int -> Tensor<'T> -> Tensor<'T> Calculates the product of the elements along the specified axis. Declaration static member productAxis: ax:int -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to calculate the product along. Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The product is calculated along the specified axis. An empty product equals one. Examples let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0] [5.0; 6.0; 7.0; 8.0]] let b = Tensor.productAxis 1 a // b = [24.0; 1680.0] See Also member FillProductAxis: int -> Tensor<'T> -> unit static member product: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.productTensor.html": {
    "href": "api/Tensor.Tensor-1.productTensor.html",
    "title": "Method productTensor | Tensor for F#",
    "keywords": "Method productTensor static member productTensor: Tensor<'T> -> Tensor<'T> Calculates the product all elements returning a Tensor. Declaration static member productTensor: src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> src The tensor containing the source values. Returns Type Description Tensor <'T> A new scalar tensor containing the result of this operation. See Also static member product: Tensor<'T> -> 'T"
  },
  "api/Tensor.Tensor-1.pseudoInvert.html": {
    "href": "api/Tensor.Tensor-1.pseudoInvert.html",
    "title": "Method pseudoInvert | Tensor for F#",
    "keywords": "Method pseudoInvert static member pseudoInvert: Tensor<'T> * 'T option -> Tensor<'T> Computes the (batched) Moore-Penrose pseudo-inverse of the specified matrix. Declaration static member pseudoInvert: a:Tensor<'T> * rCond:'T option -> Tensor<'T> Parameters Type Name Description Tensor <'T> a The input matrix or tensor to this operation. 'T option rCond The cut-off value for the singular values. (default: 1e-15) Returns Type Description Tensor <'T> A new matrix or tensor containing the result of this operation. Remarks If a is a matrix, its pseudo-inverse is computed. The result is a matrix. If a is a tensor of shape [b_1; ...; b_n; i; j] , the pseudo-inverse of all matrices consisting of the last two dimensions of the tensor are computed. The result is a tensor of shape [b_1; ...; b_n; j; i] . See Also member FillPseudoInvert: Tensor<'T> * 'T option -> unit static member invert: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.range.html": {
    "href": "api/Tensor.Tensor-1.range.html",
    "title": "Method range | Tensor for F#",
    "keywords": "Method range static member range: Rng list -> Tensor<'T> -> Tensor<'T> Get a slice (part) of the tensor. Declaration static member range: rng:Rng list -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Rng list rng The range of the tensor to select. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor. See Also member Item: Rng list -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.relayout.html": {
    "href": "api/Tensor.Tensor-1.relayout.html",
    "title": "Method relayout | Tensor for F#",
    "keywords": "Method relayout static member relayout: TensorLayout -> Tensor<'T> -> Tensor<'T> Creates a tensor with the specified layout sharing its storage with the original tensor. Declaration static member relayout: newLayout:TensorLayout -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description TensorLayout newLayout The new tensor memory layout. Tensor <'T> a The tensor to operate on. Returns Type Description Tensor <'T> The resulting tensor."
  },
  "api/Tensor.Tensor-1.replicate.html": {
    "href": "api/Tensor.Tensor-1.replicate.html",
    "title": "Method replicate | Tensor for F#",
    "keywords": "Method replicate static member replicate: int -> int64 -> Tensor<'T> -> Tensor<'T> Repeats the tensor along an axis. Declaration static member replicate: ax:int -> reps:int64 -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax The axis to repeat along. int64 reps The number of repetitions. Tensor <'T> a The tensor to repeat. Returns Type Description Tensor <'T> The repeated tensor. Remarks The contents of a the tensors are replicated reps times in the specifed dimension. Examples let a = HostTensor.zeros [4L; 28L] let b = Tensor.replicate 0 10L a // b.Shape = [40L; 28L]"
  },
  "api/Tensor.HostTensor.filled.html": {
    "href": "api/Tensor.HostTensor.filled.html",
    "title": "Method filled | Tensor for F#",
    "keywords": "Method filled val filled: int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. Declaration val filled: shape:int64 list -> value:'T -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. 'T value The value to fill the new tensor with. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T See Also static member filled: ITensorDevice -> int64 list -> 'T -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.identity.html": {
    "href": "api/Tensor.HostTensor.identity.html",
    "title": "Method identity | Tensor for F#",
    "keywords": "Method identity val identity: int64 -> Tensor<'T> Creates a new identity matrix. Declaration val identity: size:int64 -> Tensor<'T> Parameters Type Name Description int64 size The size of the square identity matrix. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member identity: ITensorDevice -> int64 -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.counting.html": {
    "href": "api/Tensor.HostTensor.counting.html",
    "title": "Method counting | Tensor for F#",
    "keywords": "Method counting val counting: int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. Declaration val counting: nElems:int64 -> Tensor<int64> Parameters Type Name Description int64 nElems The number of elements of the new vector. Returns Type Description Tensor < int64 > The new tensor. See Also static member counting: ITensorDevice -> int64 -> Tensor<int64>"
  },
  "api/Tensor.HostTensor.arange.html": {
    "href": "api/Tensor.HostTensor.arange.html",
    "title": "Method arange | Tensor for F#",
    "keywords": "Method arange val arange: 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. Declaration val arange: start:'T -> incr:'T -> stop:'T -> Tensor<'T> Parameters Type Name Description 'T start The starting value. 'T incr The increment between successive element. 'T stop The end value, which is not included. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also Tensor`1.arange``3"
  },
  "api/Tensor.HostTensor.linspace.html": {
    "href": "api/Tensor.HostTensor.linspace.html",
    "title": "Method linspace | Tensor for F#",
    "keywords": "Method linspace val linspace: 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. Declaration val linspace: start:'T -> stop:'T -> nElems:int64 -> Tensor<'T> Parameters Type Name Description 'T start The starting value. 'T stop The end value, which is not included. int64 nElems The size of the vector. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also Tensor`1.linspace``2"
  },
  "api/Tensor.HostTensor.usingArray.html": {
    "href": "api/Tensor.HostTensor.usingArray.html",
    "title": "Method usingArray | Tensor for F#",
    "keywords": "Method usingArray val usingArray: 'T [] -> Tensor<'T> Creates a one-dimensional tensor referencing the specified data. Declaration val usingArray: data:'T [] -> Tensor<'T> Parameters Type Name Description 'T [] data The data array to use. Returns Type Description Tensor <'T> A tensor using the array data as its storage. Type Parameters Name Description 'T The type of the data. Remarks The data array is referenced, not copied. Thus changing the tensor modifies the specified data array and vice versa. See Also val ofArray: 'T [] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofArray.html": {
    "href": "api/Tensor.HostTensor.ofArray.html",
    "title": "Method ofArray | Tensor for F#",
    "keywords": "Method ofArray val ofArray: 'T [] -> Tensor<'T> Creates a one-dimensional tensor copying the specified data. Declaration val ofArray: data:'T [] -> Tensor<'T> Parameters Type Name Description 'T [] data The data array to use. Returns Type Description Tensor <'T> A tensor filled with the values from data . Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val usingArray: 'T [] -> Tensor<'T> val ofArray2D: 'T [,] -> Tensor<'T> val ofArray3D: 'T [,,] -> Tensor<'T> val ofArray4D: 'T [,,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofArray2D.html": {
    "href": "api/Tensor.HostTensor.ofArray2D.html",
    "title": "Method ofArray2D | Tensor for F#",
    "keywords": "Method ofArray2D val ofArray2D: 'T [,] -> Tensor<'T> Creates a two-dimensional tensor copying the specified data. Declaration val ofArray2D: data:'T [,] -> Tensor<'T> Parameters Type Name Description 'T [,] data The data array to use. Returns Type Description Tensor <'T> A tensor using filled with the values from data . Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val ofArray: 'T [] -> Tensor<'T> val ofArray3D: 'T [,,] -> Tensor<'T> val ofArray4D: 'T [,,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofArray3D.html": {
    "href": "api/Tensor.HostTensor.ofArray3D.html",
    "title": "Method ofArray3D | Tensor for F#",
    "keywords": "Method ofArray3D val ofArray3D: 'T [,,] -> Tensor<'T> Creates a three-dimensional tensor copying the specified data. Declaration val ofArray3D: data:'T [,,] -> Tensor<'T> Parameters Type Name Description 'T [,,] data The data array to use. Returns Type Description Tensor <'T> A tensor using filled with the values from data . Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val ofArray: 'T [] -> Tensor<'T> val ofArray2D: 'T [,] -> Tensor<'T> val ofArray4D: 'T [,,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofArray4D.html": {
    "href": "api/Tensor.HostTensor.ofArray4D.html",
    "title": "Method ofArray4D | Tensor for F#",
    "keywords": "Method ofArray4D val ofArray4D: 'T [,,,] -> Tensor<'T> Creates a four-dimensional tensor copying the specified data. Declaration val ofArray4D: data:'T [,,,] -> Tensor<'T> Parameters Type Name Description 'T [,,,] data The data array to use. Returns Type Description Tensor <'T> A tensor using filled with the values from data . Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val ofArray: 'T [] -> Tensor<'T> val ofArray2D: 'T [,] -> Tensor<'T> val ofArray3D: 'T [,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofSeq.html": {
    "href": "api/Tensor.HostTensor.ofSeq.html",
    "title": "Method ofSeq | Tensor for F#",
    "keywords": "Method ofSeq val ofSeq: seq<'T> -> Tensor<'T> Creates a one-dimensional tensor from the specified sequence. Declaration val ofSeq: data:seq<'T> -> Tensor<'T> Parameters Type Name Description seq <'T> data The data to fill the tensor with. Returns Type Description Tensor <'T> A tensor containing values from the specifed sequence. Type Parameters Name Description 'T The type of the data. Remarks The sequence must be finite. See Also val ofSeqWithShape: int64 list -> seq<'T> -> Tensor<'T> val ofList: 'T list -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofSeqWithShape.html": {
    "href": "api/Tensor.HostTensor.ofSeqWithShape.html",
    "title": "Method ofSeqWithShape | Tensor for F#",
    "keywords": "Method ofSeqWithShape val ofSeqWithShape: int64 list -> seq<'T> -> Tensor<'T> Creates a one-dimensional Tensor using the specified sequence and shape. Declaration val ofSeqWithShape: shape:int64 list -> data:seq<'T> -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. seq <'T> data The data to fill the tensor with. Returns Type Description Tensor <'T> A tensor containing values from the specifed sequence. Type Parameters Name Description 'T The type of the data. Remarks Only the number of elements required to fill the tensor of the specified shape are consumed from the sequence. Thus it may be infinite. See Also val ofSeq: seq<'T> -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toSeq.html": {
    "href": "api/Tensor.HostTensor.toSeq.html",
    "title": "Method toSeq | Tensor for F#",
    "keywords": "Method toSeq val toSeq: Tensor<'T> -> seq<'T> A sequence of all elements contained in the tensor. Declaration val toSeq: a:Tensor<'T> -> seq<'T> Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description seq <'T> A sequence of all elements of the tensor. Type Parameters Name Description 'T The type of the data. Remarks The enumeration is done so that the last index is the fastest changing index. See Also val ofSeq: seq<'T> -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.ofList.html": {
    "href": "api/Tensor.HostTensor.ofList.html",
    "title": "Method ofList | Tensor for F#",
    "keywords": "Method ofList val ofList: 'T list -> Tensor<'T> Creates a one-dimensional tensor from the specified list. Declaration val ofList: data:'T list -> Tensor<'T> Parameters Type Name Description 'T list data The data to fill the tensor with. Returns Type Description Tensor <'T> A tensor containing values from the specifed list. Type Parameters Name Description 'T The type of the data. See Also val ofSeq: seq<'T> -> Tensor<'T> val ofList2D: 'T list list -> Tensor<'T> val toList: Tensor<'T> -> 'T list"
  },
  "api/Tensor.HostTensor.ofList2D.html": {
    "href": "api/Tensor.HostTensor.ofList2D.html",
    "title": "Method ofList2D | Tensor for F#",
    "keywords": "Method ofList2D val ofList2D: 'T list list -> Tensor<'T> Creates a two-dimensional tensor from the specified list of lists. Declaration val ofList2D: data:'T list list -> Tensor<'T> Parameters Type Name Description 'T list list data The data to fill the tensor with. Returns Type Description Tensor <'T> A tensor containing values from the specifed lists. Type Parameters Name Description 'T The type of the data. See Also val ofSeq: seq<'T> -> Tensor<'T> val ofList: 'T list -> Tensor<'T> val toList2D: Tensor<'T> -> 'T list list"
  },
  "api/Tensor.HostTensor.toArray.html": {
    "href": "api/Tensor.HostTensor.toArray.html",
    "title": "Method toArray | Tensor for F#",
    "keywords": "Method toArray val toArray: Tensor<'T> -> 'T [] Creates an array from a one-dimensional tensor. Declaration val toArray: ary:Tensor<'T> -> 'T [] Parameters Type Name Description Tensor <'T> ary Returns Type Description 'T [] An array containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toArray2D: Tensor<'T> -> 'T [,] val toArray3D: Tensor<'T> -> 'T [,,] val toArray4D: Tensor<'T> -> 'T [,,,] val ofArray: 'T [] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toArray2D.html": {
    "href": "api/Tensor.HostTensor.toArray2D.html",
    "title": "Method toArray2D | Tensor for F#",
    "keywords": "Method toArray2D val toArray2D: Tensor<'T> -> 'T [,] Creates an array from a two-dimensional tensor. Declaration val toArray2D: a:Tensor<'T> -> 'T [,] Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description 'T [,] An array containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toArray: Tensor<'T> -> 'T [] val toArray2D: Tensor<'T> -> 'T [,] val toArray3D: Tensor<'T> -> 'T [,,] val ofArray2D: 'T [,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toArray3D.html": {
    "href": "api/Tensor.HostTensor.toArray3D.html",
    "title": "Method toArray3D | Tensor for F#",
    "keywords": "Method toArray3D val toArray3D: Tensor<'T> -> 'T [,,] Creates an array from a three-dimensional tensor. Declaration val toArray3D: a:Tensor<'T> -> 'T [,,] Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description 'T [,,] An array containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toArray: Tensor<'T> -> 'T [] val toArray2D: Tensor<'T> -> 'T [,] val toArray4D: Tensor<'T> -> 'T [,,,] val ofArray3D: 'T [,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toArray4D.html": {
    "href": "api/Tensor.HostTensor.toArray4D.html",
    "title": "Method toArray4D | Tensor for F#",
    "keywords": "Method toArray4D val toArray4D: Tensor<'T> -> 'T [,,,] Creates an array from a four-dimensional tensor. Declaration val toArray4D: a:Tensor<'T> -> 'T [,,,] Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description 'T [,,,] An array containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toArray: Tensor<'T> -> 'T [] val toArray2D: Tensor<'T> -> 'T [,] val toArray3D: Tensor<'T> -> 'T [,,] val ofArray4D: 'T [,,,] -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toList.html": {
    "href": "api/Tensor.HostTensor.toList.html",
    "title": "Method toList | Tensor for F#",
    "keywords": "Method toList val toList: Tensor<'T> -> 'T list Creates a list from a one-dimensional tensor. Declaration val toList: a:Tensor<'T> -> 'T list Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description 'T list A list containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toList2D: Tensor<'T> -> 'T list list val ofList: 'T list -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.toList2D.html": {
    "href": "api/Tensor.HostTensor.toList2D.html",
    "title": "Method toList2D | Tensor for F#",
    "keywords": "Method toList2D val toList2D: Tensor<'T> -> 'T list list Creates a list of lists from a two-dimensional tensor. Declaration val toList2D: a:Tensor<'T> -> 'T list list Parameters Type Name Description Tensor <'T> a The tensor to operate on. Returns Type Description 'T list list A list of lists containing the values from the tensor. Type Parameters Name Description 'T The type of the data. Remarks The data is copied. See Also val toList: Tensor<'T> -> 'T list val ofList2D: 'T list list -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.write.html": {
    "href": "api/Tensor.HostTensor.write.html",
    "title": "Method write | Tensor for F#",
    "keywords": "Method write val write: HDF5 -> string -> ITensor -> unit Writes the tensor into the HDF5 file under the specfied HDF5 object path. Declaration val write: hdf5:HDF5 -> path:string -> x:ITensor -> unit Parameters Type Name Description HDF5 hdf5 The HDF5 file. string path The HDF5 object path. ITensor x The tensor to write. Examples let k = HostTensor.init [5L; 3L] (fun [|i; j|] -> 3.0 * float i + float j) use hdfFile = HDF5.OpenWrite \"tensors.h5\" HostTensor.write hdfFile \"k\" k"
  },
  "api/Tensor.HostTensor.read.html": {
    "href": "api/Tensor.HostTensor.read.html",
    "title": "Method read | Tensor for F#",
    "keywords": "Method read val read: HDF5 -> string -> Tensor<'T> Reads a tensor from the specified HDF5 object path in an HDF5 file. Declaration val read: hdf5:HDF5 -> path:string -> Tensor<'T> Parameters Type Name Description HDF5 hdf5 The HDF5 file. string path The HDF5 object path. Returns Type Description Tensor <'T> A tensor filled with data read from the HDF5 file. Type Parameters Name Description 'T The type of the data. This must match the type of the data stored in the HDF5 file. Examples use hdfFile = HDF5.OpenRead \"tensors.h5\" let k = HostTensor.read<float> hdfFile \"k\" Exceptions Type Condition System.InvalidOperationException The data type stored in the HDF5 does not match type 'T . See Also val write: HDF5 -> string -> ITensor -> unit val readUntyped: HDF5 -> string -> ITensor"
  },
  "api/Tensor.HostTensor.readUntyped.html": {
    "href": "api/Tensor.HostTensor.readUntyped.html",
    "title": "Method readUntyped | Tensor for F#",
    "keywords": "Method readUntyped val readUntyped: HDF5 -> string -> ITensor Reads a tensor with unspecified data type from the specified HDF5 object path in an HDF5 file. Declaration val readUntyped: hdf5:HDF5 -> path:string -> ITensor Parameters Type Name Description HDF5 hdf5 The HDF5 file. string path The HDF5 object path. Returns Type Description ITensor A tensor filled with data read from the HDF5 file. See Also val read: HDF5 -> string -> Tensor<'T>"
  },
  "api/Tensor.HostTensor.randomInt.html": {
    "href": "api/Tensor.HostTensor.randomInt.html",
    "title": "Method randomInt | Tensor for F#",
    "keywords": "Method randomInt val randomInt: Random -> int * int -> int64 list -> Tensor<int> Creates a tensor filled with random integer numbers from a uniform distribution. Declaration val randomInt: rnd:Random -> minValue:int * maxValue:int -> shp:int64 list -> Tensor<int> Parameters Type Name Description System.Random rnd The random generator to use. int minValue The minimum value. int maxValue The maximum value. int64 list shp The shape of the new tensor. Returns Type Description Tensor < int > A tensor of specified shape filled with random numbers."
  },
  "api/Tensor.HostTensor.randomUniform.html": {
    "href": "api/Tensor.HostTensor.randomUniform.html",
    "title": "Method randomUniform | Tensor for F#",
    "keywords": "Method randomUniform val randomUniform: Random -> 'T * 'T -> int64 list -> Tensor<'T> Creates a tensor filled with random floating-point numbers from a uniform distribution. Declaration val randomUniform: rnd:Random -> minValue:'T * maxValue:'T -> shp:int64 list -> Tensor<'T> Parameters Type Name Description System.Random rnd The random generator to use. 'T minValue The minimum value. 'T maxValue The maximum value. int64 list shp The shape of the new tensor. Returns Type Description Tensor <'T> A tensor of specified shape filled with random numbers. Type Parameters Name Description 'T"
  },
  "api/Tensor.HostTensor.randomNormal.html": {
    "href": "api/Tensor.HostTensor.randomNormal.html",
    "title": "Method randomNormal | Tensor for F#",
    "keywords": "Method randomNormal val randomNormal: Random -> 'T * 'T -> int64 list -> Tensor<'T> Creates a tensor filled with random numbers from a normale distribution. Declaration val randomNormal: rnd:Random -> mean:'T * variance:'T -> shp:int64 list -> Tensor<'T> Parameters Type Name Description System.Random rnd The random generator to use. 'T mean The mean of the normal distribution. 'T variance The variance of the normal distribution. int64 list shp The shape of the new tensor. Returns Type Description Tensor <'T> A tensor of specified shape filled with random numbers. Type Parameters Name Description 'T"
  },
  "api/Tensor.HostTensor.Fill.html": {
    "href": "api/Tensor.HostTensor.Fill.html",
    "title": "Method Fill | Tensor for F#",
    "keywords": "Method Fill val Fill: Tensor<'T> -> unit -> 'T -> unit Fills the tensor with the values returned by the function. Declaration val Fill: trgt:Tensor<'T> -> fn:unit -> 'T -> unit Parameters Type Name Description Tensor <'T> trgt The target tensor to fill. unit -> 'T fn A function that returns the values to fill the tensor with. Type Parameters Name Description 'T See Also HostTensor.Parallel.Fill``1"
  },
  "api/Tensor.HostTensor.FillSeq.html": {
    "href": "api/Tensor.HostTensor.FillSeq.html",
    "title": "Method FillSeq | Tensor for F#",
    "keywords": "Method FillSeq val FillSeq: Tensor<'T> -> seq<'T> -> unit Fills the tensor with the values returned by the given sequence. Declaration val FillSeq: trgt:Tensor<'T> -> data:seq<'T> -> unit Parameters Type Name Description Tensor <'T> trgt The target tensor to fill. seq <'T> data The sequence of data to fill the tensor with. Type Parameters Name Description 'T The type of the data."
  },
  "api/Tensor.HostTensor.FillMap.html": {
    "href": "api/Tensor.HostTensor.FillMap.html",
    "title": "Method FillMap | Tensor for F#",
    "keywords": "Method FillMap val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified function to all elements of the tensor using the specified tensor as target. Declaration val FillMap: trgt:Tensor<'T> -> fn:'TA -> 'T -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. 'TA -> 'T fn A function that takes a value from the input tensor and returns the corresponding output value. Tensor <'TA> a The input tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> HostTensor.Parallel.FillMap``2"
  },
  "api/Tensor.HostTensor.map.html": {
    "href": "api/Tensor.HostTensor.map.html",
    "title": "Method map | Tensor for F#",
    "keywords": "Method map val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified function to all elements of the tensor. Declaration val map: fn:'T -> 'R -> a:Tensor<'T> -> Tensor<'R> Parameters Type Name Description 'T -> 'R fn A function that takes a value from the input tensor and returns the corresponding output value. Tensor <'T> a The source tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'T The type of the data. 'R See Also val FillMap: Tensor<'T> -> 'TA -> 'T -> Tensor<'TA> -> unit val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> HostTensor.Parallel.map``2"
  },
  "api/Tensor.HostTensor.FillMapIndexed.html": {
    "href": "api/Tensor.HostTensor.FillMapIndexed.html",
    "title": "Method FillMapIndexed | Tensor for F#",
    "keywords": "Method FillMapIndexed val FillMapIndexed: Tensor<'T> -> int64 [] -> 'TA -> 'T -> Tensor<'TA> -> unit Applies to specified indexed function to all elements of the tensor using the specified tensor as target. Declaration val FillMapIndexed: trgt:Tensor<'T> -> fn:int64 [] -> 'TA -> 'T -> a:Tensor<'TA> -> unit Parameters Type Name Description Tensor <'T> trgt The output tensor to fill. int64 [] -> 'TA -> 'T fn A function that takes an index and the corresponding value from the input tensor and returns the corresponding output value. Tensor <'TA> a The input tensor. Type Parameters Name Description 'T The type of the data. 'TA See Also val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> HostTensor.Parallel.FillMapIndexed``2"
  },
  "api/Tensor.HostTensor.Parallel.mapi.html": {
    "href": "api/Tensor.HostTensor.Parallel.mapi.html",
    "title": "Method mapi | Tensor for F#",
    "keywords": "Method mapi val mapi: int64 [] -> 'T -> 'R -> Tensor<'T> -> Tensor<'R> Applies to specified indexed function to all elements of the tensor using multiple threads. Declaration val mapi: fn:int64 [] -> 'T -> 'R -> a:Tensor<'T> -> Tensor<'R> Parameters Type Name Description int64 [] -> 'T -> 'R fn A function that takes an index and the corresponding value from the input tensor and returns the corresponding output value. Tensor <'T> a The source tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'T The type of the data. 'R See Also val map: 'T -> 'R -> Tensor<'T> -> Tensor<'R>"
  },
  "api/Tensor.HostTensor.Parallel.map2.html": {
    "href": "api/Tensor.HostTensor.Parallel.map2.html",
    "title": "Method map2 | Tensor for F#",
    "keywords": "Method map2 val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified function to all elements of the two tensors using multiple threads. Declaration val map2: fn:'TA -> 'TB -> 'R -> a:Tensor<'TA> -> b:Tensor<'TB> -> Tensor<'R> Parameters Type Name Description 'TA -> 'TB -> 'R fn A function that takes a value from the first input tensor and a value from the second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'TA 'TB 'R See Also val map2: 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R>"
  },
  "api/Tensor.HostTensor.Parallel.mapi2.html": {
    "href": "api/Tensor.HostTensor.Parallel.mapi2.html",
    "title": "Method mapi2 | Tensor for F#",
    "keywords": "Method mapi2 val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R> Applies to specified indexed function to all elements of the two tensors using multiple threads. Declaration val mapi2: fn:int64 [] -> 'TA -> 'TB -> 'R -> a:Tensor<'TA> -> b:Tensor<'TB> -> Tensor<'R> Parameters Type Name Description int64 [] -> 'TA -> 'TB -> 'R fn A function that takes an index, the corresponding value from the first input and second input tensor and returns the corresponding output value. Tensor <'TA> a The first input tensor. Tensor <'TB> b The second input tensor. Returns Type Description Tensor <'R> The output tensor. Type Parameters Name Description 'TA 'TB 'R See Also val mapi2: int64 [] -> 'TA -> 'TB -> 'R -> Tensor<'TA> -> Tensor<'TB> -> Tensor<'R>"
  },
  "api/Tensor.HostTensor.Parallel.foldAxis.html": {
    "href": "api/Tensor.HostTensor.Parallel.foldAxis.html",
    "title": "Method foldAxis | Tensor for F#",
    "keywords": "Method foldAxis val foldAxis: 'T -> 'TA -> 'T -> 'T -> int -> Tensor<'TA> -> Tensor<'T> Applies to specified function to all elements of the tensor, threading an accumulator through the computation using multiple threads. Declaration val foldAxis: fn:'T -> 'TA -> 'T -> initial:'T -> axis:int -> a:Tensor<'TA> -> Tensor<'T> Parameters Type Name Description 'T -> 'TA -> 'T fn A function that takes a state value and a value from the input tensor and returns a new state value. 'T initial The initial state value. int axis The axis to fold over. Tensor <'TA> a The source tensor. Returns Type Description Tensor <'T> The output tensor containg the final states. Type Parameters Name Description 'T The type of the data. 'TA See Also val foldAxis: 'T -> 'TA -> 'T -> 'T -> int -> Tensor<'TA> -> Tensor<'T>"
  },
  "api/Tensor.Host.ITensorHostStorage.Pin.html": {
    "href": "api/Tensor.Host.ITensorHostStorage.Pin.html",
    "title": "Method Pin | Tensor for F#",
    "keywords": "Method Pin abstract member Pin: unit -> PinnedMemory pins the underlying data array and returns the corresponding pinned memory Declaration abstract member Pin: unit -> PinnedMemory Returns Type Description PinnedMemory"
  },
  "api/Tensor.Host.ITensorHostStorage.DataSizeInBytes.html": {
    "href": "api/Tensor.Host.ITensorHostStorage.DataSizeInBytes.html",
    "title": "Property DataSizeInBytes | Tensor for F#",
    "keywords": "Property DataSizeInBytes abstract property DataSizeInBytes: int64 size of underlying data array in bytes Declaration abstract property DataSizeInBytes: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Host.ITensorHostStorage.DataSize.html": {
    "href": "api/Tensor.Host.ITensorHostStorage.DataSize.html",
    "title": "Property DataSize | Tensor for F#",
    "keywords": "Property DataSize abstract property DataSize: int64 size of underlying data array in elements Declaration abstract property DataSize: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Host.ITensorHostStorage.Data.html": {
    "href": "api/Tensor.Host.ITensorHostStorage.Data.html",
    "title": "Property Data | Tensor for F#",
    "keywords": "Property Data abstract property Data: Array the underlying data array Declaration abstract property Data: Array with get Property Value Type Description System.Array"
  },
  "api/Tensor.Host.Cfg.BLASLib.html": {
    "href": "api/Tensor.Host.Cfg.BLASLib.html",
    "title": "Property BLASLib | Tensor for F#",
    "keywords": "Property BLASLib static property BLASLib: BLASLib The BLAS and LAPACK library to use. Declaration static property BLASLib: BLASLib with get, set Property Value Type Description BLASLib Remarks This setting is global to the all threads."
  },
  "api/Tensor.Host.BLASModule.LAPACK_ROW_MAJOR().html": {
    "href": "api/Tensor.Host.BLASModule.LAPACK_ROW_MAJOR().html",
    "title": "Field val LAPACK_ROW_MAJOR | Tensor for F#",
    "keywords": "Field val LAPACK_ROW_MAJOR Namespace : Tensor.Host Assembly : Tensor.dll Syntax val LAPACK_ROW_MAJOR: int Returns Type Description int"
  },
  "api/Tensor.Host.BLASModule.LAPACK_COL_MAJOR().html": {
    "href": "api/Tensor.Host.BLASModule.LAPACK_COL_MAJOR().html",
    "title": "Field val LAPACK_COL_MAJOR | Tensor for F#",
    "keywords": "Field val LAPACK_COL_MAJOR Namespace : Tensor.Host Assembly : Tensor.dll Syntax val LAPACK_COL_MAJOR: int Returns Type Description int"
  },
  "api/Tensor.Host.BLASLib.Vendor.html": {
    "href": "api/Tensor.Host.BLASLib.Vendor.html",
    "title": "Property Vendor | Tensor for F#",
    "keywords": "Property Vendor Vendor BLAS and LAPACK. Namespace : Tensor.Host Assembly : Tensor.dll Syntax | Vendor Remarks This uses the system BLAS and LAPACK libraries by loading the shared libaries with the following names. Windows: blas.dll and lapacke.dll. Linux: libblas.so and liblapacke.so. Mac OS: libblas.dylib and liblapacke.dylib."
  },
  "api/Tensor.Host.BLASLib.IntelMKL.html": {
    "href": "api/Tensor.Host.BLASLib.IntelMKL.html",
    "title": "Property IntelMKL | Tensor for F#",
    "keywords": "Property IntelMKL Intel MKL BLAS and LAPACK Namespace : Tensor.Host Assembly : Tensor.dll Syntax | IntelMKL"
  },
  "api/Tensor.Host.BLASLib.OpenBLAS.html": {
    "href": "api/Tensor.Host.BLASLib.OpenBLAS.html",
    "title": "Property OpenBLAS | Tensor for F#",
    "keywords": "Property OpenBLAS OpenBLAS BLAS and LAPACK Namespace : Tensor.Host Assembly : Tensor.dll Syntax | OpenBLAS"
  },
  "api/Tensor.Host.BLASLib.Custom.html": {
    "href": "api/Tensor.Host.BLASLib.Custom.html",
    "title": "Property Custom of blas: NativeLibName * lapack: NativeLibName | Tensor for F#",
    "keywords": "Property Custom of blas: NativeLibName * lapack: NativeLibName Custom BLAS and LAPACK libraries. Namespace : Tensor.Host Assembly : Tensor.dll Syntax | Custom of blas: NativeLibName * lapack: NativeLibName Parameters Type Name Description Tensor.Utils.NativeLibName blas Name of BLAS native library. Tensor.Utils.NativeLibName lapack Name of LAPACK native library."
  },
  "api/Tensor.Host.BLAS.F.html": {
    "href": "api/Tensor.Host.BLAS.F.html",
    "title": "Property F | Tensor for F#",
    "keywords": "Property F static property F: Impl Access to actual implementation Declaration static property F: Impl with get Property Value Type Description Impl"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Add.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Add.html",
    "title": "Method Add | Tensor for F#",
    "keywords": "Method Add interface ITensorBackend<'T> with member Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Add: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> * src2:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 ITensorFrontend <'T> src2 Overrides abstract member ITensorBackend.Add: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-AllLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-AllLastAxis.html",
    "title": "Method AllLastAxis | Tensor for F#",
    "keywords": "Method AllLastAxis interface ITensorBackend<'T> with member AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member AllLastAxis: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 Overrides abstract member ITensorBackend.AllLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-And.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-And.html",
    "title": "Method And | Tensor for F#",
    "keywords": "Method And interface ITensorBackend<'T> with member And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member And: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2 Overrides abstract member ITensorBackend.And: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-AnyLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-AnyLastAxis.html",
    "title": "Method AnyLastAxis | Tensor for F#",
    "keywords": "Method AnyLastAxis interface ITensorBackend<'T> with member AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member AnyLastAxis: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 Overrides abstract member ITensorBackend.AnyLastAxis: ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ArgMaxLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ArgMaxLastAxis.html",
    "title": "Method ArgMaxLastAxis | Tensor for F#",
    "keywords": "Method ArgMaxLastAxis interface ITensorBackend<'T> with member ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ArgMaxLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.ArgMaxLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ArgMinLastAxis.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-ArgMinLastAxis.html",
    "title": "Method ArgMinLastAxis | Tensor for F#",
    "keywords": "Method ArgMinLastAxis interface ITensorBackend<'T> with member ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member ArgMinLastAxis: trgt:ITensorFrontend<int64> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend < int64 > trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.ArgMinLastAxis: ITensorFrontend<int64> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Asin.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Asin.html",
    "title": "Method Asin | Tensor for F#",
    "keywords": "Method Asin interface ITensorBackend<'T> with member Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Asin: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Asin: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Atan.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Atan.html",
    "title": "Method Atan | Tensor for F#",
    "keywords": "Method Atan interface ITensorBackend<'T> with member Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Atan: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Atan: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedInvert.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedInvert.html",
    "title": "Method BatchedInvert | Tensor for F#",
    "keywords": "Method BatchedInvert interface ITensorBackend<'T> with member BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedInvert: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.BatchedInvert: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedMatMatDot.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedMatMatDot.html",
    "title": "Method BatchedMatMatDot | Tensor for F#",
    "keywords": "Method BatchedMatMatDot interface ITensorBackend<'T> with member BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedMatMatDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.BatchedMatMatDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedSVD.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-BatchedSVD.html",
    "title": "Method BatchedSVD | Tensor for F#",
    "keywords": "Method BatchedSVD interface ITensorBackend<'T> with member BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member BatchedSVD: trgtS:ITensorFrontend<'T> * trgtUV:ITensorFrontend<'T> * ITensorFrontend<'T> option * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgtS ITensorFrontend <'T> * ITensorFrontend <'T> option trgtUV ITensorFrontend <'T> src Overrides abstract member ITensorBackend.BatchedSVD: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> option * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Ceiling.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Ceiling.html",
    "title": "Method Ceiling | Tensor for F#",
    "keywords": "Method Ceiling interface ITensorBackend<'T> with member Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Ceiling: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Ceiling: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Convert.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Convert.html",
    "title": "Method Convert | Tensor for F#",
    "keywords": "Method Convert interface ITensorBackend<'T> with member Convert: ITensorFrontend<'T> * ITensorFrontend<'?153486> -> unit Declaration interface ITensorBackend<'T> with member Convert: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'?153486> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'?153486> src Type Parameters Name Description '? Overrides abstract member ITensorBackend.Convert: ITensorFrontend<'T> * ITensorFrontend<'T1> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Copy.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Copy.html",
    "title": "Method Copy | Tensor for F#",
    "keywords": "Method Copy interface ITensorBackend<'T> with member Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Copy: trgt:ITensorFrontend<'T> * src:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src Overrides abstract member ITensorBackend.Copy: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Cos.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Cos.html",
    "title": "Method Cos | Tensor for F#",
    "keywords": "Method Cos interface ITensorBackend<'T> with member Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Cos: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Cos: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Cosh.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Cosh.html",
    "title": "Method Cosh | Tensor for F#",
    "keywords": "Method Cosh interface ITensorBackend<'T> with member Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member Cosh: trgt:ITensorFrontend<'T> * src1:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> src1 Overrides abstract member ITensorBackend.Cosh: ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-VecVecDot.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-VecVecDot.html",
    "title": "Method VecVecDot | Tensor for F#",
    "keywords": "Method VecVecDot interface ITensorBackend<'T> with member VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit Declaration interface ITensorBackend<'T> with member VecVecDot: trgt:ITensorFrontend<'T> * a:ITensorFrontend<'T> * b:ITensorFrontend<'T> -> unit Parameters Type Name Description ITensorFrontend <'T> trgt ITensorFrontend <'T> a ITensorFrontend <'T> b Overrides abstract member ITensorBackend.VecVecDot: ITensorFrontend<'T> * ITensorFrontend<'T> * ITensorFrontend<'T> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Xor.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-Xor.html",
    "title": "Method Xor | Tensor for F#",
    "keywords": "Method Xor interface ITensorBackend<'T> with member Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit Declaration interface ITensorBackend<'T> with member Xor: trgt:ITensorFrontend<bool> * src1:ITensorFrontend<bool> * src2:ITensorFrontend<bool> -> unit Parameters Type Name Description ITensorFrontend < bool > trgt ITensorFrontend < bool > src1 ITensorFrontend < bool > src2 Overrides abstract member ITensorBackend.Xor: ITensorFrontend<bool> * ITensorFrontend<bool> * ITensorFrontend<bool> -> unit"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-get_Item.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-get_Item.html",
    "title": "Method Item | Tensor for F#",
    "keywords": "Method Item interface ITensorBackend<'T> with member Item: int64 [] -> 'T Declaration interface ITensorBackend<'T> with member Item: idx:int64 [] -> 'T Parameters Type Name Description int64 [] idx Returns Type Description 'T"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-set_Item.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.Tensor-Backend-ITensorBackend-1-set_Item.html",
    "title": "Method Item | Tensor for F#",
    "keywords": "Method Item interface ITensorBackend<'T> with member Item: int64 [] * 'T -> unit Declaration interface ITensorBackend<'T> with member Item: idx:int64 [] * value:'T -> unit Parameters Type Name Description int64 [] idx 'T value"
  },
  "api/Tensor.Cuda.TensorCudaBackend-1.DevicePtr.html": {
    "href": "api/Tensor.Cuda.TensorCudaBackend-1.DevicePtr.html",
    "title": "Property DevicePtr | Tensor for F#",
    "keywords": "Property DevicePtr property DevicePtr: nativeint device pointer to first element of this tensor Declaration property DevicePtr: nativeint with get Property Value Type Description nativeint"
  },
  "api/Tensor.Cuda.ITensorCudaStorage.DataSizeInBytes.html": {
    "href": "api/Tensor.Cuda.ITensorCudaStorage.DataSizeInBytes.html",
    "title": "Property DataSizeInBytes | Tensor for F#",
    "keywords": "Property DataSizeInBytes abstract property DataSizeInBytes: int64 Declaration abstract property DataSizeInBytes: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Cuda.ITensorCudaStorage.DataSize.html": {
    "href": "api/Tensor.Cuda.ITensorCudaStorage.DataSize.html",
    "title": "Property DataSize | Tensor for F#",
    "keywords": "Property DataSize abstract property DataSize: int64 Declaration abstract property DataSize: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Cuda.ITensorCudaStorage.ByteData.html": {
    "href": "api/Tensor.Cuda.ITensorCudaStorage.ByteData.html",
    "title": "Property ByteData | Tensor for F#",
    "keywords": "Property ByteData abstract property ByteData: CudaDeviceVariable<byte> Declaration abstract property ByteData: CudaDeviceVariable<byte> with get Property Value Type Description ManagedCuda.CudaDeviceVariable < byte >"
  },
  "api/Tensor.Algorithm.Rat.-ctor.html": {
    "href": "api/Tensor.Algorithm.Rat.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: BigInteger * BigInteger -> Rat Constructs a fraction from numerator and denominator. Declaration new: num:BigInteger * dnm:BigInteger -> Rat Parameters Type Name Description System.Numerics.BigInteger num System.Numerics.BigInteger dnm Returns Type Description Rat new: int32 * int32 -> Rat Constructs a fraction from numerator and denominator. Declaration new: num:int32 * dnm:int32 -> Rat Parameters Type Name Description int32 num int32 dnm Returns Type Description Rat new: uint32 * uint32 -> Rat Constructs a fraction from numerator and denominator. Declaration new: num:uint32 * dnm:uint32 -> Rat Parameters Type Name Description uint32 num uint32 dnm Returns Type Description Rat new: int64 * int64 -> Rat Constructs a fraction from numerator and denominator. Declaration new: num:int64 * dnm:int64 -> Rat Parameters Type Name Description int64 num int64 dnm Returns Type Description Rat new: uint64 * uint64 -> Rat Constructs a fraction from numerator and denominator. Declaration new: num:uint64 * dnm:uint64 -> Rat Parameters Type Name Description uint64 num uint64 dnm Returns Type Description Rat new: BigInteger -> Rat Constructs an integer rational number. Declaration new: value:BigInteger -> Rat Parameters Type Name Description System.Numerics.BigInteger value Returns Type Description Rat new: int32 -> Rat Constructs an integer rational number. Declaration new: value:int32 -> Rat Parameters Type Name Description int32 value Returns Type Description Rat new: uint32 -> Rat Constructs an integer rational number. Declaration new: value:uint32 -> Rat Parameters Type Name Description uint32 value Returns Type Description Rat new: int64 -> Rat Constructs an integer rational number. Declaration new: value:int64 -> Rat Parameters Type Name Description int64 value Returns Type Description Rat new: uint64 -> Rat Constructs an integer rational number. Declaration new: value:uint64 -> Rat Parameters Type Name Description uint64 value Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.Abs.html": {
    "href": "api/Tensor.Algorithm.Rat.Abs.html",
    "title": "Method Abs | Tensor for F#",
    "keywords": "Method Abs static member Abs: Rat -> Rat Declaration static member Abs: a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.Ceiling.html": {
    "href": "api/Tensor.Algorithm.Rat.Ceiling.html",
    "title": "Method Ceiling | Tensor for F#",
    "keywords": "Method Ceiling static member Ceiling: Rat -> Rat Declaration static member Ceiling: a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Rat.System-IComparable-1-CompareTo.html": {
    "href": "api/Tensor.Algorithm.Rat.System-IComparable-1-CompareTo.html",
    "title": "Method CompareTo | Tensor for F#",
    "keywords": "Method CompareTo interface IComparable<Rat> with member CompareTo: Rat -> int Declaration interface IComparable<Rat> with member CompareTo: b:Rat -> int Parameters Type Name Description Rat b Returns Type Description int Overrides abstract member System.IComparable.CompareTo: 'T -> int"
  },
  "api/Tensor.Algorithm.Rat.System-IComparable-CompareTo.html": {
    "href": "api/Tensor.Algorithm.Rat.System-IComparable-CompareTo.html",
    "title": "Method CompareTo | Tensor for F#",
    "keywords": "Method CompareTo interface IComparable with member CompareTo: obj -> int Declaration interface IComparable with member CompareTo: b:obj -> int Parameters Type Name Description obj b Returns Type Description int Overrides abstract member System.IComparable.CompareTo: obj -> int"
  },
  "api/Tensor.Algorithm.Rat.Equals.html": {
    "href": "api/Tensor.Algorithm.Rat.Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals override member Equals: obj -> bool Declaration override member Equals: b:obj -> bool Parameters Type Name Description obj b Returns Type Description bool"
  },
  "api/Tensor.Algorithm.Rat.System-IEquatable-1-Equals.html": {
    "href": "api/Tensor.Algorithm.Rat.System-IEquatable-1-Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals interface IEquatable<Rat> with member Equals: Rat -> bool Declaration interface IEquatable<Rat> with member Equals: b:Rat -> bool Parameters Type Name Description Rat b Returns Type Description bool Overrides abstract member System.IEquatable.Equals: 'T -> bool"
  },
  "api/Tensor.Algorithm.Rat.Floor.html": {
    "href": "api/Tensor.Algorithm.Rat.Floor.html",
    "title": "Method Floor | Tensor for F#",
    "keywords": "Method Floor static member Floor: Rat -> Rat Declaration static member Floor: a:Rat -> Rat Parameters Type Name Description Rat a Returns Type Description Rat"
  },
  "api/Tensor.Algorithm.Decomposition.ZCA.Reverse.html": {
    "href": "api/Tensor.Algorithm.Decomposition.ZCA.Reverse.html",
    "title": "Method Reverse | Tensor for F#",
    "keywords": "Method Reverse static member Reverse: Tensor<'T> * PCAInfo<'T> -> Tensor<'T> Reverses ZCA whitening. whitened must be of the form [sample, component]. Declaration static member Reverse: zcaed:Tensor<'T> * info:PCAInfo<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> zcaed PCAInfo <'T> info Returns Type Description Tensor <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Algorithm.Decomposition.PCA.-ctor.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCA.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: unit -> PCA Implicit constructor. Declaration new: unit -> PCA Returns Type Description PCA"
  },
  "api/Tensor.Algorithm.Decomposition.PCA.Perform.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCA.Perform.html",
    "title": "Method Perform | Tensor for F#",
    "keywords": "Method Perform static member Perform: Tensor<'T> * int64 option -> Tensor<'T> * PCAInfo<'T> Apply Principal Component Analysis (PCA) whitening. data must be of the form [sample, feature]. nComps optionally specifies how many components to keep. Returns a tensor of the form [sample, component]. Declaration static member Perform: data:Tensor<'T> * nComps:int64 option -> Tensor<'T> * PCAInfo<'T> Parameters Type Name Description Tensor <'T> data int64 option nComps Returns Type Description Tensor <'T> * PCAInfo <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Algorithm.Decomposition.PCA.Reverse.html": {
    "href": "api/Tensor.Algorithm.Decomposition.PCA.Reverse.html",
    "title": "Method Reverse | Tensor for F#",
    "keywords": "Method Reverse static member Reverse: Tensor<'T> * PCAInfo<'T> -> Tensor<'T> Reverses PCA whitening. whitened must be of the form [sample, component]. Declaration static member Reverse: whitened:Tensor<'T> * PCAInfo<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> whitened PCAInfo <'T> Returns Type Description Tensor <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Rng.Pretty.html": {
    "href": "api/Tensor.Rng.Pretty.html",
    "title": "Property Pretty | Tensor for F#",
    "keywords": "Property Pretty property Pretty: string Pretty string. Declaration property Pretty: string with get Property Value Type Description string"
  },
  "api/Tensor.Rng.All.html": {
    "href": "api/Tensor.Rng.All.html",
    "title": "Property All | Tensor for F#",
    "keywords": "Property All static property All: Rng All elements. Declaration static property All: Rng with get Property Value Type Description Rng"
  },
  "api/Tensor.Rng.Elem.html": {
    "href": "api/Tensor.Rng.Elem.html",
    "title": "Property Elem of int64 | Tensor for F#",
    "keywords": "Property Elem of int64 The single element specified. Namespace : Tensor Assembly : Tensor.dll Syntax | Elem of int64 Parameters Type Name Description int64"
  },
  "api/Tensor.Rng.Rng.html": {
    "href": "api/Tensor.Rng.Rng.html",
    "title": "Property Rng of first: int64 option * last: int64 option | Tensor for F#",
    "keywords": "Property Rng of first: int64 option * last: int64 option Range of elements, including first and last. Namespace : Tensor Assembly : Tensor.dll Syntax | Rng of first: int64 option * last: int64 option Parameters Type Name Description int64 option first int64 option last"
  },
  "api/Tensor.Rng.NewAxis.html": {
    "href": "api/Tensor.Rng.NewAxis.html",
    "title": "Property NewAxis | Tensor for F#",
    "keywords": "Property NewAxis Insert broadcastable axis of size 1. Namespace : Tensor Assembly : Tensor.dll Syntax | NewAxis"
  },
  "api/Tensor.Rng.AllFill.html": {
    "href": "api/Tensor.Rng.AllFill.html",
    "title": "Property AllFill | Tensor for F#",
    "keywords": "Property AllFill Take all elements of remaining dimensions. Namespace : Tensor Assembly : Tensor.dll Syntax | AllFill"
  },
  "api/Tensor.Operators.Sgn.html": {
    "href": "api/Tensor.Operators.Sgn.html",
    "title": "Method sgn | Tensor for F#",
    "keywords": "Method sgn val sgn: 'T -> 'T Sign of value returned using same type as input. Declaration [<CompiledName(\"Sgn\")>] val sgn: x:'T -> 'T Parameters Type Name Description 'T x Input value. Returns Type Description 'T If x<0 , then -1 . If x=0 , then 0 . If x>0 , then 1 . Type Parameters Name Description 'T Type of input and output values. Remarks In contrast, the F# builtin function sign returns an int regardless of the input data type. This calls static method Sgn on non-primitive types."
  },
  "api/Tensor.MatrixPart.Upper.html": {
    "href": "api/Tensor.MatrixPart.Upper.html",
    "title": "Property Upper | Tensor for F#",
    "keywords": "Property Upper Upper triangular part of the matrix. Namespace : Tensor Assembly : Tensor.dll Syntax | Upper"
  },
  "api/Tensor.MatrixPart.Lower.html": {
    "href": "api/Tensor.MatrixPart.Lower.html",
    "title": "Property Lower | Tensor for F#",
    "keywords": "Property Lower Lower triangular part of the matrix. Namespace : Tensor Assembly : Tensor.dll Syntax | Lower"
  },
  "api/Tensor.ITensorModule.layout.html": {
    "href": "api/Tensor.ITensorModule.layout.html",
    "title": "Method layout | Tensor for F#",
    "keywords": "Method layout val layout: ITensor -> TensorLayout Memory layout of the tensor. Declaration val layout: a:ITensor -> TensorLayout Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description TensorLayout Memory layout. See Also member Layout: unit -> TensorLayout"
  },
  "api/Tensor.ITensorModule.dev.html": {
    "href": "api/Tensor.ITensorModule.dev.html",
    "title": "Method dev | Tensor for F#",
    "keywords": "Method dev val dev: ITensor -> ITensorDevice Device the data of tensor is stored on. Declaration val dev: a:ITensor -> ITensorDevice Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description ITensorDevice Data storage device. See Also member Dev: unit -> ITensorDevice"
  },
  "api/Tensor.ITensorModule.shape.html": {
    "href": "api/Tensor.ITensorModule.shape.html",
    "title": "Method shape | Tensor for F#",
    "keywords": "Method shape val shape: ITensor -> int64 list Shape of the tensor. Declaration val shape: a:ITensor -> int64 list Parameters Type Name Description ITensor a The tensor to operate on. Returns Type Description int64 list Shape. See Also member Shape: unit -> int64 list"
  },
  "api/Tensor.Host.TensorHostStorage-1.Tensor-Backend-ITensorStorage-1-Backend.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Tensor-Backend-ITensorStorage-1-Backend.html",
    "title": "Method Backend | Tensor for F#",
    "keywords": "Method Backend interface ITensorStorage<'T> with member Backend: TensorLayout -> ITensorBackend<'T> Declaration interface ITensorStorage<'T> with member Backend: layout:TensorLayout -> ITensorBackend<'T> Parameters Type Name Description TensorLayout layout Returns Type Description ITensorBackend <'T> Overrides abstract member ITensorStorage.Backend: TensorLayout -> ITensorBackend<'T>"
  },
  "api/Tensor.Host.TensorHostStorage-1.Equals.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals override member Equals: obj -> bool Declaration override member Equals: other:obj -> bool Parameters Type Name Description obj other Returns Type Description bool"
  },
  "api/Tensor.Host.TensorHostStorage-1.GetHashCode.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.GetHashCode.html",
    "title": "Method GetHashCode | Tensor for F#",
    "keywords": "Method GetHashCode override member GetHashCode: unit -> int Declaration override member GetHashCode: unit -> int Returns Type Description int"
  },
  "api/Tensor.Host.TensorHostStorage-1.Pin.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Pin.html",
    "title": "Method Pin | Tensor for F#",
    "keywords": "Method Pin member Pin: unit -> PinnedMemory pins the underlying data array and returns the corresponding pinned memory Declaration member Pin: unit -> PinnedMemory Returns Type Description PinnedMemory"
  },
  "api/Tensor.Host.TensorHostStorage-1.Tensor-Host-ITensorHostStorage-Pin.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Tensor-Host-ITensorHostStorage-Pin.html",
    "title": "Method Pin | Tensor for F#",
    "keywords": "Method Pin interface ITensorHostStorage with member Pin: unit -> PinnedMemory Declaration interface ITensorHostStorage with member Pin: unit -> PinnedMemory Returns Type Description PinnedMemory Overrides abstract member ITensorHostStorage.Pin: unit -> PinnedMemory"
  },
  "api/Tensor.Host.TensorHostStorage-1.Tensor-Backend-ITensorStorage-1-get_Dev.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Tensor-Backend-ITensorStorage-1-get_Dev.html",
    "title": "Method Dev | Tensor for F#",
    "keywords": "Method Dev interface ITensorStorage with member Dev: unit -> ITensorDevice Declaration interface ITensorStorage with member Dev: unit -> ITensorDevice Returns Type Description ITensorDevice"
  },
  "api/Tensor.Host.TensorHostStorage-1.DataSizeInBytes.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.DataSizeInBytes.html",
    "title": "Property DataSizeInBytes | Tensor for F#",
    "keywords": "Property DataSizeInBytes property DataSizeInBytes: int64 size of underlying data array in bytes Declaration property DataSizeInBytes: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Host.TensorHostStorage-1.DataSize.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.DataSize.html",
    "title": "Property DataSize | Tensor for F#",
    "keywords": "Property DataSize property DataSize: int64 size of underlying data array in elements Declaration property DataSize: int64 with get Property Value Type Description int64"
  },
  "api/Tensor.Host.TensorHostStorage-1.Data.html": {
    "href": "api/Tensor.Host.TensorHostStorage-1.Data.html",
    "title": "Property Data | Tensor for F#",
    "keywords": "Property Data property Data: 'T [] the underlying data array Declaration property Data: 'T [] with get Property Value Type Description 'T []"
  },
  "api/Tensor.Host.TensorHostDevice.Create.html": {
    "href": "api/Tensor.Host.TensorHostDevice.Create.html",
    "title": "Method Create | Tensor for F#",
    "keywords": "Method Create override member Create: int64 -> ITensorStorage<'?123796> Declaration override member Create: nElems:int64 -> ITensorStorage<'?123796> Parameters Type Name Description int64 nElems Returns Type Description ITensorStorage <'?123796> Type Parameters Name Description '? Overrides abstract member BaseTensorDevice.Create: int64 -> ITensorStorage<'T>"
  },
  "api/Tensor.Host.TensorHostDevice.Zeroed.html": {
    "href": "api/Tensor.Host.TensorHostDevice.Zeroed.html",
    "title": "Property Zeroed | Tensor for F#",
    "keywords": "Property Zeroed override property Zeroed: bool Declaration override property Zeroed: bool with get Property Value Type Description bool Overrides abstract property BaseTensorDevice.Zeroed: bool"
  },
  "api/Tensor.Host.TensorHostDevice.Instance.html": {
    "href": "api/Tensor.Host.TensorHostDevice.Instance.html",
    "title": "Property Instance | Tensor for F#",
    "keywords": "Property Instance static property Instance: TensorHostDevice Declaration static property Instance: TensorHostDevice with get Property Value Type Description TensorHostDevice"
  },
  "api/Tensor.Host.TensorHostDevice.Id.html": {
    "href": "api/Tensor.Host.TensorHostDevice.Id.html",
    "title": "Property Id | Tensor for F#",
    "keywords": "Property Id override property Id: string Declaration override property Id: string with get Property Value Type Description string Overrides abstract property BaseTensorDevice.Id: string"
  },
  "api/Tensor.HDF5.CreateGroups.html": {
    "href": "api/Tensor.HDF5.CreateGroups.html",
    "title": "Method CreateGroups | Tensor for F#",
    "keywords": "Method CreateGroups member CreateGroups: string -> unit Creates the given group path. Declaration member CreateGroups: path:string -> unit Parameters Type Name Description string path HDF5 group path to create. Remarks All necessary parent groups are created automatically. If the group with the given path already exists, nothing happens."
  },
  "api/Tensor.HDF5.Dispose.html": {
    "href": "api/Tensor.HDF5.Dispose.html",
    "title": "Method Dispose | Tensor for F#",
    "keywords": "Method Dispose member Dispose: unit -> unit Closes the HDF5 file. Declaration member Dispose: unit -> unit"
  },
  "api/Tensor.HDF5.System-IDisposable-Dispose.html": {
    "href": "api/Tensor.HDF5.System-IDisposable-Dispose.html",
    "title": "Method Dispose | Tensor for F#",
    "keywords": "Method Dispose interface IDisposable with member Dispose: unit -> unit Closes the HDF5 file. Declaration interface IDisposable with member Dispose: unit -> unit Overrides abstract member System.IDisposable.Dispose: unit -> unit"
  },
  "api/Tensor.CudaTensor.falses.html": {
    "href": "api/Tensor.CudaTensor.falses.html",
    "title": "Method falses | Tensor for F#",
    "keywords": "Method falses val falses: int64 list -> Tensor<bool> Creates a new boolean tensor filled with falses. Declaration val falses: shape:int64 list -> Tensor<bool> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. See Also static member falses: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.CudaTensor.trues.html": {
    "href": "api/Tensor.CudaTensor.trues.html",
    "title": "Method trues | Tensor for F#",
    "keywords": "Method trues val trues: int64 list -> Tensor<bool> Creates a new boolean tensor filled with trues. Declaration val trues: shape:int64 list -> Tensor<bool> Parameters Type Name Description int64 list shape The shape of the new tensor. Returns Type Description Tensor < bool > The new tensor. See Also static member trues: ITensorDevice -> int64 list -> Tensor<bool>"
  },
  "api/Tensor.CudaTensor.scalar.html": {
    "href": "api/Tensor.CudaTensor.scalar.html",
    "title": "Method scalar | Tensor for F#",
    "keywords": "Method scalar val scalar: 'T -> Tensor<'T> Creates a new zero-dimensional (scalar) tensor with the specified value. Declaration val scalar: value:'T -> Tensor<'T> Parameters Type Name Description 'T value The value of the new, scalar tensor. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T See Also static member scalar: ITensorDevice -> 'T -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.filled.html": {
    "href": "api/Tensor.CudaTensor.filled.html",
    "title": "Method filled | Tensor for F#",
    "keywords": "Method filled val filled: int64 list -> 'T -> Tensor<'T> Creates a new tensor filled with the specified value. Declaration val filled: shape:int64 list -> value:'T -> Tensor<'T> Parameters Type Name Description int64 list shape The shape of the new tensor. 'T value The value to fill the new tensor with. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T See Also static member filled: ITensorDevice -> int64 list -> 'T -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.identity.html": {
    "href": "api/Tensor.CudaTensor.identity.html",
    "title": "Method identity | Tensor for F#",
    "keywords": "Method identity val identity: int64 -> Tensor<'T> Creates a new identity matrix. Declaration val identity: size:int64 -> Tensor<'T> Parameters Type Name Description int64 size The size of the square identity matrix. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also static member identity: ITensorDevice -> int64 -> Tensor<'T>"
  },
  "api/Tensor.CudaTensor.counting.html": {
    "href": "api/Tensor.CudaTensor.counting.html",
    "title": "Method counting | Tensor for F#",
    "keywords": "Method counting val counting: int64 -> Tensor<int64> Creates a new vector filled with the integers from zero to the specified maximum. Declaration val counting: nElems:int64 -> Tensor<int64> Parameters Type Name Description int64 nElems The number of elements of the new vector. Returns Type Description Tensor < int64 > The new tensor. See Also static member counting: ITensorDevice -> int64 -> Tensor<int64>"
  },
  "api/Tensor.CudaTensor.arange.html": {
    "href": "api/Tensor.CudaTensor.arange.html",
    "title": "Method arange | Tensor for F#",
    "keywords": "Method arange val arange: 'T -> 'T -> 'T -> Tensor<'T> Creates a new vector filled with equaly spaced values using a specifed increment. Declaration val arange: start:'T -> incr:'T -> stop:'T -> Tensor<'T> Parameters Type Name Description 'T start The starting value. 'T incr The increment between successive element. 'T stop The end value, which is not included. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also Tensor`1.arange``3"
  },
  "api/Tensor.CudaTensor.linspace.html": {
    "href": "api/Tensor.CudaTensor.linspace.html",
    "title": "Method linspace | Tensor for F#",
    "keywords": "Method linspace val linspace: 'T -> 'T -> int64 -> Tensor<'T> Creates a new vector of given size filled with equaly spaced values. Declaration val linspace: start:'T -> stop:'T -> nElems:int64 -> Tensor<'T> Parameters Type Name Description 'T start The starting value. 'T stop The end value, which is not included. int64 nElems The size of the vector. Returns Type Description Tensor <'T> The new tensor. Type Parameters Name Description 'T The data type of the new tensor. See Also Tensor`1.linspace``2"
  },
  "api/Tensor.CudaTensor.usingPtrAndType.html": {
    "href": "api/Tensor.CudaTensor.usingPtrAndType.html",
    "title": "Method usingPtrAndType | Tensor for F#",
    "keywords": "Method usingPtrAndType val usingPtrAndType: CUdeviceptr -> SizeT -> Type -> TensorLayout -> ITensor Creates a tensor from the given CUDA pointer, allocation size in bytes, type and layout. Declaration val usingPtrAndType: ptr:CUdeviceptr -> sizeInBytes:SizeT -> typ:Type -> layout:TensorLayout -> ITensor Parameters Type Name Description ManagedCuda.BasicTypes.CUdeviceptr ptr A CUDA device pointer. ManagedCuda.BasicTypes.SizeT sizeInBytes Size of the allocation referenced by ptr in bytes. System.Type typ Type of contained data. TensorLayout layout Layout of the tensor. Returns Type Description ITensor Remarks This function creates a tensor using existing data in GPU memory. The data is referenced. Thus changing values within the tensor affects the original data."
  },
  "api/Tensor.CudaTensor.usingPtr.html": {
    "href": "api/Tensor.CudaTensor.usingPtr.html",
    "title": "Method usingPtr | Tensor for F#",
    "keywords": "Method usingPtr val usingPtr: CUdeviceptr -> SizeT -> TensorLayout -> Tensor<'T> Creates a tensor from the given CUDA pointer, allocation size in bytes and layout. Declaration val usingPtr: ptr:CUdeviceptr -> sizeInBytes:SizeT -> layout:TensorLayout -> Tensor<'T> Parameters Type Name Description ManagedCuda.BasicTypes.CUdeviceptr ptr A CUDA device pointer. ManagedCuda.BasicTypes.SizeT sizeInBytes Size of the allocation referenced by ptr in bytes. TensorLayout layout Layout of the tensor. Returns Type Description Tensor <'T> Type Parameters Name Description 'T Type of contained data. Remarks This function creates a tensor using existing data in GPU memory. The data is referenced. Thus changing values within the tensor affects the original data."
  },
  "api/Tensor.Cuda.NativeIdxTensorsInfo.NDims.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensorsInfo.NDims.html",
    "title": "Field val NDims: int | Tensor for F#",
    "keywords": "Field val NDims: int Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val NDims: int Returns Type Description int"
  },
  "api/Tensor.Cuda.NativeIdxTensorsInfo.NIdxs.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensorsInfo.NIdxs.html",
    "title": "Field val NIdxs: int | Tensor for F#",
    "keywords": "Field val NIdxs: int Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val NIdxs: int Returns Type Description int"
  },
  "api/Tensor.Cuda.NativeIdxTensors.NDims.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensors.NDims.html",
    "title": "Field val NDims: int | Tensor for F#",
    "keywords": "Field val NDims: int Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val NDims: int Returns Type Description int"
  },
  "api/Tensor.Cuda.NativeIdxTensors.Idxs.html": {
    "href": "api/Tensor.Cuda.NativeIdxTensors.Idxs.html",
    "title": "Field val Idxs: NativeTensor option list | Tensor for F#",
    "keywords": "Field val Idxs: NativeTensor option list Namespace : Tensor.Cuda Assembly : Tensor.dll Syntax val Idxs: NativeTensor option list Returns Type Description NativeTensor option list"
  },
  "api/Tensor.Backend.ITensorDevice.Create.html": {
    "href": "api/Tensor.Backend.ITensorDevice.Create.html",
    "title": "Method Create | Tensor for F#",
    "keywords": "Method Create abstract member Create: int64 -> ITensorStorage<'T> Declaration abstract member Create: nElems:int64 -> ITensorStorage<'T> Parameters Type Name Description int64 nElems Returns Type Description ITensorStorage <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Backend.ITensorDevice.Zeroed.html": {
    "href": "api/Tensor.Backend.ITensorDevice.Zeroed.html",
    "title": "Property Zeroed | Tensor for F#",
    "keywords": "Property Zeroed abstract property Zeroed: bool Declaration abstract property Zeroed: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Backend.ITensorDevice.Id.html": {
    "href": "api/Tensor.Backend.ITensorDevice.Id.html",
    "title": "Property Id | Tensor for F#",
    "keywords": "Property Id abstract property Id: string Declaration abstract property Id: string with get Property Value Type Description string"
  },
  "api/Tensor.Backend.BaseTensorDevice.-ctor.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.-ctor.html",
    "title": "Constructor ( .ctor ) | Tensor for F#",
    "keywords": "Constructor ( .ctor ) new: unit -> BaseTensorDevice Implicit constructor. Declaration new: unit -> BaseTensorDevice Returns Type Description BaseTensorDevice"
  },
  "api/Tensor.Backend.BaseTensorDevice.System-IComparable-1-CompareTo.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.System-IComparable-1-CompareTo.html",
    "title": "Method CompareTo | Tensor for F#",
    "keywords": "Method CompareTo interface IComparable<ITensorDevice> with member CompareTo: ITensorDevice -> int Declaration interface IComparable<ITensorDevice> with member CompareTo: other:ITensorDevice -> int Parameters Type Name Description ITensorDevice other Returns Type Description int Overrides abstract member System.IComparable.CompareTo: 'T -> int"
  },
  "api/Tensor.Backend.BaseTensorDevice.System-IComparable-CompareTo.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.System-IComparable-CompareTo.html",
    "title": "Method CompareTo | Tensor for F#",
    "keywords": "Method CompareTo interface IComparable with member CompareTo: obj -> int Declaration interface IComparable with member CompareTo: other:obj -> int Parameters Type Name Description obj other Returns Type Description int Overrides abstract member System.IComparable.CompareTo: obj -> int"
  },
  "api/Tensor.Backend.BaseTensorDevice.Create.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.Create.html",
    "title": "Method Create | Tensor for F#",
    "keywords": "Method Create abstract member Create: int64 -> ITensorStorage<'T> Declaration abstract member Create: nElems:int64 -> ITensorStorage<'T> Parameters Type Name Description int64 nElems Returns Type Description ITensorStorage <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Backend.BaseTensorDevice.Tensor-Backend-ITensorDevice-Create.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.Tensor-Backend-ITensorDevice-Create.html",
    "title": "Method Create | Tensor for F#",
    "keywords": "Method Create interface ITensorDevice with member Create: int64 -> ITensorStorage<'?40621> Declaration interface ITensorDevice with member Create: nElems:int64 -> ITensorStorage<'?40621> Parameters Type Name Description int64 nElems Returns Type Description ITensorStorage <'?40621> Type Parameters Name Description '? Overrides abstract member ITensorDevice.Create: int64 -> ITensorStorage<'T>"
  },
  "api/Tensor.Backend.BaseTensorDevice.Equals.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals override member Equals: obj -> bool Declaration override member Equals: other:obj -> bool Parameters Type Name Description obj other Returns Type Description bool"
  },
  "api/Tensor.Backend.BaseTensorDevice.System-IEquatable-1-Equals.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.System-IEquatable-1-Equals.html",
    "title": "Method Equals | Tensor for F#",
    "keywords": "Method Equals interface IEquatable<ITensorDevice> with member Equals: ITensorDevice -> bool Declaration interface IEquatable<ITensorDevice> with member Equals: other:ITensorDevice -> bool Parameters Type Name Description ITensorDevice other Returns Type Description bool Overrides abstract member System.IEquatable.Equals: 'T -> bool"
  },
  "api/Tensor.Backend.BaseTensorDevice.GetHashCode.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.GetHashCode.html",
    "title": "Method GetHashCode | Tensor for F#",
    "keywords": "Method GetHashCode override member GetHashCode: unit -> int Declaration override member GetHashCode: unit -> int Returns Type Description int"
  },
  "api/Tensor.Backend.BaseTensorDevice.ToString.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.ToString.html",
    "title": "Method ToString | Tensor for F#",
    "keywords": "Method ToString override member ToString: unit -> string Declaration override member ToString: unit -> string Returns Type Description string"
  },
  "api/Tensor.Backend.BaseTensorDevice.Zeroed.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.Zeroed.html",
    "title": "Property Zeroed | Tensor for F#",
    "keywords": "Property Zeroed abstract property Zeroed: bool Declaration abstract property Zeroed: bool with get Property Value Type Description bool"
  },
  "api/Tensor.Backend.BaseTensorDevice.Id.html": {
    "href": "api/Tensor.Backend.BaseTensorDevice.Id.html",
    "title": "Property Id | Tensor for F#",
    "keywords": "Property Id abstract property Id: string Declaration abstract property Id: string with get Property Value Type Description string"
  },
  "api/Tensor.Algorithm.RatRecognizers.-Rat-.html": {
    "href": "api/Tensor.Algorithm.RatRecognizers.-Rat-.html",
    "title": "Method ( |Rat| ) | Tensor for F#",
    "keywords": "Method ( |Rat| ) val ( |Rat| ): Rat -> bigint * bigint decomposes a rational into its numerator and denominator Declaration val ( |Rat| ): a:Rat -> bigint * bigint Parameters Type Name Description Rat a Returns Type Description bigint * bigint"
  },
  "api/Tensor.Algorithm.RatRecognizers.-RatFrac-RatInt-RatPosInf-RatNegInf-RatNaN-.html": {
    "href": "api/Tensor.Algorithm.RatRecognizers.-RatFrac-RatInt-RatPosInf-RatNegInf-RatNaN-.html",
    "title": "Method ( |RatFrac|RatInt|RatPosInf|RatNegInf|RatNaN| ) | Tensor for F#",
    "keywords": "Method ( |RatFrac|RatInt|RatPosInf|RatNegInf|RatNaN| ) val ( |RatFrac|RatInt|RatPosInf|RatNegInf|RatNaN| ): Rat RatFrac(num,dnm) matches a true (finite) fraction and RatInteger(value) matches an integer rational number. Declaration val ( |RatFrac|RatInt|RatPosInf|RatNegInf|RatNaN| ): a:Rat -> | RatFrac of bigint * bigint | RatInt of bigint | RatPosInf | RatNegInf | RatNaN Parameters Type Name Description Rat a Returns Type Description Choice < bigint * bigint , bigint , unit , unit , unit >"
  },
  "api/Tensor.Algorithm.LinAlg.rowEchelonAugmented.html": {
    "href": "api/Tensor.Algorithm.LinAlg.rowEchelonAugmented.html",
    "title": "Method rowEchelonAugmented | Tensor for F#",
    "keywords": "Method rowEchelonAugmented val rowEchelonAugmented: Tensor<'T> -> Tensor<'T> -> Tensor<'T> * int64 * int64 list * Tensor<'T> Computes the reduced row echelon form of matrix L augmented with matrix A. Returns a tuple of (row echelon form, number of non-zero rows, list of non-normalized columns, transformed augmentation matrix). Declaration val rowEchelonAugmented: L:Tensor<'T> -> A:Tensor<'T> -> Tensor<'T> * int64 * int64 list * Tensor<'T> Parameters Type Name Description Tensor <'T> L Tensor <'T> A Returns Type Description Tensor <'T> * int64 * int64 list * Tensor <'T> Type Parameters Name Description 'T"
  },
  "api/Tensor.Algorithm.LinAlg.rowEchelon.html": {
    "href": "api/Tensor.Algorithm.LinAlg.rowEchelon.html",
    "title": "Method rowEchelon | Tensor for F#",
    "keywords": "Method rowEchelon val rowEchelon: Tensor<'T> -> Tensor<'T> * int64 * int64 list Computes the reduced row echelon form of the specified matrix. Returns a tuple of (row echelon form, number of non-zero rows, list of non-normalized columns). Declaration val rowEchelon: L:Tensor<'T> -> Tensor<'T> * int64 * int64 list Parameters Type Name Description Tensor <'T> L Returns Type Description Tensor <'T> * int64 * int64 list Type Parameters Name Description 'T"
  },
  "api/Tensor.Tensor-1.trace.html": {
    "href": "api/Tensor.Tensor-1.trace.html",
    "title": "Method trace | Tensor for F#",
    "keywords": "Method trace static member trace: Tensor<'T> -> Tensor<'T> Calculates the trace of the matrix. Declaration static member trace: a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description Tensor <'T> a A square matrix. Returns Type Description Tensor <'T> The trace of the matrix. Remarks The trace is is defined by the sum of the elements on the diagonal. The matrix must be square. If the specified tensor has more than two dimensions, the traces along the last two dimensions are returned as a tensor. Examples let a = HostTensor.zeros [3L; 3L] let b = Tensor.trace a See Also static member traceAxis: int -> int -> Tensor<'T> -> Tensor<'T> static member diag: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.traceAxis.html": {
    "href": "api/Tensor.Tensor-1.traceAxis.html",
    "title": "Method traceAxis | Tensor for F#",
    "keywords": "Method traceAxis static member traceAxis: int -> int -> Tensor<'T> -> Tensor<'T> Calculates the trace along the specified axes. Declaration static member traceAxis: ax1:int -> ax2:int -> a:Tensor<'T> -> Tensor<'T> Parameters Type Name Description int ax1 The first axis of the diagonal to compute the trace along. int ax2 The second axis of the diagonal to compute the trace along. Tensor <'T> a The tensor containing the source values. Returns Type Description Tensor <'T> A new tensor containing the result of this operation. Remarks The trace is calculated along the specified axes. It is defined by the sum of the elements on the diagonal. The tensor must have the same size in dimensions ax1 and ax2 . Examples let a = HostTensor.zeros [2L; 3L; 4L; 3L] let b = Tensor.traceAxis 1 3 a // b.Shape = [2L; 4L] See Also static member trace: Tensor<'T> -> Tensor<'T>"
  },
  "api/Tensor.Tensor-1.transfer.html": {
    "href": "api/Tensor.Tensor-1.transfer.html",
    "title": "Method transfer | Tensor for F#",
    "keywords": "Method transfer static member transfer: ITensorDevice -> Tensor<'T> -> Tensor<'T> Transfers a tensor to the specifed device. Declaration static member transfer: dev:ITensorDevice -> src:Tensor<'T> -> Tensor<'T> Parameters Type Name Description ITensorDevice dev The target device. Tensor <'T> src Returns Type Description Tensor <'T> A tensor on the target device. Remarks A new tensor is created on the specified device. The elements of the original tensor are copied into the new tensor. If the target device matches the current device of the tensor, the original tensor is returned. Examples let a = HostTensor.zeros [3L; 5L] // a.Dev = HostTensor.Dev let b = Tensor.transfer CudaTensor.Dev a // b.Dev = CudaTensor.Dev See Also member TransferFrom: Tensor<'T> -> unit member Dev: unit -> ITensorDevice static member copy: Tensor<'T> * TensorOrder option -> Tensor<'T>"
  }
}